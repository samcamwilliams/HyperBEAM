Generated: 2025-05-02T14:36:17Z

--- START OF FILE: docs/devices/index.md ---
# Devices

Devices are the core functional units within HyperBEAM and AO-Core. They define how messages are processed and what actions can be performed.

Each device listed here represents a specific capability available to AO processes and nodes. Understanding these devices is key to building complex applications and configuring your HyperBEAM node effectively.

## Available Devices

Below is a list of documented built-in devices. Each page details the device's purpose, status, available functions (keys), and usage examples where applicable.

*   **[`~message@1.0`](./message-at-1-0.md):** Base message handling and manipulation.
*   **[`~meta@1.0`](./meta-at-1-0.md):** Node configuration and metadata.
*   **[`~process@1.0`](./process-at-1-0.md):** Persistent, shared process execution environment.
*   **[`~scheduler@1.0`](./scheduler-at-1-0.md):** Message scheduling and execution ordering for processes.
*   **[`~wasm64@1.0`](./wasm64-at-1-0.md):** WebAssembly (WASM) execution engine.
*   **[`~lua@5.3a`](./lua-at-5-3a.md):** Lua script execution engine.
*   **[`~relay@1.0`](./relay-at-1-0.md):** Relaying messages to other nodes or HTTP endpoints.
*   **[`~json@1.0`](./json-at-1-0.md):** Provides access to JSON data structures using HyperPATHs.

*(More devices will be documented here as specifications are finalized and reviewed.)*

## Device Naming and Versioning

Devices are typically referenced using a name and version, like `~<name>@<version>` (e.g., `~process@1.0`). The tilde (`~`) often indicates a primary, user-facing device, while internal or utility devices might use a `dev_` prefix in the source code (e.g., `dev_router`).

Versioning indicates the specific interface and behavior of the device. Changes to a device that break backward compatibility usually result in a version increment.

## Status Indicators

Each device page will include a status indicator (e.g., `Stable`, `Beta`, `Experimental`) to help you gauge its production readiness and likelihood of future changes.

--- END OF FILE: docs/devices/index.md ---

--- START OF FILE: docs/devices/json-at-1-0.md ---
# Device: ~json@1.0

## Overview

The `json` device provides a structured way to access and interact with JSON (JavaScript Object Notation) data within the HyperBEAM environment. It allows processes to read, query, and potentially modify JSON objects stored or referenced by the device. It can also be used via HyperPATH chaining to serialize arbitrary data from other devices.

**Status:** Experimental <!-- TODO: Update status -->

## Core Functions (Keys)

These keys are typically accessed via HyperPATHs relative to the device's mount point (e.g., `/data/myJson`) or used in HyperPATH chains.

*   **`GET /<MountPoint>/<HyperPATH>` (Read Action)**
    *   **Action:** Retrieves the data located at the specified `<HyperPATH>` within the device's *own* stored JSON structure. The device serializes the targeted JSON fragment (object, array, value) into a standard JSON string format.
    *   **Example:** `GET /data/myJson/user/settings` on the example JSON below would return the string `"{\"theme\":\"dark\",\"notifications\":true}"`.
    *   **HyperPATH:** Required. Specifies the target within the device's JSON data.

*   **`/<PreviousPath>/serialize` (Serialize Action)**
    *   **Action:** Takes arbitrary input data (piped from the `<PreviousPath>` segment of a HyperPATH chain) and returns its serialized JSON string representation.
    *   **Example:** `GET /~meta@1.0/info /~json@1.0/serialize` - fetches node info and then pipes it to this device to serialize the result as JSON.
    *   **HyperPATH:** This segment (`/serialize`) is appended to a previous HyperPATH segment.

*   **`GET /<MountPoint>/query?<HyperPATHQuery>` (Query Action)**
    *   **Action:** Performs a more complex query against the device's *own* stored JSON data using a specific query syntax (details TBD).
    *   **Example:** <!-- TODO: Add Query example -->
    *   **HyperPATH:** Required. The base path to the device's data.
    *   **Query Parameter:** `?query=<HyperPATHQuery>` (Syntax TBD).

<!-- TODO: Add details on Update, Delete, or other potential actions -->

## Example JSON Data

Assuming `json` is mounted at `/data/myJson` and holds the following JSON:

```json
{
  "user": {
    "name": "Alice",
    "id": 123,
    "settings": {
      "theme": "dark",
      "notifications": true
    }
  },
  "items": [
    {"sku": "abc", "price": 10},
    {"sku": "def", "price": 20}
  ]
}
```

**Access Examples:**

-   Get user name: `GET /data/myJson/user/name`
-   Get theme setting: `GET /data/myJson/user/settings/theme`
-   Get first item price: `GET /data/myJson/items[0]/price`

## Events

<!-- TODO: Details about events emitted by the device, e.g., DataChanged -->

<!-- TODO: Link to source module if available --> 

[json module](../resources/source-code/dev_codec_json.md)
--- END OF FILE: docs/devices/json-at-1-0.md ---

--- START OF FILE: docs/devices/lua-at-5-3a.md ---
# Device: ~lua@5.3a

## Overview

The `~lua@5.3a` device enables the execution of Lua scripts within an AO process. It utilizes the `luerl` Erlang library to provide a Lua 5.3 compatible environment.

**Status:** Stable

## Core Concept: Lua Script Execution

This device allows processes to perform computations defined in Lua scripts. Similar to the `~wasm64@1.0` device, it manages the lifecycle of a Lua execution state associated with the process.

## Key Functions (Keys)

These keys are typically used within an execution stack (managed by `dev_stack`) for an AO process.

*   **`init`**
    *   **Action:** Initializes the Lua environment for the process. It finds and loads the Lua script(s) associated with the process, creates a `luerl` state, applies sandboxing rules if specified, installs the `dev_lua_lib` (providing AO-specific functions like `ao.send`), and stores the initialized state in the process's private area (`priv/state`).
    *   **Inputs (Expected in Process Definition or `init` Message):**
        *   `script`: Can be:
            *   An Arweave Transaction ID of the Lua script file.
            *   A list of script IDs or script message maps.
            *   A message map containing the Lua script in its `body` tag (Content-Type `application/lua` or `text/x-lua`).
            *   A map where keys are module names and values are script IDs/messages.
        *   `sandbox`: (Optional) Controls Lua sandboxing. Can be `true` (uses default sandbox list), `false` (no sandbox), or a map/list specifying functions to disable and their return values.
    *   **Outputs (Stored in `priv/`):**
        *   `state`: The initialized `luerl` state handle.
*   **`<FunctionName>` (Default Handler - `compute`)**
    *   **Action:** Executes a specific function within the loaded Lua script(s). This is the default handler; if a key matching a Lua function name is called on the device, this logic runs.
    *   **Inputs (Expected in Process State or Incoming Message):**
        *   `priv/state`: The Lua state obtained during `init`.
        *   The **key** being accessed (used as the default function name).
        *   `function` or `body/function`: (Optional) Overrides the function name derived from the key.
        *   `parameters` or `body/parameters`: (Optional) Arguments to pass to the Lua function. Defaults to a list containing the process message, the request message, and an empty options map.
    *   **Response:** The results returned by the Lua function call, typically encoded. The device also updates the `priv/state` with the Lua state after execution.
*   **`snapshot`**
    *   **Action:** Captures the current state of the running Lua environment. `luerl` state is serializable.
    *   **Inputs:** `priv/state`.
    *   **Outputs:** A message containing the serialized Lua state, typically tagged with `[Prefix]/State`.
*   **`normalize` (Internal Helper)**
    *   **Action:** Ensures a consistent state representation by loading a Lua state from a snapshot (`[Prefix]/State`) if a live state (`priv/state`) isn't already present.
*   **`functions`**
    *   **Action:** Returns a list of all globally defined functions within the current Lua state.
    *   **Inputs:** `priv/state`.
    *   **Response:** A list of function names.

## Sandboxing

The `sandbox` option in the process definition restricts potentially harmful Lua functions (like file I/O, OS commands, loading arbitrary code). By default (`sandbox = true`), common dangerous functions are disabled. You can customize the sandbox rules.

## AO Library (`dev_lua_lib`)

The `init` function automatically installs a helper library (`dev_lua_lib`) into the Lua state. This library typically provides functions for interacting with the AO environment from within the Lua script, such as:

*   `ao.send({ Target = ..., ... })`: To send messages from the process.
*   Access to message tags and data.

## Usage within `dev_stack`

Like `~wasm64@1.0`, the `~lua@5.3a` device is typically used within an execution stack.

```text
# Example Process Definition Snippet
Execution-Device: stack@1.0
Execution-Stack: "scheduler@1.0", "lua@5.3a"
Script: <LuaScriptTxID>
Sandbox: true
```

This device offers a lightweight, integrated scripting capability for AO processes, suitable for a wide range of tasks from simple logic to more complex state management and interactions.

[lua module](../resources/source-code/dev_lua.md)

--- END OF FILE: docs/devices/lua-at-5-3a.md ---

--- START OF FILE: docs/devices/message-at-1-0.md ---
# Device: ~message@1.0

## Overview

The [`~message@1.0`](../resources/source-code/dev_message.md) device is a fundamental built-in device in HyperBEAM. It serves as the identity device for standard AO-Core messages, which are represented as Erlang maps internally. Its primary function is to allow manipulation and inspection of these message maps directly via HyperPATH requests, without needing a persistent process state.

**Status:** Stable

This device is particularly useful for:

*   Creating and modifying transient messages on the fly using query parameters.
*   Retrieving specific values from a message map.
*   Inspecting the keys of a message.
*   Handling message commitments and verification (though often delegated to specialized commitment devices like `httpsig@1.0`).

## Core Functionality

The `message@1.0` device treats the message itself as the state it operates on. Key operations are accessed via path segments in the HyperPATH.

### Key Access (`/key`)

To retrieve the value associated with a specific key in the message map, simply append the key name to the path. Key lookup is case-insensitive.

**Example:**

```
http://localhost:10000/~message@1.0&hello=world&Key=Value/key
```

**Response:**

```
"Value"
```

### Reserved Keys

The `message@1.0` device reserves several keys for specific operations:

*   **`get`**: (Default operation if path segment matches a key in the map) Retrieves the value of a specified key. Behaves identically to accessing `/key` directly.
*   **`set`**: Modifies the message by adding or updating key-value pairs. Requires additional parameters (usually in the request body or subsequent path segments/query params, depending on implementation specifics).
    *   Supports deep merging of maps.
    *   Setting a key to `unset` removes it.
    *   Overwriting keys that are part of existing commitments will typically remove those commitments unless the new value matches the old one.
*   **`set_path`**: A special case for setting the `path` key itself, which cannot be done via the standard `set` operation.
*   **`remove`**: Removes one or more specified keys from the message. Requires an `item` or `items` parameter.
*   **`keys`**: Returns a list of all public (non-private) keys present in the message map.
*   **`id`**: Calculates and returns the ID (hash) of the message. Considers active commitments based on specified `committers`. May delegate ID calculation to a device specified by the message's `id-device` key or the default (`httpsig@1.0`).
*   **`commit`**: Creates a commitment (e.g., a signature) for the message. Requires parameters like `commitment-device` and potentially committer information. Delegates the actual commitment generation to the specified device (default `httpsig@1.0`).
*   **`committers`**: Returns a list of committers associated with the commitments in the message. Can be filtered by request parameters.
*   **`commitments`**: Used internally and in requests to filter or specify which commitments to operate on (e.g., for `id` or `verify`).
*   **`verify`**: Verifies the commitments attached to the message. Can be filtered by `committers` or specific `commitment` IDs in the request. Delegates verification to the device specified in each commitment (`commitment-device`).

### Private Keys

Keys prefixed with `priv` (e.g., `priv_key`, `private.data`) are considered private and cannot be accessed or listed via standard `get` or `keys` operations.

## HyperPATH Example

This example demonstrates creating a transient message and retrieving a value:

```
http://localhost:10000/~message@1.0&hello=world&k=v/k
```

**Breakdown:**

1.  `~message@1.0`: Sets the root device.
2.  `&hello=world&k=v`: Query parameters create the initial message: `#{ <<"hello">> => <<"world">>, <<"k">> => <<"v">> }`.
3.  `/k`: The path segment requests the value for the key `k`.

**Response:**

```
"v"
``` 
--- END OF FILE: docs/devices/message-at-1-0.md ---

--- START OF FILE: docs/devices/meta-at-1-0.md ---
# Device: ~meta@1.0

## Overview

The `~meta@1.0` device serves as the primary configuration and information endpoint for a HyperBEAM node. It's the default entry point for processing requests and allows querying or modifying the node's settings.

**Status:** Stable

## Core Functions (Keys)

### `info`

Retrieves or modifies the node's configuration message (often referred to as `NodeMsg` internally).

*   **`GET /~meta@1.0/info`**
    *   **Action:** Returns the current node configuration message.
    *   **Response:** A message map containing the node's settings. Sensitive keys (like private wallets) are filtered out. Dynamically generated keys like the node's public `address` are added if a wallet is configured.
*   **`POST /~meta@1.0/info`**
    *   **Action:** Updates the node's configuration message. Requires the request to be signed by the node's configured `operator` key/address.
    *   **Request Body:** A message map containing the configuration keys and values to update.
    *   **Response:** Confirmation message indicating success or failure.
    *   **Note:** Once a node's configuration is marked as `initialized = permanent`, it cannot be changed via this method.

## Key Configuration Parameters Managed by `~meta`

While the `info` key is the primary interaction point, the `NodeMsg` managed by `~meta` holds crucial configuration parameters affecting the entire node's behavior, including (but not limited to):

*   `port`: HTTP server port.
*   `priv_wallet` / `key_location`: Path to the node's Arweave key file.
*   `operator`: The address designated as the node operator (defaults to the address derived from `priv_wallet`).
*   `initialized`: Status indicating if the node setup is temporary or permanent.
*   `preprocessor` / `postprocessor`: Optional messages defining pre/post-processing logic for requests.
*   `routes`: Routing table used by `dev_router`.
*   `store`: Configuration for data storage.
*   `trace`: Debug tracing options.
*   `p4_*`: Payment configuration.
*   `faff_*`: Access control lists.

*(Refer to `hb_opts.erl` for a comprehensive list of options.)*

## Utility Functions (Internal/Module Level)

The `dev_meta.erl` module also contains helper functions used internally or callable from other Erlang modules:

*   `is_operator(<RequestMsg>, <NodeMsg>) -> boolean()`: Checks if the signer of `RequestMsg` matches the configured `operator` in `NodeMsg`.

## Pre/Post-Processing Hooks

The `~meta` device applies the node's configured `preprocessor` message before resolving the main request and the `postprocessor` message after obtaining the result, allowing for global interception and modification of requests/responses.

## Initialization

Before a node can process general requests, it usually needs to be initialized. Attempts to access devices other than `~meta@1.0/info` before initialization typically result in an error. Initialization often involves setting essential parameters like the operator key via a `POST` to `info`.

[meta module](../resources/source-code/dev_meta.md)

--- END OF FILE: docs/devices/meta-at-1-0.md ---

--- START OF FILE: docs/devices/process-at-1-0.md ---
# Device: ~process@1.0

## Overview

The `~process@1.0` device provides the core abstraction for persistent, shared computations within AO, analogous to smart contracts in other systems but with greater flexibility. It orchestrates the interaction between scheduling, state management, and computation execution for a specific process instance.

**Status:** Stable

## Core Concept: Orchestration

A message tagged with `Device: process@1.0` (the "Process Definition Message") doesn't typically perform computation itself. Instead, it defines *which other devices* should be used for key aspects of its lifecycle:

*   **Scheduler Device:** Determines the order of incoming messages (assignments) to be processed. (Defaults to `~scheduler@1.0`).
*   **Execution Device:** Executes the actual computation based on the current state and the scheduled message. Often configured as `dev_stack` to allow multiple computational steps (e.g., running WASM, applying cron jobs, handling proofs).
*   **Push Device:** Handles the injection of new messages into the process's schedule. (Defaults to `~push@1.0`).

The `~process@1.0` device acts as a router, intercepting requests and delegating them to the appropriate configured device (scheduler, executor, etc.) by temporarily swapping the device tag on the message before resolving.

## Key Functions (Keys)

These keys are accessed via HyperPATHs relative to the Process Definition Message ID (`<ProcessID>`).

*   **`GET /<ProcessID>~process@1.0/schedule`**
    *   **Action:** Delegates to the configured Scheduler Device (via the process's `schedule/3` function) to retrieve the current schedule or state.
    *   **Response:** Depends on the Scheduler Device implementation (e.g., list of message IDs).
*   **`POST /<ProcessID>~process@1.0/schedule`**
    *   **Action:** Delegates to the configured Push Device (via the process's `push/3` function) to add a new message to the process's schedule.
    *   **Request Body:** The message to be added.
    *   **Response:** Confirmation or result from the Push Device.
*   **`GET /<ProcessID>~process@1.0/compute/<TargetSlotOrMsgID>`**
    *   **Action:** Computes the process state up to a specific point identified by `<TargetSlotOrMsgID>` (either a slot number or a message ID within the schedule). It retrieves assignments from the Scheduler Device and applies them sequentially using the configured Execution Device.
    *   **Response:** The process state message after executing up to the target slot/message.
    *   **Caching:** Results are cached aggressively (see `dev_process_cache`) to avoid recomputation.
*   **`GET /<ProcessID>~process@1.0/now`**
    *   **Action:** Computes and returns the `Results` key from the *latest* known state of the process. This typically involves computing all pending assignments.
    *   **Response:** The value of the `Results` key from the final state.
*   **`GET /<ProcessID>~process@1.0/slot`**
    *   **Action:** Delegates to the configured Scheduler Device to query information about a specific slot or the current slot number.
    *   **Response:** Depends on the Scheduler Device implementation.
*   **`GET /<ProcessID>~process@1.0/snapshot`**
    *   **Action:** Delegates to the configured Execution Device to generate a snapshot of the current process state. This often involves running the execution stack in a specific "map" mode to gather state from different components.
    *   **Response:** A message representing the process snapshot, often marked for caching.

## Process Definition Example

A typical process definition message might look like this (represented conceptually):

```text
Device: process@1.0
Scheduler-Device: scheduler@1.0
Execution-Device: stack@1.0
Execution-Stack: "scheduler@1.0", "cron@1.0", "wasm64@1.0", "PoDA@1.0"
Cron-Frequency: 10-Minutes
WASM-Image: <WASMImageTxID>
PoDA:
    Device: PoDA/1.0
    Authority: <AddressA>
    Authority: <AddressB>
    Quorum: 2
```

This defines a process that uses:
*   The standard scheduler.
*   A stack executor that runs scheduling logic, cron jobs, a WASM module, and a Proof-of-Data-Availability check.

## State Management & Caching

`~process@1.0` relies heavily on caching (`dev_process_cache`) to optimize performance. Full state snapshots and intermediate results are cached periodically (configurable via `Cache-Frequency` and `Cache-Keys` options) to avoid recomputing the entire history for every request.

## Initialization (`init`)

Processes often require an initialization step before they can process messages. This is typically triggered by calling the `init` key on the configured Execution Device via the process path (`/<ProcessID>~process@1.0/init`). This allows components within the execution stack (like WASM modules) to set up their initial state.

[process module](../resources/source-code/dev_process.md)

--- END OF FILE: docs/devices/process-at-1-0.md ---

--- START OF FILE: docs/devices/relay-at-1-0.md ---
# Device: ~relay@1.0

## Overview

The `~relay@1.0` device is responsible for forwarding messages (HTTP requests) from one HyperBEAM node to another node or to any external HTTP(S) endpoint.

**Status:** Stable

## Core Concept: Message Forwarding

This device acts as an HTTP client within the AO ecosystem. It allows a node or process to make outbound HTTP requests.

## Key Functions (Keys)

*   **`call`**
    *   **Action:** Sends an HTTP request to a specified target and waits synchronously for the response.
    *   **Inputs (from Request Message or Base Message M1):**
        *   `target`: (Optional) A message map defining the request to be sent. Defaults to the original incoming request (`Msg2` or `M1`).
        *   `relay-path` or `path`: The URL/path to send the request to.
        *   `relay-method` or `method`: The HTTP method (GET, POST, etc.).
        *   `relay-body` or `body`: The request body.
        *   `requires-sign`: (Optional, boolean) If true, the request message (`target`) will be signed using the node's key before sending. Defaults to `false`.
        *   `http-client`: (Optional) Specify a custom HTTP client module to use (defaults to node's configured `relay_http_client`).
    *   **Response:** `{ok, <ResponseMessage>}` where `<ResponseMessage>` is the full message received from the remote peer, or `{error, Reason}`.
    *   **Example HyperPATH:**
        ```
        GET /~relay@1.0/call?method=GET&path=https://example.com
        ```
*   **`cast`**
    *   **Action:** Sends an HTTP request asynchronously. The device returns immediately after spawning a process to send the request; it does not wait for or return the response from the remote peer.
    *   **Inputs:** Same as `call`.
    *   **Response:** `{ok, <<"OK">>}`.
*   **`preprocess`**
    *   **Action:** This function is designed to be used as a node's global `preprocessor` (configured via `~meta@1.0`). When configured, it intercepts *all* incoming requests to the node and automatically rewrites them to be relayed via the `call` key. This effectively turns the node into a pure forwarding proxy, using its routing table (`dev_router`) to determine the destination.
    *   **Response:** A message structure that invokes `/~relay@1.0/call` with the original request as the target body.

## Use Cases

*   **Inter-Node Communication:** Sending messages between HyperBEAM nodes.
*   **External API Calls:** Allowing AO processes to interact with traditional web APIs.
*   **Routing Nodes:** Nodes configured with the `preprocess` key act as dedicated routers/proxies.
*   **Client-Side Relaying:** A local HyperBEAM instance can use `~relay@1.0` to forward requests to public compute nodes.

## Interaction with Routing

When `call` or `cast` is invoked, the actual HTTP request dispatch is handled by `hb_http:request/2`. This function often utilizes the node's routing configuration (`dev_router`) to determine the specific peer/URL to send the request to, especially if the target path is an AO process ID or another internal identifier rather than a full external URL.

[relay module](../resources/source-code/dev_relay.md)

--- END OF FILE: docs/devices/relay-at-1-0.md ---

--- START OF FILE: docs/devices/scheduler-at-1-0.md ---
# Device: ~scheduler@1.0

## Overview

The `~scheduler@1.0` device is responsible for managing the order of message execution for an AO process. It maintains the list of pending messages (assignments) and provides them sequentially to the process's Execution Device.

**Status:** Stable

## Core Concept: Message Ordering

When messages are sent to an AO process (typically via the `~push@1.0` device or a `POST` to the process's `/schedule` endpoint), they are added to a queue managed by the Scheduler Device associated with that process. The scheduler ensures that messages are processed one after another in a deterministic order, typically based on arrival time and potentially other factors like message nonces or timestamps (depending on the specific scheduler implementation details).

The `~process@1.0` device interacts with its configured Scheduler Device (which defaults to `~scheduler@1.0`) primarily through the `next` key to retrieve the next message to be executed.

## Key Functions (Keys)

These keys are typically accessed via the `~process@1.0` device, which delegates the calls to its configured scheduler.

*   **`schedule` (Handler for `GET /<ProcessID>~process@1.0/schedule`)**
    *   **Action:** Retrieves the list of pending assignments (messages) for the process. May support cursor-based traversal for long schedules.
    *   **Response:** A message map containing the assignments, often keyed by slot number or message ID.
*   **`register` (Handler for `POST /<ProcessID>~process@1.0/schedule`)**
    *   **Action:** Adds/registers a new message to the process's schedule. If this is the first message for a process, it might initialize the scheduler state.
    *   **Request Body:** The message to schedule.
    *   **Response:** Confirmation, potentially including the assigned slot or message ID.
*   **`slot` (Handler for `GET /<ProcessID>~process@1.0/slot`)**
    *   **Action:** Queries the current or a specific slot number within the process's schedule.
    *   **Response:** Information about the requested slot, such as the current highest slot number.
*   **`status` (Handler for `GET /<ProcessID>~process@1.0/status`)**
    *   **Action:** Retrieves status information about the scheduler for the process.
    *   **Response:** A status message.
*   **`next` (Internal Key used by `~process@1.0`)**
    *   **Action:** Retrieves the next assignment message from the schedule based on the process's current `at-slot` state.
    *   **State Management:** Requires the current process state (`Msg1`) containing the `at-slot` key.
    *   **Response:** `{ok, #{ "body" => <NextAssignmentMsg>, "state" => <UpdatedProcessState> }}` or `{error, Reason}` if no next assignment is found.
    *   **Caching & Lookahead:** The implementation uses internal caching (`dev_scheduler_cache`, `priv/assignments`) and potentially background lookahead workers to optimize fetching subsequent assignments.
*   **`init` (Internal Key)**
    *   **Action:** Initializes the scheduler state for a process, often called when the process itself is initialized.
*   **`checkpoint` (Internal Key)**
    *   **Action:** Triggers the scheduler to potentially persist its current state or perform other checkpointing operations.

## Interaction with Other Components

*   **`~process@1.0`:** The primary user of the scheduler, calling `next` to drive process execution.
*   **`~push@1.0`:** Often used to add messages to the schedule via `POST /schedule`.
*   **`dev_scheduler_cache`:** Internal module used for caching assignments locally on the node to reduce latency.
*   **Scheduling Unit (SU):** Schedulers may interact with external entities (like Arweave gateways or dedicated SU nodes) to fetch or commit schedules, although `~scheduler@1.0` aims for a simpler, often node-local or SU-client model.

`~scheduler@1.0` provides the fundamental mechanism for ordered, sequential execution within the potentially asynchronous and parallel environment of AO.

[scheduler module](../resources/source-code/dev_scheduler.md)

--- END OF FILE: docs/devices/scheduler-at-1-0.md ---

--- START OF FILE: docs/devices/wasm64-at-1-0.md ---
# Device: ~wasm64@1.0

## Overview

The `~wasm64@1.0` device enables the execution of WebAssembly (WASM) code within an AO process, specifically targeting the WASM Memory64 specification. It uses `hb_beamr`, an Erlang wrapper for the WebAssembly Micro Runtime (WAMR), as its backend.

**Status:** Stable

## Core Concept: WASM Execution

This device allows AO processes to perform complex computations defined in WASM modules, which can be written in languages like Rust, C++, C, Go, etc., and compiled to WASM.

The device manages the lifecycle of a WASM instance associated with the process state.

## Key Functions (Keys)

These keys are typically used within an execution stack (managed by `dev_stack`) for an AO process.

*   **`init`**
    *   **Action:** Initializes the WASM environment for the process. It locates the WASM image (binary), starts a WAMR instance, and stores the instance handle and helper functions (for reading/writing WASM memory) in the process's private state (`priv/...`).
    *   **Inputs (Expected in Process Definition or `init` Message):**
        *   `[Prefix]/image`: The Arweave Transaction ID of the WASM binary, or the WASM binary itself, or a message containing the WASM binary in its body.
        *   `[Prefix]/Mode`: (Optional) Specifies execution mode (`WASM` (default) or `AOT` if allowed by node config).
    *   **Outputs (Stored in `priv/`):**
        *   `[Prefix]/instance`: The handle to the running WAMR instance.
        *   `[Prefix]/write`: A function to write data into the WASM instance's memory.
        *   `[Prefix]/read`: A function to read data from the WASM instance's memory.
        *   `[Prefix]/import-resolver`: A function used to handle calls *from* the WASM module back *to* the AO environment (imports).
*   **`compute`**
    *   **Action:** Executes a function within the initialized WASM instance. It retrieves the target function name and parameters from the incoming message or process definition and calls the WASM instance via `hb_beamr`.
    *   **Inputs (Expected in Process State or Incoming Message):**
        *   `priv/[Prefix]/instance`: The handle obtained during `init`.
        *   `function` or `body/function`: The name of the WASM function to call.
        *   `parameters` or `body/parameters`: A list of parameters to pass to the WASM function.
    *   **Outputs (Stored in `results/`):**
        *   `results/[Prefix]/type`: The result type returned by the WASM function.
        *   `results/[Prefix]/output`: The actual result value returned by the WASM function.
*   **`import`**
    *   **Action:** Handles calls originating *from* the WASM module (imports). The default implementation (`default_import_resolver`) resolves these calls by treating them as sub-calls within the AO environment, allowing WASM code to invoke other AO device functions or access process state via the `hb_ao:resolve` mechanism.
    *   **Inputs (Provided by `hb_beamr`):** Module name, function name, arguments, signature.
    *   **Response:** Returns the result of the resolved AO call back to the WASM instance.
*   **`snapshot`**
    *   **Action:** Captures the current memory state of the running WASM instance. This is used for checkpointing and restoring process state.
    *   **Inputs:** `priv/[Prefix]/instance`.
    *   **Outputs:** A message containing the raw binary snapshot of the WASM memory state, typically tagged with `[Prefix]/State`.
*   **`normalize` (Internal Helper)**
    *   **Action:** Ensures a consistent state representation for computation, primarily by loading a WASM instance from a snapshot (`[Prefix]/State`) if a live instance (`priv/[Prefix]/instance`) isn't already present. This allows resuming execution from a cached state.
*   **`terminate`**
    *   **Action:** Stops and cleans up the running WASM instance associated with the process.
    *   **Inputs:** `priv/[Prefix]/instance`.

## Usage within `dev_stack`

The `~wasm64@1.0` device is almost always used as part of an execution stack configured in the Process Definition Message and managed by `dev_stack`. `dev_stack` ensures that `init` is called on the first pass, `compute` on subsequent passes, and potentially `snapshot` or `terminate` as needed.

```text
# Example Process Definition Snippet
Execution-Device: stack@1.0
Execution-Stack: "scheduler@1.0", "wasm64@1.0"
WASM-Image: <WASMImageTxID>
```

This setup allows AO processes to leverage the computational power and language flexibility offered by WebAssembly in a decentralized, verifiable manner.

[wasm module](../resources/source-code/dev_wasm.md)

--- END OF FILE: docs/devices/wasm64-at-1-0.md ---

--- START OF FILE: docs/resources/llms.md ---
# LLM Context Files

This section provides access to specially formatted files intended for consumption by Large Language Models (LLMs) to provide context about the HyperBEAM documentation.

1.  **[LLM Summary (llms.txt)](../llms.txt)**
    *   **Content**: Contains a brief summary of the HyperBEAM documentation structure and a list of relative file paths for all markdown documents included in the build.
    *   **Usage**: Useful for providing an LLM with a high-level overview and the available navigation routes within the documentation.

2.  **[LLM Full Content (llms-full.txt)](../llms-full.txt)**
    *   **Content**: A single text file containing the complete, concatenated content of all markdown documents from the specified documentation directories (`begin`, `run`, `guides`, `devices`, `resources`). Each file's content is clearly demarcated.
    *   **Usage**: Ideal for feeding the entire documentation content into an LLM for comprehensive context, analysis, or question-answering based on the full documentation set.

!!! note "Generation Process"
    These files are automatically generated by the `docs/build-all.sh` script during the documentation build process. They consolidate information from the following directories:

    *   `docs/begin`
    *   `docs/run`
    *   `docs/guides`
    *   `docs/devices`
    *   `docs/resources`

--- END OF FILE: docs/resources/llms.md ---

--- START OF FILE: docs/resources/reference/faq.md ---
# Frequently Asked Questions

This page answers common questions about HyperBEAM, its components, and how to use them effectively.

## General Questions

### What is HyperBEAM?

HyperBEAM is a client implementation of the AO-Core protocol written in Erlang. It serves as the node software for a decentralized operating system that allows operators to offer computational resources to users in the AO network.

### How does HyperBEAM differ from other distributed systems?

HyperBEAM focuses on true decentralization with asynchronous message passing between isolated processes. Unlike many distributed systems that rely on central coordination, HyperBEAM nodes can operate independently while still forming a cohesive network. Additionally, its Erlang foundation provides robust fault tolerance and concurrency capabilities.

### What can I build with HyperBEAM?

You can build a wide range of applications, including:

- Decentralized applications (dApps)
- Distributed computation systems
- Peer-to-peer services
- Resilient microservices
- IoT device networks
- Decentralized storage solutions

### Is HyperBEAM open source?

Yes, HyperBEAM is open-source software licensed under the MIT License.

## Installation and Setup

### What are the system requirements for running HyperBEAM?

Currently, HyperBEAM is primarily tested and documented for Ubuntu 22.04. Support for macOS and other platforms will be added in future updates. For detailed requirements, see the [System Requirements](../getting-started/requirements.md) page.

### Can I run HyperBEAM in a container?

While technically possible, running HyperBEAM in Docker containers or other containerization technologies is currently not recommended. The containerization approach may introduce additional complexity and potential performance issues. We recommend running HyperBEAM directly on the host system until container support is more thoroughly tested and optimized.

### How do I update HyperBEAM to the latest version?

To update HyperBEAM:

1. Pull the latest code from the repository
2. Rebuild the application
3. Restart the HyperBEAM service

Specific update instructions will vary depending on your installation method.

### Can I run multiple HyperBEAM nodes on a single machine?

Yes, you can run multiple HyperBEAM nodes on a single machine, but you'll need to configure them to use different ports and data directories to avoid conflicts. However, this is not recommended for production environments as each node should ideally have a unique IP address to properly participate in the network. Running multiple nodes on a single machine is primarily useful for development and testing purposes.

## Architecture and Components

### What is the difference between HyperBEAM and Compute Unit?

- **HyperBEAM**: The Erlang-based node software that handles message routing, process management, and device coordination.
- **Compute Unit (CU)**: A NodeJS implementation that executes WebAssembly modules and handles computational tasks.

Together, these components form a complete execution environment for AO processes.

## Development and Usage

### What programming languages can I use with HyperBEAM?

You can use any programming language that compiles to WebAssembly (WASM) for creating modules that run on the Compute Unit. This includes languages like:

- Lua
- Rust
- C/C++
- And many others with WebAssembly support

### How do I debug processes running in HyperBEAM?

Debugging processes in HyperBEAM can be done through:

1. Logging messages to the system log
2. Monitoring process state and message flow
3. Inspecting memory usage and performance metrics

### Is there a limit to how many processes can run on a node?

The practical limit depends on your hardware resources. Erlang is designed to handle millions of lightweight processes efficiently, but the actual number will be determined by:

- Available memory
- CPU capacity
- Network bandwidth
- Storage speed
- The complexity of your processes


## Troubleshooting

### What should I do if a node becomes unresponsive?

If a node becomes unresponsive:

1. Check the node's logs for error messages
2. Verify network connectivity
3. Ensure sufficient system resources
4. Restart the node if necessary
5. Check for configuration issues

For persistent problems, consult the [Troubleshooting](troubleshooting.md) page.

### Where can I get help if I encounter issues?

If you encounter issues:

- Check the [Troubleshooting](troubleshooting.md) guide
- Search or ask questions on [GitHub Issues](https://github.com/permaweb/HyperBEAM/issues)
- Join the community on [Discord](https://discord.gg/V3yjzrBxPM)
--- END OF FILE: docs/resources/reference/faq.md ---

--- START OF FILE: docs/resources/reference/glossary.md ---
# Glossary

This glossary provides definitions for terms and concepts used throughout the HyperBEAM documentation. For a comprehensive glossary of permaweb-specific terminology, check out the [permaweb glossary](#permaweb-glossary) section below.

## AO-Core Protocol
The underlying protocol that HyperBEAM implements, enabling decentralized computing and communication between nodes. AO-Core provides a framework into which any number of different computational models, encapsulated as primitive devices, can be attached.

## Asynchronous Message Passing
A communication paradigm where senders don't wait for receivers to be ready, allowing for non-blocking operations and better scalability.

## Checkpoint
A saved state of a process that can be used to resume execution from a known point, used for persistence and recovery.

## Compute Unit (CU)
The NodeJS component of HyperBEAM that executes WebAssembly modules and handles computational tasks.

## Decentralized Execution
The ability to run processes across a distributed network without centralized control or coordination.

## Device
A functional unit in HyperBEAM that provides specific capabilities to the system, such as storage, networking, or computational resources.

## Erlang
The programming language used to implement the HyperBEAM core, known for its robustness and support for building distributed, fault-tolerant applications.

## ~flat@1.0
A format used for encoding settings files in HyperBEAM configuration, using HTTP header styling.

## Hashpaths
A mechanism for referencing locations in a program's state-space prior to execution. These state-space links are represented as Merklized lists of programs inputs and initial states.

## HyperBEAM
The Erlang-based node software that handles message routing, process management, and device coordination in the HyperBEAM ecosystem.

## Message
A data structure used for communication between processes in the HyperBEAM system. Messages can be interpreted as a binary term or as a collection of named functions (a Map of functions).

## Module
A unit of code that can be loaded and executed by the Compute Unit, typically in WebAssembly format.

## Node
An instance of HyperBEAM running on a physical or virtual machine that participates in the distributed network.

## ~p4@1.0
A device that runs as a pre-processor and post-processor in HyperBEAM, enabling a framework for node operators to sell usage of their machine's hardware to execute AO-Core devices.

## Process
An independent unit of computation in HyperBEAM with its own state and execution context.

## Process ID
A unique identifier assigned to a process within the HyperBEAM system.

## ~scheduler@1.0
A device used to assign a linear hashpath to an execution, such that all users may access it with a deterministic ordering.

## ~compute-lite@1.0
A lightweight device wrapping a local WASM executor, used for executing legacynet AO processes inside HyperBEAM.

## ~json-iface@1.0
A device that offers a translation layer between the JSON-encoded message format used by legacy versions and HyperBEAM's native HTTP message format.

## ~meta@1.0
A device used to configure the node's hardware, supported devices, metering and payments information, amongst other configuration options.

## ~process@1.0
A device that enables users to create persistent, shared executions that can be accessed by any number of users, each of whom may add additional inputs to its hashpath.

## ~relay@1.0
A device used to relay messages between nodes and the wider HTTP network. It offers an interface for sending and receiving messages using a variety of execution strategies.

## ~simple-pay@1.0
A simple, flexible pricing device that can be used in conjunction with p4@1.0 to offer flat-fees for the execution of AO-Core messages.

## ~snp@1.0
A device used to generate and validate proofs that a node is executing inside a Trusted Execution Environment (TEE).

## ~wasm64@1.0
A device used to execute WebAssembly code, using the Web Assembly Micro-Runtime (WAMR) under-the-hood.

## ~stack@1.0
A device used to execute an ordered set of devices over the same inputs, allowing users to create complex combinations of other devices.

## Trusted Execution Environment (TEE)
A secure area inside a processor that ensures the confidentiality and integrity of code and data loaded within it. Used in HyperBEAM for trust-minimized computation.

## WebAssembly (WASM)
A binary instruction format that serves as a portable compilation target for programming languages, enabling deployment on the web and other environments.

## Permaweb Glossary

For a more comprehensive glossary of terms used in the permaweb, try the [Permaweb Glossary](https://glossary.arweave.net). Or use it below:


<style>
.dark-mode-iframe-container { display: none; }
.light-mode-iframe-container { display: block; }
[data-md-color-scheme="slate"] .light-mode-iframe-container { display: none; }
[data-md-color-scheme="slate"] .dark-mode-iframe-container { display: block; }

/* Explicitly handle default scheme */
[data-md-color-scheme="default"] .dark-mode-iframe-container { display: none; }
[data-md-color-scheme="default"] .light-mode-iframe-container { display: block; }
</style>

<div class="mt-6">
  <div class="light-mode-iframe-container">
    <iframe 
     id="glossary-frame-light" 
     src="https://glossary.arweave.net/?hide-header=true&bg-color=%23FFFFFF&text-color=%231A1A1A&link-color=%23fc8516&heading-color=%233C3C3C&accent-color=%23fc8516&tag-bg=%23fc8516&tag-text=%23ffffff&button-bg=%23fc8516&button-text=%23ffffff"
     width="100%" 
     height="400" 
     frameborder="0" 
     scrolling="no">
    </iframe>
  </div>
  <div class="dark-mode-iframe-container">
    <iframe 
     class="w-full"
	 width="100%" 
     height="400"  
	 frameborder="0" 
	 scrolling="no"
     src="https://glossary.arweave.net/?hide-header=true&bg-color=%231F2129&text-color=%23e0e0e0&link-color=%23fc8516&heading-color=%23ffffff&accent-color=%23fc8516&border-color=%23444444&hover-bg=%23222222&button-bg=%23fc8516&button-text=%23ffffff&section-bg=%23333333&section-color=%23ffffff&category-bg=%23333333&category-text=%23ffffff&tag-bg=%23fc8516&tag-text=%23ffffff&secondary-text=%23a0a0a0&result-bg=%231e1e1e&result-hover=%23333333"
     >
    </iframe>
  </div>
</div>
--- END OF FILE: docs/resources/reference/glossary.md ---

--- START OF FILE: docs/resources/reference/troubleshooting.md ---
# Troubleshooting Guide

This guide addresses common issues you might encounter when working with HyperBEAM and the Compute Unit.

## Installation Issues

### Erlang Installation Fails

**Symptoms**: Errors during Erlang compilation or installation

**Solutions**:

- Ensure all required dependencies are installed: `sudo apt-get install -y libssl-dev ncurses-dev make cmake gcc g++`
- Try configuring with fewer options: `./configure --without-wx --without-debugger --without-observer --without-et`
- Check disk space, as compilation requires several GB of free space

### Rebar3 Bootstrap Fails

**Symptoms**: Errors when running `./bootstrap` for Rebar3

**Solutions**:

- Verify Erlang is correctly installed: `erl -eval 'erlang:display(erlang:system_info(otp_release)), halt().'`
- Ensure you have the latest version of the repository: `git fetch && git reset --hard origin/master`
- Try manually downloading a precompiled Rebar3 binary

## HyperBEAM Issues

### HyperBEAM Won't Start

**Symptoms**: Errors when running `rebar3 shell` or the HyperBEAM startup command

**Solutions**:

- Check for port conflicts: Another service might be using the configured port
- Verify the wallet key file exists and is accessible
- Examine Erlang crash dumps for detailed error information
- Ensure all required dependencies are installed

### HyperBEAM Crashes During Operation

**Symptoms**: Unexpected termination of the HyperBEAM process

**Solutions**:

- Check system resources (memory, disk space)
- Examine Erlang crash dumps for details
- Reduce memory limits if the system is resource-constrained
- Check for network connectivity issues if connecting to external services

## Compute Unit Issues

### Compute Unit Won't Start

**Symptoms**: Errors when running `npm start` in the CU directory

**Solutions**:

- Verify Node.js is installed correctly: `node -v`
- Ensure all dependencies are installed: `npm i`
- Check that the wallet file exists and is correctly formatted
- Verify the `.env` file has all required settings

### Memory Errors in Compute Unit

**Symptoms**: Out of memory errors or excessive memory usage

**Solutions**:

- Adjust the `PROCESS_WASM_MEMORY_MAX_LIMIT` environment variable
- Enable garbage collection by setting an appropriate `GC_INTERVAL_MS`
- Monitor memory usage and adjust limits as needed
- If on a low-memory system, reduce concurrent process execution

## Integration Issues

### HyperBEAM Can't Connect to Compute Unit

**Symptoms**: Connection errors in HyperBEAM logs when trying to reach the CU

**Solutions**:

- Verify the CU is running: `curl http://localhost:6363`
- Ensure there are no firewall rules blocking the connection
- Verify network configuration if components are on different machines

### Process Execution Fails

**Symptoms**: Errors when deploying or executing processes

**Solutions**:

- Check both HyperBEAM and CU logs for specific error messages
- Verify that the WASM module is correctly compiled and valid
- Test with a simple example process to isolate the issue
- Adjust memory limits if the process requires more resources

## Getting Help

If you're still experiencing issues after trying these troubleshooting steps:

1. Check the [GitHub repository](https://github.com/permaweb/HyperBEAM) for known issues
2. Join the [Discord community](https://discord.gg/V3yjzrBxPM) for support
3. Open an issue on GitHub with detailed information about your problem 
--- END OF FILE: docs/resources/reference/troubleshooting.md ---

--- START OF FILE: docs/resources/source-code/ar_bundles.md ---
# [Module ar_bundles.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_bundles.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_bundle_tags-1">add_bundle_tags/1*</a></td><td></td></tr><tr><td valign="top"><a href="#add_list_tags-1">add_list_tags/1*</a></td><td></td></tr><tr><td valign="top"><a href="#add_manifest_tags-2">add_manifest_tags/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ar_bundles_test_-0">ar_bundles_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#assert_data_item-7">assert_data_item/7*</a></td><td></td></tr><tr><td valign="top"><a href="#check_size-2">check_size/2*</a></td><td>Force that a binary is either empty or the given number of bytes.</td></tr><tr><td valign="top"><a href="#check_type-2">check_type/2*</a></td><td>Ensure that a value is of the given type.</td></tr><tr><td valign="top"><a href="#data_item_signature_data-1">data_item_signature_data/1</a></td><td>Generate the data segment to be signed for a data item.</td></tr><tr><td valign="top"><a href="#data_item_signature_data-2">data_item_signature_data/2*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_avro_name-3">decode_avro_name/3*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_avro_tags-2">decode_avro_tags/2*</a></td><td>Decode Avro blocks (for tags) from binary.</td></tr><tr><td valign="top"><a href="#decode_avro_value-4">decode_avro_value/4*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_bundle_header-2">decode_bundle_header/2*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_bundle_header-3">decode_bundle_header/3*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_bundle_items-2">decode_bundle_items/2*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_optional_field-1">decode_optional_field/1*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_signature-1">decode_signature/1*</a></td><td>Decode the signature from a binary format.</td></tr><tr><td valign="top"><a href="#decode_tags-1">decode_tags/1</a></td><td>Decode tags from a binary format using Apache Avro.</td></tr><tr><td valign="top"><a href="#decode_vint-3">decode_vint/3*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_zigzag-1">decode_zigzag/1*</a></td><td>Decode a VInt encoded ZigZag integer from binary.</td></tr><tr><td valign="top"><a href="#deserialize-1">deserialize/1</a></td><td>Convert binary data back to a #tx record.</td></tr><tr><td valign="top"><a href="#deserialize-2">deserialize/2</a></td><td></td></tr><tr><td valign="top"><a href="#encode_avro_string-1">encode_avro_string/1*</a></td><td>Encode a string for Avro using ZigZag and VInt encoding.</td></tr><tr><td valign="top"><a href="#encode_optional_field-1">encode_optional_field/1*</a></td><td>Encode an optional field (target, anchor) with a presence byte.</td></tr><tr><td valign="top"><a href="#encode_signature_type-1">encode_signature_type/1*</a></td><td>Only RSA 4096 is currently supported.</td></tr><tr><td valign="top"><a href="#encode_tags-1">encode_tags/1</a></td><td>Encode tags into a binary format using Apache Avro.</td></tr><tr><td valign="top"><a href="#encode_tags_size-2">encode_tags_size/2*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_vint-1">encode_vint/1*</a></td><td>Encode a ZigZag integer to VInt binary format.</td></tr><tr><td valign="top"><a href="#encode_vint-2">encode_vint/2*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_zigzag-1">encode_zigzag/1*</a></td><td>Encode an integer using ZigZag encoding.</td></tr><tr><td valign="top"><a href="#enforce_valid_tx-1">enforce_valid_tx/1*</a></td><td>Take an item and ensure that it is of valid form.</td></tr><tr><td valign="top"><a href="#finalize_bundle_data-1">finalize_bundle_data/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find-2">find/2</a></td><td>Find an item in a bundle-map/list and return it.</td></tr><tr><td valign="top"><a href="#find_single_layer-2">find_single_layer/2*</a></td><td>An internal helper for finding an item in a single-layer of a bundle.</td></tr><tr><td valign="top"><a href="#format-1">format/1</a></td><td></td></tr><tr><td valign="top"><a href="#format-2">format/2</a></td><td></td></tr><tr><td valign="top"><a href="#format_binary-1">format_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#format_data-2">format_data/2*</a></td><td></td></tr><tr><td valign="top"><a href="#format_line-2">format_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#format_line-3">format_line/3*</a></td><td></td></tr><tr><td valign="top"><a href="#hd-1">hd/1</a></td><td>Return the first item in a bundle-map/list.</td></tr><tr><td valign="top"><a href="#id-1">id/1</a></td><td>Return the ID of an item -- either signed or unsigned as specified.</td></tr><tr><td valign="top"><a href="#id-2">id/2</a></td><td></td></tr><tr><td valign="top"><a href="#is_signed-1">is_signed/1</a></td><td>Check if an item is signed.</td></tr><tr><td valign="top"><a href="#manifest-1">manifest/1</a></td><td></td></tr><tr><td valign="top"><a href="#manifest_item-1">manifest_item/1</a></td><td>Return the manifest item in a bundle-map/list.</td></tr><tr><td valign="top"><a href="#map-1">map/1</a></td><td>Convert an item containing a map or list into an Erlang map.</td></tr><tr><td valign="top"><a href="#maybe_map_to_list-1">maybe_map_to_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_unbundle-1">maybe_unbundle/1*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_unbundle_map-1">maybe_unbundle_map/1*</a></td><td></td></tr><tr><td valign="top"><a href="#member-2">member/2</a></td><td>Check if an item exists in a bundle-map/list.</td></tr><tr><td valign="top"><a href="#new_item-4">new_item/4</a></td><td>Create a new data item.</td></tr><tr><td valign="top"><a href="#new_manifest-1">new_manifest/1*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize-1">normalize/1</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_data-1">normalize_data/1*</a></td><td>Ensure that a data item (potentially containing a map or list) has a standard, serialized form.</td></tr><tr><td valign="top"><a href="#normalize_data_size-1">normalize_data_size/1*</a></td><td>Reset the data size of a data item.</td></tr><tr><td valign="top"><a href="#ok_or_throw-3">ok_or_throw/3*</a></td><td>Throw an error if the given value is not ok.</td></tr><tr><td valign="top"><a href="#parse_manifest-1">parse_manifest/1</a></td><td></td></tr><tr><td valign="top"><a href="#print-1">print/1</a></td><td></td></tr><tr><td valign="top"><a href="#reset_ids-1">reset_ids/1</a></td><td>Re-calculate both of the IDs for an item.</td></tr><tr><td valign="top"><a href="#run_test-0">run_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#serialize-1">serialize/1</a></td><td>Convert a #tx record to its binary representation.</td></tr><tr><td valign="top"><a href="#serialize-2">serialize/2</a></td><td></td></tr><tr><td valign="top"><a href="#serialize_bundle_data-2">serialize_bundle_data/2*</a></td><td></td></tr><tr><td valign="top"><a href="#sign_item-2">sign_item/2</a></td><td>Sign a data item.</td></tr><tr><td valign="top"><a href="#signer-1">signer/1</a></td><td>Return the address of the signer of an item, if it is signed.</td></tr><tr><td valign="top"><a href="#test_basic_member_id-0">test_basic_member_id/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_bundle_map-0">test_bundle_map/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_bundle_with_one_item-0">test_bundle_with_one_item/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_bundle_with_two_items-0">test_bundle_with_two_items/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_deep_member-0">test_deep_member/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_empty_bundle-0">test_empty_bundle/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_extremely_large_bundle-0">test_extremely_large_bundle/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_no_tags-0">test_no_tags/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_recursive_bundle-0">test_recursive_bundle/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_serialize_deserialize_deep_signed_bundle-0">test_serialize_deserialize_deep_signed_bundle/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_unsigned_data_item_id-0">test_unsigned_data_item_id/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_unsigned_data_item_normalization-0">test_unsigned_data_item_normalization/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_with_tags-0">test_with_tags/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_with_zero_length_tag-0">test_with_zero_length_tag/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_serialized_pair-1">to_serialized_pair/1*</a></td><td></td></tr><tr><td valign="top"><a href="#type-1">type/1</a></td><td></td></tr><tr><td valign="top"><a href="#unbundle-1">unbundle/1*</a></td><td></td></tr><tr><td valign="top"><a href="#unbundle_list-1">unbundle_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#update_ids-1">update_ids/1*</a></td><td>Take an item and ensure that both the unsigned and signed IDs are
appropriately set.</td></tr><tr><td valign="top"><a href="#utf8_encoded-1">utf8_encoded/1*</a></td><td>Encode a UTF-8 string to binary.</td></tr><tr><td valign="top"><a href="#verify_data_item_id-1">verify_data_item_id/1*</a></td><td>Verify the data item's ID matches the signature.</td></tr><tr><td valign="top"><a href="#verify_data_item_signature-1">verify_data_item_signature/1*</a></td><td>Verify the data item's signature.</td></tr><tr><td valign="top"><a href="#verify_data_item_tags-1">verify_data_item_tags/1*</a></td><td>Verify the validity of the data item's tags.</td></tr><tr><td valign="top"><a href="#verify_item-1">verify_item/1</a></td><td>Verify the validity of a data item.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_bundle_tags-1"></a>

### add_bundle_tags/1 * ###

`add_bundle_tags(Tags) -> any()`

<a name="add_list_tags-1"></a>

### add_list_tags/1 * ###

`add_list_tags(Tags) -> any()`

<a name="add_manifest_tags-2"></a>

### add_manifest_tags/2 * ###

`add_manifest_tags(Tags, ManifestID) -> any()`

<a name="ar_bundles_test_-0"></a>

### ar_bundles_test_/0 * ###

`ar_bundles_test_() -> any()`

<a name="assert_data_item-7"></a>

### assert_data_item/7 * ###

`assert_data_item(KeyType, Owner, Target, Anchor, Tags, Data, DataItem) -> any()`

<a name="check_size-2"></a>

### check_size/2 * ###

`check_size(Bin, Sizes) -> any()`

Force that a binary is either empty or the given number of bytes.

<a name="check_type-2"></a>

### check_type/2 * ###

`check_type(Value, X2) -> any()`

Ensure that a value is of the given type.

<a name="data_item_signature_data-1"></a>

### data_item_signature_data/1 ###

`data_item_signature_data(RawItem) -> any()`

Generate the data segment to be signed for a data item.

<a name="data_item_signature_data-2"></a>

### data_item_signature_data/2 * ###

`data_item_signature_data(RawItem, X2) -> any()`

<a name="decode_avro_name-3"></a>

### decode_avro_name/3 * ###

`decode_avro_name(NameSize, Rest, Count) -> any()`

<a name="decode_avro_tags-2"></a>

### decode_avro_tags/2 * ###

`decode_avro_tags(Binary, Count) -> any()`

Decode Avro blocks (for tags) from binary.

<a name="decode_avro_value-4"></a>

### decode_avro_value/4 * ###

`decode_avro_value(ValueSize, Name, Rest, Count) -> any()`

<a name="decode_bundle_header-2"></a>

### decode_bundle_header/2 * ###

`decode_bundle_header(Count, Bin) -> any()`

<a name="decode_bundle_header-3"></a>

### decode_bundle_header/3 * ###

`decode_bundle_header(Count, ItemsBin, Header) -> any()`

<a name="decode_bundle_items-2"></a>

### decode_bundle_items/2 * ###

`decode_bundle_items(RestItems, ItemsBin) -> any()`

<a name="decode_optional_field-1"></a>

### decode_optional_field/1 * ###

`decode_optional_field(X1) -> any()`

<a name="decode_signature-1"></a>

### decode_signature/1 * ###

`decode_signature(Other) -> any()`

Decode the signature from a binary format. Only RSA 4096 is currently supported.
Note: the signature type '1' corresponds to RSA 4096 - but it is is written in
little-endian format which is why we match on `<<1, 0>>`.

<a name="decode_tags-1"></a>

### decode_tags/1 ###

`decode_tags(X1) -> any()`

Decode tags from a binary format using Apache Avro.

<a name="decode_vint-3"></a>

### decode_vint/3 * ###

`decode_vint(X1, Result, Shift) -> any()`

<a name="decode_zigzag-1"></a>

### decode_zigzag/1 * ###

`decode_zigzag(Binary) -> any()`

Decode a VInt encoded ZigZag integer from binary.

<a name="deserialize-1"></a>

### deserialize/1 ###

`deserialize(Binary) -> any()`

Convert binary data back to a #tx record.

<a name="deserialize-2"></a>

### deserialize/2 ###

`deserialize(Item, X2) -> any()`

<a name="encode_avro_string-1"></a>

### encode_avro_string/1 * ###

`encode_avro_string(String) -> any()`

Encode a string for Avro using ZigZag and VInt encoding.

<a name="encode_optional_field-1"></a>

### encode_optional_field/1 * ###

`encode_optional_field(Field) -> any()`

Encode an optional field (target, anchor) with a presence byte.

<a name="encode_signature_type-1"></a>

### encode_signature_type/1 * ###

`encode_signature_type(X1) -> any()`

Only RSA 4096 is currently supported.
Note: the signature type '1' corresponds to RSA 4096 -- but it is is written in
little-endian format which is why we encode to `<<1, 0>>`.

<a name="encode_tags-1"></a>

### encode_tags/1 ###

`encode_tags(Tags) -> any()`

Encode tags into a binary format using Apache Avro.

<a name="encode_tags_size-2"></a>

### encode_tags_size/2 * ###

`encode_tags_size(Tags, EncodedTags) -> any()`

<a name="encode_vint-1"></a>

### encode_vint/1 * ###

`encode_vint(ZigZag) -> any()`

Encode a ZigZag integer to VInt binary format.

<a name="encode_vint-2"></a>

### encode_vint/2 * ###

`encode_vint(ZigZag, Acc) -> any()`

<a name="encode_zigzag-1"></a>

### encode_zigzag/1 * ###

`encode_zigzag(Int) -> any()`

Encode an integer using ZigZag encoding.

<a name="enforce_valid_tx-1"></a>

### enforce_valid_tx/1 * ###

`enforce_valid_tx(List) -> any()`

Take an item and ensure that it is of valid form. Useful for ensuring
that a message is viable for serialization/deserialization before execution.
This function should throw simple, easy to follow errors to aid devs in
debugging issues.

<a name="finalize_bundle_data-1"></a>

### finalize_bundle_data/1 * ###

`finalize_bundle_data(Processed) -> any()`

<a name="find-2"></a>

### find/2 ###

`find(Key, Map) -> any()`

Find an item in a bundle-map/list and return it.

<a name="find_single_layer-2"></a>

### find_single_layer/2 * ###

`find_single_layer(UnsignedID, TX) -> any()`

An internal helper for finding an item in a single-layer of a bundle.
Does not recurse! You probably want `find/2` in most cases.

<a name="format-1"></a>

### format/1 ###

`format(Item) -> any()`

<a name="format-2"></a>

### format/2 ###

`format(Item, Indent) -> any()`

<a name="format_binary-1"></a>

### format_binary/1 * ###

`format_binary(Bin) -> any()`

<a name="format_data-2"></a>

### format_data/2 * ###

`format_data(Item, Indent) -> any()`

<a name="format_line-2"></a>

### format_line/2 * ###

`format_line(Str, Indent) -> any()`

<a name="format_line-3"></a>

### format_line/3 * ###

`format_line(RawStr, Fmt, Ind) -> any()`

<a name="hd-1"></a>

### hd/1 ###

`hd(Tx) -> any()`

Return the first item in a bundle-map/list.

<a name="id-1"></a>

### id/1 ###

`id(Item) -> any()`

Return the ID of an item -- either signed or unsigned as specified.
If the item is unsigned and the user requests the signed ID, we return
the atom `not_signed`. In all other cases, we return the ID of the item.

<a name="id-2"></a>

### id/2 ###

`id(Item, Type) -> any()`

<a name="is_signed-1"></a>

### is_signed/1 ###

`is_signed(Item) -> any()`

Check if an item is signed.

<a name="manifest-1"></a>

### manifest/1 ###

`manifest(Map) -> any()`

<a name="manifest_item-1"></a>

### manifest_item/1 ###

`manifest_item(Tx) -> any()`

Return the manifest item in a bundle-map/list.

<a name="map-1"></a>

### map/1 ###

`map(Tx) -> any()`

Convert an item containing a map or list into an Erlang map.

<a name="maybe_map_to_list-1"></a>

### maybe_map_to_list/1 * ###

`maybe_map_to_list(Item) -> any()`

<a name="maybe_unbundle-1"></a>

### maybe_unbundle/1 * ###

`maybe_unbundle(Item) -> any()`

<a name="maybe_unbundle_map-1"></a>

### maybe_unbundle_map/1 * ###

`maybe_unbundle_map(Bundle) -> any()`

<a name="member-2"></a>

### member/2 ###

`member(Key, Item) -> any()`

Check if an item exists in a bundle-map/list.

<a name="new_item-4"></a>

### new_item/4 ###

`new_item(Target, Anchor, Tags, Data) -> any()`

Create a new data item. Should only be used for testing.

<a name="new_manifest-1"></a>

### new_manifest/1 * ###

`new_manifest(Index) -> any()`

<a name="normalize-1"></a>

### normalize/1 ###

`normalize(Item) -> any()`

<a name="normalize_data-1"></a>

### normalize_data/1 * ###

`normalize_data(Bundle) -> any()`

Ensure that a data item (potentially containing a map or list) has a standard, serialized form.

<a name="normalize_data_size-1"></a>

### normalize_data_size/1 * ###

`normalize_data_size(Item) -> any()`

Reset the data size of a data item. Assumes that the data is already normalized.

<a name="ok_or_throw-3"></a>

### ok_or_throw/3 * ###

`ok_or_throw(TX, X2, Error) -> any()`

Throw an error if the given value is not ok.

<a name="parse_manifest-1"></a>

### parse_manifest/1 ###

`parse_manifest(Item) -> any()`

<a name="print-1"></a>

### print/1 ###

`print(Item) -> any()`

<a name="reset_ids-1"></a>

### reset_ids/1 ###

`reset_ids(Item) -> any()`

Re-calculate both of the IDs for an item. This is a wrapper
function around `update_id/1` that ensures both IDs are set from
scratch.

<a name="run_test-0"></a>

### run_test/0 * ###

`run_test() -> any()`

<a name="serialize-1"></a>

### serialize/1 ###

`serialize(TX) -> any()`

Convert a #tx record to its binary representation.

<a name="serialize-2"></a>

### serialize/2 ###

`serialize(TX, X2) -> any()`

<a name="serialize_bundle_data-2"></a>

### serialize_bundle_data/2 * ###

`serialize_bundle_data(Map, Manifest) -> any()`

<a name="sign_item-2"></a>

### sign_item/2 ###

`sign_item(RawItem, X2) -> any()`

Sign a data item.

<a name="signer-1"></a>

### signer/1 ###

`signer(Tx) -> any()`

Return the address of the signer of an item, if it is signed.

<a name="test_basic_member_id-0"></a>

### test_basic_member_id/0 * ###

`test_basic_member_id() -> any()`

<a name="test_bundle_map-0"></a>

### test_bundle_map/0 * ###

`test_bundle_map() -> any()`

<a name="test_bundle_with_one_item-0"></a>

### test_bundle_with_one_item/0 * ###

`test_bundle_with_one_item() -> any()`

<a name="test_bundle_with_two_items-0"></a>

### test_bundle_with_two_items/0 * ###

`test_bundle_with_two_items() -> any()`

<a name="test_deep_member-0"></a>

### test_deep_member/0 * ###

`test_deep_member() -> any()`

<a name="test_empty_bundle-0"></a>

### test_empty_bundle/0 * ###

`test_empty_bundle() -> any()`

<a name="test_extremely_large_bundle-0"></a>

### test_extremely_large_bundle/0 * ###

`test_extremely_large_bundle() -> any()`

<a name="test_no_tags-0"></a>

### test_no_tags/0 * ###

`test_no_tags() -> any()`

<a name="test_recursive_bundle-0"></a>

### test_recursive_bundle/0 * ###

`test_recursive_bundle() -> any()`

<a name="test_serialize_deserialize_deep_signed_bundle-0"></a>

### test_serialize_deserialize_deep_signed_bundle/0 * ###

`test_serialize_deserialize_deep_signed_bundle() -> any()`

<a name="test_unsigned_data_item_id-0"></a>

### test_unsigned_data_item_id/0 * ###

`test_unsigned_data_item_id() -> any()`

<a name="test_unsigned_data_item_normalization-0"></a>

### test_unsigned_data_item_normalization/0 * ###

`test_unsigned_data_item_normalization() -> any()`

<a name="test_with_tags-0"></a>

### test_with_tags/0 * ###

`test_with_tags() -> any()`

<a name="test_with_zero_length_tag-0"></a>

### test_with_zero_length_tag/0 * ###

`test_with_zero_length_tag() -> any()`

<a name="to_serialized_pair-1"></a>

### to_serialized_pair/1 * ###

`to_serialized_pair(Item) -> any()`

<a name="type-1"></a>

### type/1 ###

`type(Item) -> any()`

<a name="unbundle-1"></a>

### unbundle/1 * ###

`unbundle(Item) -> any()`

<a name="unbundle_list-1"></a>

### unbundle_list/1 * ###

`unbundle_list(Item) -> any()`

<a name="update_ids-1"></a>

### update_ids/1 * ###

`update_ids(Item) -> any()`

Take an item and ensure that both the unsigned and signed IDs are
appropriately set. This function is structured to fall through all cases
of poorly formed items, recursively ensuring its correctness for each case
until the item has a coherent set of IDs.
The cases in turn are:
- The item has no unsigned_id. This is never valid.
- The item has the default signature and ID. This is valid.
- The item has the default signature but a non-default ID. Reset the ID.
- The item has a signature. We calculate the ID from the signature.
- Valid: The item is fully formed and has both an unsigned and signed ID.

<a name="utf8_encoded-1"></a>

### utf8_encoded/1 * ###

`utf8_encoded(String) -> any()`

Encode a UTF-8 string to binary.

<a name="verify_data_item_id-1"></a>

### verify_data_item_id/1 * ###

`verify_data_item_id(DataItem) -> any()`

Verify the data item's ID matches the signature.

<a name="verify_data_item_signature-1"></a>

### verify_data_item_signature/1 * ###

`verify_data_item_signature(DataItem) -> any()`

Verify the data item's signature.

<a name="verify_data_item_tags-1"></a>

### verify_data_item_tags/1 * ###

`verify_data_item_tags(DataItem) -> any()`

Verify the validity of the data item's tags.

<a name="verify_item-1"></a>

### verify_item/1 ###

`verify_item(DataItem) -> any()`

Verify the validity of a data item.


--- END OF FILE: docs/resources/source-code/ar_bundles.md ---

--- START OF FILE: docs/resources/source-code/ar_deep_hash.md ---
# [Module ar_deep_hash.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_deep_hash.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#hash-1">hash/1</a></td><td></td></tr><tr><td valign="top"><a href="#hash_bin-1">hash_bin/1*</a></td><td></td></tr><tr><td valign="top"><a href="#hash_bin_or_list-1">hash_bin_or_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#hash_list-2">hash_list/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="hash-1"></a>

### hash/1 ###

`hash(List) -> any()`

<a name="hash_bin-1"></a>

### hash_bin/1 * ###

`hash_bin(Bin) -> any()`

<a name="hash_bin_or_list-1"></a>

### hash_bin_or_list/1 * ###

`hash_bin_or_list(Bin) -> any()`

<a name="hash_list-2"></a>

### hash_list/2 * ###

`hash_list(List, Acc) -> any()`


--- END OF FILE: docs/resources/source-code/ar_deep_hash.md ---

--- START OF FILE: docs/resources/source-code/ar_rate_limiter.md ---
# [Module ar_rate_limiter.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_rate_limiter.erl)




__Behaviours:__ [`gen_server`](gen_server.md).

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cut_trace-4">cut_trace/4*</a></td><td></td></tr><tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td></td></tr><tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td></td></tr><tr><td valign="top"><a href="#handle_info-2">handle_info/2</a></td><td></td></tr><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#off-0">off/0</a></td><td>Turn rate limiting off.</td></tr><tr><td valign="top"><a href="#on-0">on/0</a></td><td>Turn rate limiting on.</td></tr><tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td></td></tr><tr><td valign="top"><a href="#terminate-2">terminate/2</a></td><td></td></tr><tr><td valign="top"><a href="#throttle-3">throttle/3</a></td><td>Hang until it is safe to make another request to the given Peer with the
given Path.</td></tr><tr><td valign="top"><a href="#throttle2-3">throttle2/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cut_trace-4"></a>

### cut_trace/4 * ###

`cut_trace(N, Trace, Now, Opts) -> any()`

<a name="handle_call-3"></a>

### handle_call/3 ###

`handle_call(Request, From, State) -> any()`

<a name="handle_cast-2"></a>

### handle_cast/2 ###

`handle_cast(Cast, State) -> any()`

<a name="handle_info-2"></a>

### handle_info/2 ###

`handle_info(Message, State) -> any()`

<a name="init-1"></a>

### init/1 ###

`init(Opts) -> any()`

<a name="off-0"></a>

### off/0 ###

`off() -> any()`

Turn rate limiting off.

<a name="on-0"></a>

### on/0 ###

`on() -> any()`

Turn rate limiting on.

<a name="start_link-1"></a>

### start_link/1 ###

`start_link(Opts) -> any()`

<a name="terminate-2"></a>

### terminate/2 ###

`terminate(Reason, State) -> any()`

<a name="throttle-3"></a>

### throttle/3 ###

`throttle(Peer, Path, Opts) -> any()`

Hang until it is safe to make another request to the given Peer with the
given Path. The limits are configured in include/ar_blacklist_middleware.hrl.

<a name="throttle2-3"></a>

### throttle2/3 * ###

`throttle2(Peer, Path, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/ar_rate_limiter.md ---

--- START OF FILE: docs/resources/source-code/ar_timestamp.md ---
# [Module ar_timestamp.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_timestamp.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cache-1">cache/1*</a></td><td>Cache the current timestamp from Arweave.</td></tr><tr><td valign="top"><a href="#get-0">get/0</a></td><td>Get the current timestamp from the server, starting the server if it
isn't already running.</td></tr><tr><td valign="top"><a href="#refresher-1">refresher/1*</a></td><td>Refresh the timestamp cache periodically.</td></tr><tr><td valign="top"><a href="#spawn_server-0">spawn_server/0*</a></td><td>Spawn a new server and its refresher.</td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td>Check if the server is already running, and if not, start it.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cache-1"></a>

### cache/1 * ###

`cache(Current) -> any()`

Cache the current timestamp from Arweave.

<a name="get-0"></a>

### get/0 ###

`get() -> any()`

Get the current timestamp from the server, starting the server if it
isn't already running.

<a name="refresher-1"></a>

### refresher/1 * ###

`refresher(TSServer) -> any()`

Refresh the timestamp cache periodically.

<a name="spawn_server-0"></a>

### spawn_server/0 * ###

`spawn_server() -> any()`

Spawn a new server and its refresher.

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

Check if the server is already running, and if not, start it.


--- END OF FILE: docs/resources/source-code/ar_timestamp.md ---

--- START OF FILE: docs/resources/source-code/ar_tx.md ---
# [Module ar_tx.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_tx.erl)




The module with utilities for transaction creation, signing, and verification.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#collect_validation_results-2">collect_validation_results/2*</a></td><td></td></tr><tr><td valign="top"><a href="#do_verify-2">do_verify/2*</a></td><td>Verify transaction.</td></tr><tr><td valign="top"><a href="#json_struct_to_tx-1">json_struct_to_tx/1</a></td><td></td></tr><tr><td valign="top"><a href="#new-4">new/4</a></td><td>Create a new transaction.</td></tr><tr><td valign="top"><a href="#new-5">new/5</a></td><td></td></tr><tr><td valign="top"><a href="#sign-2">sign/2</a></td><td>Cryptographically sign (claim ownership of) a transaction.</td></tr><tr><td valign="top"><a href="#signature_data_segment-1">signature_data_segment/1*</a></td><td>Generate the data segment to be signed for a given TX.</td></tr><tr><td valign="top"><a href="#tx_to_json_struct-1">tx_to_json_struct/1</a></td><td></td></tr><tr><td valign="top"><a href="#verify-1">verify/1</a></td><td>Verify whether a transaction is valid.</td></tr><tr><td valign="top"><a href="#verify_hash-1">verify_hash/1*</a></td><td>Verify that the transaction's ID is a hash of its signature.</td></tr><tr><td valign="top"><a href="#verify_signature-2">verify_signature/2*</a></td><td>Verify the transaction's signature.</td></tr><tr><td valign="top"><a href="#verify_tx_id-2">verify_tx_id/2</a></td><td>Verify the given transaction actually has the given identifier.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="collect_validation_results-2"></a>

### collect_validation_results/2 * ###

`collect_validation_results(TXID, Checks) -> any()`

<a name="do_verify-2"></a>

### do_verify/2 * ###

`do_verify(TX, VerifySignature) -> any()`

Verify transaction.

<a name="json_struct_to_tx-1"></a>

### json_struct_to_tx/1 ###

`json_struct_to_tx(TXStruct) -> any()`

<a name="new-4"></a>

### new/4 ###

`new(Dest, Reward, Qty, Last) -> any()`

Create a new transaction.

<a name="new-5"></a>

### new/5 ###

`new(Dest, Reward, Qty, Last, SigType) -> any()`

<a name="sign-2"></a>

### sign/2 ###

`sign(TX, X2) -> any()`

Cryptographically sign (claim ownership of) a transaction.

<a name="signature_data_segment-1"></a>

### signature_data_segment/1 * ###

`signature_data_segment(TX) -> any()`

Generate the data segment to be signed for a given TX.

<a name="tx_to_json_struct-1"></a>

### tx_to_json_struct/1 ###

`tx_to_json_struct(Tx) -> any()`

<a name="verify-1"></a>

### verify/1 ###

`verify(TX) -> any()`

Verify whether a transaction is valid.

<a name="verify_hash-1"></a>

### verify_hash/1 * ###

`verify_hash(Tx) -> any()`

Verify that the transaction's ID is a hash of its signature.

<a name="verify_signature-2"></a>

### verify_signature/2 * ###

`verify_signature(TX, X2) -> any()`

Verify the transaction's signature.

<a name="verify_tx_id-2"></a>

### verify_tx_id/2 ###

`verify_tx_id(ExpectedID, Tx) -> any()`

Verify the given transaction actually has the given identifier.


--- END OF FILE: docs/resources/source-code/ar_tx.md ---

--- START OF FILE: docs/resources/source-code/ar_wallet.md ---
# [Module ar_wallet.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/ar_wallet.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#compress_ecdsa_pubkey-1">compress_ecdsa_pubkey/1*</a></td><td></td></tr><tr><td valign="top"><a href="#hash_address-1">hash_address/1*</a></td><td></td></tr><tr><td valign="top"><a href="#hmac-1">hmac/1</a></td><td></td></tr><tr><td valign="top"><a href="#hmac-2">hmac/2</a></td><td></td></tr><tr><td valign="top"><a href="#load_key-1">load_key/1</a></td><td>Read the keyfile for the key with the given address from disk.</td></tr><tr><td valign="top"><a href="#load_keyfile-1">load_keyfile/1</a></td><td>Extract the public and private key from a keyfile.</td></tr><tr><td valign="top"><a href="#new-0">new/0</a></td><td></td></tr><tr><td valign="top"><a href="#new-1">new/1</a></td><td></td></tr><tr><td valign="top"><a href="#new_keyfile-2">new_keyfile/2</a></td><td>Generate a new wallet public and private key, with a corresponding keyfile.</td></tr><tr><td valign="top"><a href="#sign-2">sign/2</a></td><td>Sign some data with a private key.</td></tr><tr><td valign="top"><a href="#sign-3">sign/3</a></td><td>sign some data, hashed using the provided DigestType.</td></tr><tr><td valign="top"><a href="#to_address-1">to_address/1</a></td><td>Generate an address from a public key.</td></tr><tr><td valign="top"><a href="#to_address-2">to_address/2</a></td><td></td></tr><tr><td valign="top"><a href="#to_rsa_address-1">to_rsa_address/1*</a></td><td></td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td>Verify that a signature is correct.</td></tr><tr><td valign="top"><a href="#verify-4">verify/4</a></td><td></td></tr><tr><td valign="top"><a href="#wallet_filepath-1">wallet_filepath/1*</a></td><td></td></tr><tr><td valign="top"><a href="#wallet_filepath-3">wallet_filepath/3*</a></td><td></td></tr><tr><td valign="top"><a href="#wallet_filepath2-1">wallet_filepath2/1*</a></td><td></td></tr><tr><td valign="top"><a href="#wallet_name-3">wallet_name/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="compress_ecdsa_pubkey-1"></a>

### compress_ecdsa_pubkey/1 * ###

`compress_ecdsa_pubkey(X1) -> any()`

<a name="hash_address-1"></a>

### hash_address/1 * ###

`hash_address(PubKey) -> any()`

<a name="hmac-1"></a>

### hmac/1 ###

`hmac(Data) -> any()`

<a name="hmac-2"></a>

### hmac/2 ###

`hmac(Data, DigestType) -> any()`

<a name="load_key-1"></a>

### load_key/1 ###

`load_key(Addr) -> any()`

Read the keyfile for the key with the given address from disk.
Return not_found if arweave_keyfile_[addr].json or [addr].json is not found
in [data_dir]/?WALLET_DIR.

<a name="load_keyfile-1"></a>

### load_keyfile/1 ###

`load_keyfile(File) -> any()`

Extract the public and private key from a keyfile.

<a name="new-0"></a>

### new/0 ###

`new() -> any()`

<a name="new-1"></a>

### new/1 ###

`new(KeyType) -> any()`

<a name="new_keyfile-2"></a>

### new_keyfile/2 ###

`new_keyfile(KeyType, WalletName) -> any()`

Generate a new wallet public and private key, with a corresponding keyfile.
The provided key is used as part of the file name.

<a name="sign-2"></a>

### sign/2 ###

`sign(Key, Data) -> any()`

Sign some data with a private key.

<a name="sign-3"></a>

### sign/3 ###

`sign(X1, Data, DigestType) -> any()`

sign some data, hashed using the provided DigestType.

<a name="to_address-1"></a>

### to_address/1 ###

`to_address(Pubkey) -> any()`

Generate an address from a public key.

<a name="to_address-2"></a>

### to_address/2 ###

`to_address(PubKey, X2) -> any()`

<a name="to_rsa_address-1"></a>

### to_rsa_address/1 * ###

`to_rsa_address(PubKey) -> any()`

<a name="verify-3"></a>

### verify/3 ###

`verify(Key, Data, Sig) -> any()`

Verify that a signature is correct.

<a name="verify-4"></a>

### verify/4 ###

`verify(X1, Data, Sig, DigestType) -> any()`

<a name="wallet_filepath-1"></a>

### wallet_filepath/1 * ###

`wallet_filepath(Wallet) -> any()`

<a name="wallet_filepath-3"></a>

### wallet_filepath/3 * ###

`wallet_filepath(WalletName, PubKey, KeyType) -> any()`

<a name="wallet_filepath2-1"></a>

### wallet_filepath2/1 * ###

`wallet_filepath2(Wallet) -> any()`

<a name="wallet_name-3"></a>

### wallet_name/3 * ###

`wallet_name(WalletName, PubKey, KeyType) -> any()`


--- END OF FILE: docs/resources/source-code/ar_wallet.md ---

--- START OF FILE: docs/resources/source-code/dev_cache.md ---
# [Module dev_cache.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_cache.erl)




A device that looks up an ID from a local store and returns it,
honoring the `accept` key to return the correct format.

<a name="description"></a>

## Description ##
The cache also
supports writing messages to the store, if the node message has the
writer's address in its `cache_writers` key.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cache_write_binary_test-0">cache_write_binary_test/0*</a></td><td>Ensure that we can write direct binaries to the cache.</td></tr><tr><td valign="top"><a href="#cache_write_message_test-0">cache_write_message_test/0*</a></td><td>Test that the cache can be written to and read from using the hb_cache
API.</td></tr><tr><td valign="top"><a href="#is_trusted_writer-2">is_trusted_writer/2*</a></td><td>Verify that the request originates from a trusted writer.</td></tr><tr><td valign="top"><a href="#link-3">link/3</a></td><td>Link a source to a destination in the cache.</td></tr><tr><td valign="top"><a href="#read-3">read/3</a></td><td>Read data from the cache.</td></tr><tr><td valign="top"><a href="#read_from_cache-2">read_from_cache/2*</a></td><td>Read data from the cache via HTTP.</td></tr><tr><td valign="top"><a href="#setup_test_env-0">setup_test_env/0*</a></td><td>Create a test environment with a local store and node.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write data to the cache.</td></tr><tr><td valign="top"><a href="#write_single-2">write_single/2*</a></td><td>Helper function to write a single data item to the cache.</td></tr><tr><td valign="top"><a href="#write_to_cache-3">write_to_cache/3*</a></td><td>Write data to the cache via HTTP.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cache_write_binary_test-0"></a>

### cache_write_binary_test/0 * ###

`cache_write_binary_test() -> any()`

Ensure that we can write direct binaries to the cache.

<a name="cache_write_message_test-0"></a>

### cache_write_message_test/0 * ###

`cache_write_message_test() -> any()`

Test that the cache can be written to and read from using the hb_cache
API.

<a name="is_trusted_writer-2"></a>

### is_trusted_writer/2 * ###

`is_trusted_writer(Req, Opts) -> any()`

Verify that the request originates from a trusted writer.
Checks that the single signer of the request is present in the list
of trusted cache writer addresses specified in the options.

<a name="link-3"></a>

### link/3 ###

`link(Base, Req, Opts) -> any()`

Link a source to a destination in the cache.

<a name="read-3"></a>

### read/3 ###

`read(M1, M2, Opts) -> any()`

Read data from the cache.
Retrieves data corresponding to a key from a local store.
The key is extracted from the incoming message under <<"target">>.
The options map may include store configuration.
If the "accept" header is set to <<"application/aos-2">>, the result is
converted to a JSON structure and encoded.

<a name="read_from_cache-2"></a>

### read_from_cache/2 * ###

`read_from_cache(Node, Path) -> any()`

Read data from the cache via HTTP.
Constructs a GET request using the provided path, sends it to the node,
and returns the response.

<a name="setup_test_env-0"></a>

### setup_test_env/0 * ###

`setup_test_env() -> any()`

Create a test environment with a local store and node.
Ensures that the required application is started, configures a local
file-system store, resets the store for a clean state, creates a wallet
for signing requests, and starts a node with the store and trusted cache
writer configuration.

<a name="write-3"></a>

### write/3 ###

`write(M1, M2, Opts) -> any()`

Write data to the cache.
Processes a write request by first verifying that the request comes from a
trusted writer (as defined by the `cache_writers` configuration in the
options). The write type is determined from the message ("single" or "batch")
and the data is stored accordingly.

<a name="write_single-2"></a>

### write_single/2 * ###

`write_single(Msg, Opts) -> any()`

Helper function to write a single data item to the cache.
Extracts the body, location, and operation from the message.
Depending on the type of data (map or binary) or if a link operation is
requested, it writes the data to the store using the appropriate function.

<a name="write_to_cache-3"></a>

### write_to_cache/3 * ###

`write_to_cache(Node, Data, Wallet) -> any()`

Write data to the cache via HTTP.
Constructs a write request message with the provided data, signs it with the
given wallet, sends it to the node, and verifies that the response indicates
a successful write.


--- END OF FILE: docs/resources/source-code/dev_cache.md ---

--- START OF FILE: docs/resources/source-code/dev_cacheviz.md ---
# [Module dev_cacheviz.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_cacheviz.erl)




A device that generates renders (or renderable dot output) of a node's
cache.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#dot-3">dot/3</a></td><td>Output the dot representation of the cache, or a specific path within
the cache set by the <code>target</code> key in the request.</td></tr><tr><td valign="top"><a href="#svg-3">svg/3</a></td><td>Output the SVG representation of the cache, or a specific path within
the cache set by the <code>target</code> key in the request.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="dot-3"></a>

### dot/3 ###

`dot(X1, Req, Opts) -> any()`

Output the dot representation of the cache, or a specific path within
the cache set by the `target` key in the request.

<a name="svg-3"></a>

### svg/3 ###

`svg(Base, Req, Opts) -> any()`

Output the SVG representation of the cache, or a specific path within
the cache set by the `target` key in the request.


--- END OF FILE: docs/resources/source-code/dev_cacheviz.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_ans104.md ---
# [Module dev_codec_ans104.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_ans104.erl)




Codec for managing transformations from `ar_bundles`-style Arweave TX
records to and from TABMs.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td>Sign a message using the <code>priv_wallet</code> key in the options.</td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td>Return a list of committed keys from an ANS-104 message.</td></tr><tr><td valign="top"><a href="#committed_from_trusted_keys-3">committed_from_trusted_keys/3*</a></td><td></td></tr><tr><td valign="top"><a href="#content_type-1">content_type/1</a></td><td>Return the content type for the codec.</td></tr><tr><td valign="top"><a href="#deduplicating_from_list-1">deduplicating_from_list/1*</a></td><td>Deduplicate a list of key-value pairs by key, generating a list of
values for each normalized key if there are duplicates.</td></tr><tr><td valign="top"><a href="#deserialize-1">deserialize/1</a></td><td>Deserialize a binary ans104 message to a TABM.</td></tr><tr><td valign="top"><a href="#do_from-1">do_from/1*</a></td><td></td></tr><tr><td valign="top"><a href="#duplicated_tag_name_test-0">duplicated_tag_name_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#encoded_tags_to_map-1">encoded_tags_to_map/1*</a></td><td>Convert an ANS-104 encoded tag list into a HyperBEAM-compatible map.</td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Convert a #tx record into a message map recursively.</td></tr><tr><td valign="top"><a href="#from_maintains_tag_name_case_test-0">from_maintains_tag_name_case_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#id-1">id/1</a></td><td>Return the ID of a message.</td></tr><tr><td valign="top"><a href="#normal_tags-1">normal_tags/1*</a></td><td>Check whether a list of key-value pairs contains only normalized keys.</td></tr><tr><td valign="top"><a href="#normal_tags_test-0">normal_tags_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#only_committed_maintains_target_test-0">only_committed_maintains_target_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#restore_tag_name_case_from_cache_test-0">restore_tag_name_case_from_cache_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#serialize-1">serialize/1</a></td><td>Serialize a message or TX to a binary.</td></tr><tr><td valign="top"><a href="#signed_duplicated_tag_name_test-0">signed_duplicated_tag_name_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_to_conversion_test-0">simple_to_conversion_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#tag_map_to_encoded_tags-1">tag_map_to_encoded_tags/1*</a></td><td>Convert a HyperBEAM-compatible map into an ANS-104 encoded tag list,
recreating the original order of the tags.</td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Internal helper to translate a message to its #tx record representation,
which can then be used by ar_bundles to serialize the message.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td>Verify an ANS-104 commitment.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="commit-3"></a>

### commit/3 ###

`commit(Msg, Req, Opts) -> any()`

Sign a message using the `priv_wallet` key in the options.

<a name="committed-3"></a>

### committed/3 ###

`committed(Msg, Req, Opts) -> any()`

Return a list of committed keys from an ANS-104 message.

<a name="committed_from_trusted_keys-3"></a>

### committed_from_trusted_keys/3 * ###

`committed_from_trusted_keys(Msg, TrustedKeys, Opts) -> any()`

<a name="content_type-1"></a>

### content_type/1 ###

`content_type(X1) -> any()`

Return the content type for the codec.

<a name="deduplicating_from_list-1"></a>

### deduplicating_from_list/1 * ###

`deduplicating_from_list(Tags) -> any()`

Deduplicate a list of key-value pairs by key, generating a list of
values for each normalized key if there are duplicates.

<a name="deserialize-1"></a>

### deserialize/1 ###

`deserialize(Binary) -> any()`

Deserialize a binary ans104 message to a TABM.

<a name="do_from-1"></a>

### do_from/1 * ###

`do_from(RawTX) -> any()`

<a name="duplicated_tag_name_test-0"></a>

### duplicated_tag_name_test/0 * ###

`duplicated_tag_name_test() -> any()`

<a name="encoded_tags_to_map-1"></a>

### encoded_tags_to_map/1 * ###

`encoded_tags_to_map(Tags) -> any()`

Convert an ANS-104 encoded tag list into a HyperBEAM-compatible map.

<a name="from-1"></a>

### from/1 ###

`from(Binary) -> any()`

Convert a #tx record into a message map recursively.

<a name="from_maintains_tag_name_case_test-0"></a>

### from_maintains_tag_name_case_test/0 * ###

`from_maintains_tag_name_case_test() -> any()`

<a name="id-1"></a>

### id/1 ###

`id(Msg) -> any()`

Return the ID of a message.

<a name="normal_tags-1"></a>

### normal_tags/1 * ###

`normal_tags(Tags) -> any()`

Check whether a list of key-value pairs contains only normalized keys.

<a name="normal_tags_test-0"></a>

### normal_tags_test/0 * ###

`normal_tags_test() -> any()`

<a name="only_committed_maintains_target_test-0"></a>

### only_committed_maintains_target_test/0 * ###

`only_committed_maintains_target_test() -> any()`

<a name="restore_tag_name_case_from_cache_test-0"></a>

### restore_tag_name_case_from_cache_test/0 * ###

`restore_tag_name_case_from_cache_test() -> any()`

<a name="serialize-1"></a>

### serialize/1 ###

`serialize(Msg) -> any()`

Serialize a message or TX to a binary.

<a name="signed_duplicated_tag_name_test-0"></a>

### signed_duplicated_tag_name_test/0 * ###

`signed_duplicated_tag_name_test() -> any()`

<a name="simple_to_conversion_test-0"></a>

### simple_to_conversion_test/0 * ###

`simple_to_conversion_test() -> any()`

<a name="tag_map_to_encoded_tags-1"></a>

### tag_map_to_encoded_tags/1 * ###

`tag_map_to_encoded_tags(TagMap) -> any()`

Convert a HyperBEAM-compatible map into an ANS-104 encoded tag list,
recreating the original order of the tags.

<a name="to-1"></a>

### to/1 ###

`to(Binary) -> any()`

Internal helper to translate a message to its #tx record representation,
which can then be used by ar_bundles to serialize the message. We call the
message's device in order to get the keys that we will be checkpointing. We
do this recursively to handle nested messages. The base case is that we hit
a binary, which we return as is.

<a name="verify-3"></a>

### verify/3 ###

`verify(Msg, Req, Opts) -> any()`

Verify an ANS-104 commitment.


--- END OF FILE: docs/resources/source-code/dev_codec_ans104.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_flat.md ---
# [Module dev_codec_flat.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_flat.erl)




A codec for turning TABMs into/from flat Erlang maps that have
(potentially multi-layer) paths as their keys, and a normal TABM binary as
their value.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td></td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td></td></tr><tr><td valign="top"><a href="#deep_nesting_test-0">deep_nesting_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#deserialize-1">deserialize/1</a></td><td></td></tr><tr><td valign="top"><a href="#empty_map_test-0">empty_map_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Convert a flat map to a TABM.</td></tr><tr><td valign="top"><a href="#inject_at_path-3">inject_at_path/3*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_paths_test-0">multiple_paths_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#nested_conversion_test-0">nested_conversion_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#path_list_test-0">path_list_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#serialize-1">serialize/1</a></td><td></td></tr><tr><td valign="top"><a href="#simple_conversion_test-0">simple_conversion_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Convert a TABM to a flat map.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="commit-3"></a>

### commit/3 ###

`commit(Msg, Req, Opts) -> any()`

<a name="committed-3"></a>

### committed/3 ###

`committed(Msg, Req, Opts) -> any()`

<a name="deep_nesting_test-0"></a>

### deep_nesting_test/0 * ###

`deep_nesting_test() -> any()`

<a name="deserialize-1"></a>

### deserialize/1 ###

`deserialize(Bin) -> any()`

<a name="empty_map_test-0"></a>

### empty_map_test/0 * ###

`empty_map_test() -> any()`

<a name="from-1"></a>

### from/1 ###

`from(Bin) -> any()`

Convert a flat map to a TABM.

<a name="inject_at_path-3"></a>

### inject_at_path/3 * ###

`inject_at_path(Rest, Value, Map) -> any()`

<a name="multiple_paths_test-0"></a>

### multiple_paths_test/0 * ###

`multiple_paths_test() -> any()`

<a name="nested_conversion_test-0"></a>

### nested_conversion_test/0 * ###

`nested_conversion_test() -> any()`

<a name="path_list_test-0"></a>

### path_list_test/0 * ###

`path_list_test() -> any()`

<a name="serialize-1"></a>

### serialize/1 ###

`serialize(Map) -> any()`

<a name="simple_conversion_test-0"></a>

### simple_conversion_test/0 * ###

`simple_conversion_test() -> any()`

<a name="to-1"></a>

### to/1 ###

`to(Bin) -> any()`

Convert a TABM to a flat map.

<a name="verify-3"></a>

### verify/3 ###

`verify(Msg, Req, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_codec_flat.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_httpsig_conv.md ---
# [Module dev_codec_httpsig_conv.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_httpsig_conv.erl)




A codec for the that marshals TABM encoded messages to and from the
"HTTP" message structure.

<a name="description"></a>

## Description ##

Every HTTP message is an HTTP multipart message.
See https://datatracker.ietf.org/doc/html/rfc7578

For each TABM Key:

The Key/Value Pair will be encoded according to the following rules:
"signatures" -> {SignatureInput, Signature} header Tuples, each encoded
as a Structured Field Dictionary
"body" ->
- if a map, then recursively encode as its own HyperBEAM message
- otherwise encode as a normal field
_ -> encode as a normal field

Each field will be mapped to the HTTP Message according to the following
rules:
"body" -> always encoded part of the body as with Content-Disposition
type of "inline"
_ ->
- If the byte size of the value is less than the ?MAX_TAG_VALUE,
then encode as a header, also attempting to encode as a
structured field.
- Otherwise encode the value as a part in the multipart response
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#boundary_from_parts-1">boundary_from_parts/1*</a></td><td>Generate a unique, reproducible boundary for the
multipart body, however we cannot use the id of the message as
the boundary, as the id is not known until the message is
encoded.</td></tr><tr><td valign="top"><a href="#commitments_from_signature-4">commitments_from_signature/4*</a></td><td>Populate the <code>/commitments</code> key on the TABM with the dictionary of
signatures and their corresponding inputs.</td></tr><tr><td valign="top"><a href="#do_to-2">do_to/2*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_body_keys-1">encode_body_keys/1*</a></td><td>Encode a list of body parts into a binary.</td></tr><tr><td valign="top"><a href="#encode_body_part-3">encode_body_part/3*</a></td><td>Encode a multipart body part to a flat binary.</td></tr><tr><td valign="top"><a href="#encode_http_msg-1">encode_http_msg/1*</a></td><td>Encode a HTTP message into a binary.</td></tr><tr><td valign="top"><a href="#extract_hashpaths-1">extract_hashpaths/1*</a></td><td>Extract all keys labelled <code>hashpath*</code> from the commitments, and add them
to the HTTP message as <code>hashpath*</code> keys.</td></tr><tr><td valign="top"><a href="#field_to_http-3">field_to_http/3*</a></td><td>All maps are encoded into the body of the HTTP message
to be further encoded later.</td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Convert a HTTP Message into a TABM.</td></tr><tr><td valign="top"><a href="#from_body-4">from_body/4*</a></td><td></td></tr><tr><td valign="top"><a href="#from_body_parts-3">from_body_parts/3*</a></td><td></td></tr><tr><td valign="top"><a href="#group_ids-1">group_ids/1*</a></td><td>Group all elements with:
1.</td></tr><tr><td valign="top"><a href="#group_maps-1">group_maps/1*</a></td><td>Merge maps at the same level, if possible.</td></tr><tr><td valign="top"><a href="#group_maps-3">group_maps/3*</a></td><td></td></tr><tr><td valign="top"><a href="#group_maps_flat_compatible_test-0">group_maps_flat_compatible_test/0*</a></td><td>The grouped maps encoding is a subset of the flat encoding,
where on keys with maps values are flattened.</td></tr><tr><td valign="top"><a href="#group_maps_test-0">group_maps_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#hashpaths_from_message-1">hashpaths_from_message/1*</a></td><td></td></tr><tr><td valign="top"><a href="#inline_key-1">inline_key/1*</a></td><td>given a message, returns a binary tuple:
- A list of pairs to add to the msg, if any
- the field name for the inlined key.</td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Convert a TABM into an HTTP Message.</td></tr><tr><td valign="top"><a href="#to-2">to/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ungroup_ids-1">ungroup_ids/1*</a></td><td>Decode the <code>ao-ids</code> key into a map.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="boundary_from_parts-1"></a>

### boundary_from_parts/1 * ###

`boundary_from_parts(PartList) -> any()`

Generate a unique, reproducible boundary for the
multipart body, however we cannot use the id of the message as
the boundary, as the id is not known until the message is
encoded. Subsequently, we generate each body part individually,
concatenate them, and apply a SHA2-256 hash to the result.
This ensures that the boundary is unique, reproducible, and
secure.

<a name="commitments_from_signature-4"></a>

### commitments_from_signature/4 * ###

`commitments_from_signature(Map, HPs, RawSig, RawSigInput) -> any()`

Populate the `/commitments` key on the TABM with the dictionary of
signatures and their corresponding inputs.

<a name="do_to-2"></a>

### do_to/2 * ###

`do_to(Binary, Opts) -> any()`

<a name="encode_body_keys-1"></a>

### encode_body_keys/1 * ###

`encode_body_keys(PartList) -> any()`

Encode a list of body parts into a binary.

<a name="encode_body_part-3"></a>

### encode_body_part/3 * ###

`encode_body_part(PartName, BodyPart, InlineKey) -> any()`

Encode a multipart body part to a flat binary.

<a name="encode_http_msg-1"></a>

### encode_http_msg/1 * ###

`encode_http_msg(Httpsig) -> any()`

Encode a HTTP message into a binary.

<a name="extract_hashpaths-1"></a>

### extract_hashpaths/1 * ###

`extract_hashpaths(Map) -> any()`

Extract all keys labelled `hashpath*` from the commitments, and add them
to the HTTP message as `hashpath*` keys.

<a name="field_to_http-3"></a>

### field_to_http/3 * ###

`field_to_http(Httpsig, X2, Opts) -> any()`

All maps are encoded into the body of the HTTP message
to be further encoded later.

<a name="from-1"></a>

### from/1 ###

`from(Bin) -> any()`

Convert a HTTP Message into a TABM.
HTTP Structured Field is encoded into it's equivalent TABM encoding.

<a name="from_body-4"></a>

### from_body/4 * ###

`from_body(TABM, InlinedKey, ContentType, Body) -> any()`

<a name="from_body_parts-3"></a>

### from_body_parts/3 * ###

`from_body_parts(TABM, InlinedKey, Rest) -> any()`

<a name="group_ids-1"></a>

### group_ids/1 * ###

`group_ids(Map) -> any()`

Group all elements with:
1. A key that ?IS_ID returns true for, and
2. A value that is immediate
into a combined SF dict-_like_ structure. If not encoded, these keys would
be sent as headers and lower-cased, losing their comparability against the
original keys. The structure follows all SF dict rules, except that it allows
for keys to contain capitals. The HyperBEAM SF parser will accept these keys,
but standard RFC 8741 parsers will not. Subsequently, the resulting `ao-cased`
key is not added to the `ao-types` map.

<a name="group_maps-1"></a>

### group_maps/1 * ###

`group_maps(Map) -> any()`

Merge maps at the same level, if possible.

<a name="group_maps-3"></a>

### group_maps/3 * ###

`group_maps(Map, Parent, Top) -> any()`

<a name="group_maps_flat_compatible_test-0"></a>

### group_maps_flat_compatible_test/0 * ###

`group_maps_flat_compatible_test() -> any()`

The grouped maps encoding is a subset of the flat encoding,
where on keys with maps values are flattened.

So despite needing a special encoder to produce it
We can simply apply the flat encoder to it to get back
the original message.

The test asserts that is indeed the case.

<a name="group_maps_test-0"></a>

### group_maps_test/0 * ###

`group_maps_test() -> any()`

<a name="hashpaths_from_message-1"></a>

### hashpaths_from_message/1 * ###

`hashpaths_from_message(Msg) -> any()`

<a name="inline_key-1"></a>

### inline_key/1 * ###

`inline_key(Msg) -> any()`

given a message, returns a binary tuple:
- A list of pairs to add to the msg, if any
- the field name for the inlined key

In order to preserve the field name of the inlined
part, an additional field may need to be added

<a name="to-1"></a>

### to/1 ###

`to(Bin) -> any()`

Convert a TABM into an HTTP Message. The HTTP Message is a simple Erlang Map
that can translated to a given web server Response API

<a name="to-2"></a>

### to/2 * ###

`to(TABM, Opts) -> any()`

<a name="ungroup_ids-1"></a>

### ungroup_ids/1 * ###

`ungroup_ids(Msg) -> any()`

Decode the `ao-ids` key into a map.


--- END OF FILE: docs/resources/source-code/dev_codec_httpsig_conv.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_httpsig.md ---
# [Module dev_codec_httpsig.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_httpsig.erl)



* [Data Types](#types)

This module implements HTTP Message Signatures as described in RFC-9421
(https://datatracker.ietf.org/doc/html/rfc9421), as an AO-Core device.

<a name="description"></a>

## Description ##
It implements the codec standard (from/1, to/1), as well as the optional
commitment functions (id/3, sign/3, verify/3). The commitment functions
are found in this module, while the codec functions are relayed to the
`dev_codec_httpsig_conv` module.
<a name="types"></a>

## Data Types ##




### <a name="type-authority_state">authority_state()</a> ###


<pre><code>
authority_state() = #{component_identifiers =&gt; [<a href="#type-component_identifier">component_identifier()</a>], sig_params =&gt; <a href="#type-signature_params">signature_params()</a>, key =&gt; binary()}
</code></pre>




### <a name="type-component_identifier">component_identifier()</a> ###


<pre><code>
component_identifier() = {item, {string, binary()}, {binary(), integer() | boolean() | {string | token | binary, binary()}}}
</code></pre>




### <a name="type-fields">fields()</a> ###


<pre><code>
fields() = #{binary() | atom() | string() =&gt; binary() | atom() | string()}
</code></pre>




### <a name="type-request_message">request_message()</a> ###


<pre><code>
request_message() = #{url =&gt; binary(), method =&gt; binary(), headers =&gt; <a href="#type-fields">fields()</a>, trailers =&gt; <a href="#type-fields">fields()</a>, is_absolute_form =&gt; boolean()}
</code></pre>




### <a name="type-response_message">response_message()</a> ###


<pre><code>
response_message() = #{status =&gt; integer(), headers =&gt; <a href="#type-fields">fields()</a>, trailers =&gt; <a href="#type-fields">fields()</a>}
</code></pre>




### <a name="type-signature_params">signature_params()</a> ###


<pre><code>
signature_params() = #{atom() | binary() | string() =&gt; binary() | integer()}
</code></pre>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_content_digest-1">add_content_digest/1</a></td><td>If the <code>body</code> key is present, replace it with a content-digest.</td></tr><tr><td valign="top"><a href="#add_derived_specifiers-1">add_derived_specifiers/1</a></td><td>Normalize key parameters to ensure their names are correct.</td></tr><tr><td valign="top"><a href="#add_sig_params-2">add_sig_params/2*</a></td><td>Add the signature parameters to the authority state.</td></tr><tr><td valign="top"><a href="#address_to_sig_name-1">address_to_sig_name/1*</a></td><td>Convert an address to a signature name that is short, unique to the
address, and lowercase.</td></tr><tr><td valign="top"><a href="#authority-3">authority/3*</a></td><td>A helper to validate and produce an "Authority" State.</td></tr><tr><td valign="top"><a href="#bin-1">bin/1*</a></td><td></td></tr><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td>Main entrypoint for signing a HTTP Message, using the standardized format.</td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td>Return the list of committed keys from a message.</td></tr><tr><td valign="top"><a href="#committed_from_body-1">committed_from_body/1*</a></td><td>Return the list of committed keys from a message that are derived from
the body components.</td></tr><tr><td valign="top"><a href="#committed_id_test-0">committed_id_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#derive_component-3">derive_component/3*</a></td><td>Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, specifically a "Derived" Component within the Messages Context,
and return the normalized form of the identifier, along with the extracted
encoded value.</td></tr><tr><td valign="top"><a href="#derive_component-4">derive_component/4*</a></td><td></td></tr><tr><td valign="top"><a href="#derive_component_error_query_param_no_name_test-0">derive_component_error_query_param_no_name_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#derive_component_error_req_param_on_request_target_test-0">derive_component_error_req_param_on_request_target_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#derive_component_error_status_req_target_test-0">derive_component_error_status_req_target_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#do_committed-4">do_committed/4*</a></td><td></td></tr><tr><td valign="top"><a href="#extract_dictionary_field_value-2">extract_dictionary_field_value/2*</a></td><td>Extract a value from a Structured Field, and return the normalized field,
along with the encoded value.</td></tr><tr><td valign="top"><a href="#extract_field-3">extract_field/3*</a></td><td>Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, specifically a field on a Message within the Messages Context,
and return the normalized form of the identifier, along with the extracted
encoded value.</td></tr><tr><td valign="top"><a href="#extract_field_value-2">extract_field_value/2*</a></td><td>Extract values from the field and return the normalized field,
along with encoded value.</td></tr><tr><td valign="top"><a href="#find_byte_sequence_param-1">find_byte_sequence_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_id-1">find_id/1*</a></td><td>Find the ID of the message, which is the hmac of the fields referenced in
the signature and signature input.</td></tr><tr><td valign="top"><a href="#find_key_param-1">find_key_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_name_param-1">find_name_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_request_param-1">find_request_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_sf_param-3">find_sf_param/3*</a></td><td>Given a parameter Name, extract the Parameter value from the HTTP
Structured Field data structure.</td></tr><tr><td valign="top"><a href="#find_strict_format_param-1">find_strict_format_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_trailer_param-1">find_trailer_param/1*</a></td><td></td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td></td></tr><tr><td valign="top"><a href="#hmac-1">hmac/1*</a></td><td>Generate the ID of the message, with the current signature and signature
input as the components for the hmac.</td></tr><tr><td valign="top"><a href="#id-3">id/3</a></td><td></td></tr><tr><td valign="top"><a href="#identifier_to_component-3">identifier_to_component/3*</a></td><td>Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, and return the normalized form of the identifier, along with the
extracted encoded value.</td></tr><tr><td valign="top"><a href="#join_signature_base-2">join_signature_base/2*</a></td><td></td></tr><tr><td valign="top"><a href="#join_signature_base_test-0">join_signature_base_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#lower_bin-1">lower_bin/1*</a></td><td></td></tr><tr><td valign="top"><a href="#multicommitted_id_test-0">multicommitted_id_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_component_identifiers-1">normalize_component_identifiers/1*</a></td><td>Takes a list of keys that will be used in the signature inputs and
ensures that they have deterministic sorting, as well as the coorect
component identifiers if applicable.</td></tr><tr><td valign="top"><a href="#public_keys-1">public_keys/1</a></td><td></td></tr><tr><td valign="top"><a href="#remove_derived_specifiers-1">remove_derived_specifiers/1</a></td><td>Remove derived specifiers from a list of component identifiers.</td></tr><tr><td valign="top"><a href="#reset_hmac-1">reset_hmac/1</a></td><td>Ensure that the commitments and hmac are properly encoded.</td></tr><tr><td valign="top"><a href="#sf_encode-1">sf_encode/1*</a></td><td>Attempt to encode the data structure into an HTTP Structured Field.</td></tr><tr><td valign="top"><a href="#sf_encode-2">sf_encode/2*</a></td><td></td></tr><tr><td valign="top"><a href="#sf_item-1">sf_item/1*</a></td><td>Attempt to parse the provided value into an HTTP Structured Field Item.</td></tr><tr><td valign="top"><a href="#sf_parse-1">sf_parse/1*</a></td><td>Attempt to parse the binary into a data structure that represents
an HTTP Structured Field.</td></tr><tr><td valign="top"><a href="#sf_parse-2">sf_parse/2*</a></td><td></td></tr><tr><td valign="top"><a href="#sf_signature_param-1">sf_signature_param/1*</a></td><td>construct the structured field Parameter for the signature parameter,
checking whether the parameter name is valid according RFC-9421.</td></tr><tr><td valign="top"><a href="#sf_signature_params-2">sf_signature_params/2*</a></td><td>construct the structured field List for the
"signature-params-line" part of the signature base.</td></tr><tr><td valign="top"><a href="#sig_name_from_dict-1">sig_name_from_dict/1*</a></td><td></td></tr><tr><td valign="top"><a href="#sign_auth-3">sign_auth/3*</a></td><td>using the provided Authority and Request/Response Messages Context,
create a Name, Signature and SignatureInput that can be used to additional
signatures to a corresponding HTTP Message.</td></tr><tr><td valign="top"><a href="#signature_base-3">signature_base/3*</a></td><td>create the signature base that will be signed in order to create the
Signature and SignatureInput.</td></tr><tr><td valign="top"><a href="#signature_components_line-3">signature_components_line/3*</a></td><td>Given a list of Component Identifiers and a Request/Response Message
context, create the "signature-base-line" portion of the signature base.</td></tr><tr><td valign="top"><a href="#signature_params_line-2">signature_params_line/2*</a></td><td>construct the "signature-params-line" part of the signature base.</td></tr><tr><td valign="top"><a href="#signature_params_line_test-0">signature_params_line_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td></td></tr><tr><td valign="top"><a href="#trim_and_normalize-1">trim_and_normalize/1*</a></td><td></td></tr><tr><td valign="top"><a href="#trim_ws-1">trim_ws/1*</a></td><td>Recursively trim space characters from the beginning of the binary.</td></tr><tr><td valign="top"><a href="#trim_ws_end-2">trim_ws_end/2*</a></td><td></td></tr><tr><td valign="top"><a href="#trim_ws_test-0">trim_ws_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#upper_bin-1">upper_bin/1*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_large_message_from_http_test-0">validate_large_message_from_http_test/0*</a></td><td>Ensure that we can validate a signature on an extremely large and complex
message that is sent over HTTP, signed with the codec.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td>Verify different forms of httpsig committed messages.</td></tr><tr><td valign="top"><a href="#verify_auth-2">verify_auth/2*</a></td><td>same verify/3, but with an empty Request Message Context.</td></tr><tr><td valign="top"><a href="#verify_auth-3">verify_auth/3*</a></td><td>Given the signature name, and the Request/Response Message Context
verify the named signature by constructing the signature base and comparing.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_content_digest-1"></a>

### add_content_digest/1 ###

`add_content_digest(Msg) -> any()`

If the `body` key is present, replace it with a content-digest.

<a name="add_derived_specifiers-1"></a>

### add_derived_specifiers/1 ###

`add_derived_specifiers(ComponentIdentifiers) -> any()`

Normalize key parameters to ensure their names are correct.

<a name="add_sig_params-2"></a>

### add_sig_params/2 * ###

`add_sig_params(Authority, X2) -> any()`

Add the signature parameters to the authority state

<a name="address_to_sig_name-1"></a>

### address_to_sig_name/1 * ###

<pre><code>
address_to_sig_name(Address::binary()) -&gt; binary()
</code></pre>
<br />

Convert an address to a signature name that is short, unique to the
address, and lowercase.

<a name="authority-3"></a>

### authority/3 * ###

<pre><code>
authority(ComponentIdentifiers::[binary() | <a href="#type-component_identifier">component_identifier()</a>], SigParams::#{binary() =&gt; binary() | integer()}, PubKey::{}) -&gt; <a href="#type-authority_state">authority_state()</a>
</code></pre>
<br />

A helper to validate and produce an "Authority" State

<a name="bin-1"></a>

### bin/1 * ###

`bin(Item) -> any()`

<a name="commit-3"></a>

### commit/3 ###

`commit(MsgToSign, Req, Opts) -> any()`

Main entrypoint for signing a HTTP Message, using the standardized format.

<a name="committed-3"></a>

### committed/3 ###

`committed(RawMsg, Req, Opts) -> any()`

Return the list of committed keys from a message. The message will have
had the `commitments` key removed and the signature inputs added to the
root. Subsequently, we can parse that to get the list of committed keys.

<a name="committed_from_body-1"></a>

### committed_from_body/1 * ###

`committed_from_body(Msg) -> any()`

Return the list of committed keys from a message that are derived from
the body components.

<a name="committed_id_test-0"></a>

### committed_id_test/0 * ###

`committed_id_test() -> any()`

<a name="derive_component-3"></a>

### derive_component/3 * ###

`derive_component(Identifier, Req, Res) -> any()`

Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, specifically a "Derived" Component within the Messages Context,
and return the normalized form of the identifier, along with the extracted
encoded value.

This implements a portion of RFC-9421
See https://datatracker.ietf.org/doc/html/rfc9421#name-derived-components

<a name="derive_component-4"></a>

### derive_component/4 * ###

`derive_component(X1, Req, Res, Subject) -> any()`

<a name="derive_component_error_query_param_no_name_test-0"></a>

### derive_component_error_query_param_no_name_test/0 * ###

`derive_component_error_query_param_no_name_test() -> any()`

<a name="derive_component_error_req_param_on_request_target_test-0"></a>

### derive_component_error_req_param_on_request_target_test/0 * ###

`derive_component_error_req_param_on_request_target_test() -> any()`

<a name="derive_component_error_status_req_target_test-0"></a>

### derive_component_error_status_req_target_test/0 * ###

`derive_component_error_status_req_target_test() -> any()`

<a name="do_committed-4"></a>

### do_committed/4 * ###

`do_committed(SigInputStr, Msg, Req, Opts) -> any()`

<a name="extract_dictionary_field_value-2"></a>

### extract_dictionary_field_value/2 * ###

`extract_dictionary_field_value(StructuredField, Key) -> any()`

Extract a value from a Structured Field, and return the normalized field,
along with the encoded value

<a name="extract_field-3"></a>

### extract_field/3 * ###

`extract_field(X1, Req, Res) -> any()`

Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, specifically a field on a Message within the Messages Context,
and return the normalized form of the identifier, along with the extracted
encoded value.

This implements a portion of RFC-9421
See https://datatracker.ietf.org/doc/html/rfc9421#name-http-fields

<a name="extract_field_value-2"></a>

### extract_field_value/2 * ###

`extract_field_value(RawFields, X2) -> any()`

Extract values from the field and return the normalized field,
along with encoded value

<a name="find_byte_sequence_param-1"></a>

### find_byte_sequence_param/1 * ###

`find_byte_sequence_param(Params) -> any()`

<a name="find_id-1"></a>

### find_id/1 * ###

`find_id(Msg) -> any()`

Find the ID of the message, which is the hmac of the fields referenced in
the signature and signature input. If the message already has a signature-input,
directly, it is treated differently: We relabel it as `x-signature-input` to
avoid key collisions.

<a name="find_key_param-1"></a>

### find_key_param/1 * ###

`find_key_param(Params) -> any()`

<a name="find_name_param-1"></a>

### find_name_param/1 * ###

`find_name_param(Params) -> any()`

<a name="find_request_param-1"></a>

### find_request_param/1 * ###

`find_request_param(Params) -> any()`

<a name="find_sf_param-3"></a>

### find_sf_param/3 * ###

`find_sf_param(Name, Params, Default) -> any()`

Given a parameter Name, extract the Parameter value from the HTTP
Structured Field data structure.

If no value is found, then false is returned

<a name="find_strict_format_param-1"></a>

### find_strict_format_param/1 * ###

`find_strict_format_param(Params) -> any()`

<a name="find_trailer_param-1"></a>

### find_trailer_param/1 * ###

`find_trailer_param(Params) -> any()`

<a name="from-1"></a>

### from/1 ###

`from(Msg) -> any()`

<a name="hmac-1"></a>

### hmac/1 * ###

`hmac(Msg) -> any()`

Generate the ID of the message, with the current signature and signature
input as the components for the hmac.

<a name="id-3"></a>

### id/3 ###

`id(Msg, Params, Opts) -> any()`

<a name="identifier_to_component-3"></a>

### identifier_to_component/3 * ###

`identifier_to_component(Identifier, Req, Res) -> any()`

Given a Component Identifier and a Request/Response Messages Context
extract the value represented by the Component Identifier, from the Messages
Context, and return the normalized form of the identifier, along with the
extracted encoded value.

Generally speaking, a Component Identifier may reference a "Derived" Component,
a Message Field, or a sub-component of a Message Field.

Since a Component Identifier is itself a Structured Field, it may also specify
parameters, which are used to describe behavior such as which Message to
derive a field or sub-component of the field, and how to encode the value as
part of the signature base.

<a name="join_signature_base-2"></a>

### join_signature_base/2 * ###

`join_signature_base(ComponentsLine, ParamsLine) -> any()`

<a name="join_signature_base_test-0"></a>

### join_signature_base_test/0 * ###

`join_signature_base_test() -> any()`

<a name="lower_bin-1"></a>

### lower_bin/1 * ###

`lower_bin(Item) -> any()`

<a name="multicommitted_id_test-0"></a>

### multicommitted_id_test/0 * ###

`multicommitted_id_test() -> any()`

<a name="normalize_component_identifiers-1"></a>

### normalize_component_identifiers/1 * ###

`normalize_component_identifiers(ComponentIdentifiers) -> any()`

Takes a list of keys that will be used in the signature inputs and
ensures that they have deterministic sorting, as well as the coorect
component identifiers if applicable.

<a name="public_keys-1"></a>

### public_keys/1 ###

`public_keys(Commitment) -> any()`

<a name="remove_derived_specifiers-1"></a>

### remove_derived_specifiers/1 ###

`remove_derived_specifiers(ComponentIdentifiers) -> any()`

Remove derived specifiers from a list of component identifiers.

<a name="reset_hmac-1"></a>

### reset_hmac/1 ###

`reset_hmac(RawMsg) -> any()`

Ensure that the commitments and hmac are properly encoded

<a name="sf_encode-1"></a>

### sf_encode/1 * ###

`sf_encode(StructuredField) -> any()`

Attempt to encode the data structure into an HTTP Structured Field.
This is the inverse of sf_parse.

<a name="sf_encode-2"></a>

### sf_encode/2 * ###

`sf_encode(Serializer, StructuredField) -> any()`

<a name="sf_item-1"></a>

### sf_item/1 * ###

`sf_item(SfItem) -> any()`

Attempt to parse the provided value into an HTTP Structured Field Item

<a name="sf_parse-1"></a>

### sf_parse/1 * ###

`sf_parse(Raw) -> any()`

Attempt to parse the binary into a data structure that represents
an HTTP Structured Field.

Lacking some sort of "hint", there isn't a way to know which "kind" of
Structured Field the binary is, apriori. So we simply try each parser,
and return the first invocation that doesn't result in an error.

If no parser is successful, then we return an error tuple

<a name="sf_parse-2"></a>

### sf_parse/2 * ###

`sf_parse(Rest, Raw) -> any()`

<a name="sf_signature_param-1"></a>

### sf_signature_param/1 * ###

`sf_signature_param(X1) -> any()`

construct the structured field Parameter for the signature parameter,
checking whether the parameter name is valid according RFC-9421

See https://datatracker.ietf.org/doc/html/rfc9421#section-2.3-3

<a name="sf_signature_params-2"></a>

### sf_signature_params/2 * ###

`sf_signature_params(ComponentIdentifiers, SigParams) -> any()`

construct the structured field List for the
"signature-params-line" part of the signature base.

Can be parsed into a binary by simply passing to hb_structured_fields:list/1

See https://datatracker.ietf.org/doc/html/rfc9421#section-2.5-7.3.2.4

<a name="sig_name_from_dict-1"></a>

### sig_name_from_dict/1 * ###

`sig_name_from_dict(DictBin) -> any()`

<a name="sign_auth-3"></a>

### sign_auth/3 * ###

<pre><code>
sign_auth(Authority::<a href="#type-authority_state">authority_state()</a>, Req::<a href="#type-request_message">request_message()</a>, Res::<a href="#type-response_message">response_message()</a>) -&gt; {ok, {binary(), binary(), binary()}}
</code></pre>
<br />

using the provided Authority and Request/Response Messages Context,
create a Name, Signature and SignatureInput that can be used to additional
signatures to a corresponding HTTP Message

<a name="signature_base-3"></a>

### signature_base/3 * ###

`signature_base(Authority, Req, Res) -> any()`

create the signature base that will be signed in order to create the
Signature and SignatureInput.

This implements a portion of RFC-9421 see:
https://datatracker.ietf.org/doc/html/rfc9421#name-creating-the-signature-base

<a name="signature_components_line-3"></a>

### signature_components_line/3 * ###

`signature_components_line(ComponentIdentifiers, Req, Res) -> any()`

Given a list of Component Identifiers and a Request/Response Message
context, create the "signature-base-line" portion of the signature base

<a name="signature_params_line-2"></a>

### signature_params_line/2 * ###

`signature_params_line(ComponentIdentifiers, SigParams) -> any()`

construct the "signature-params-line" part of the signature base.

See https://datatracker.ietf.org/doc/html/rfc9421#section-2.5-7.3.2.4

<a name="signature_params_line_test-0"></a>

### signature_params_line_test/0 * ###

`signature_params_line_test() -> any()`

<a name="to-1"></a>

### to/1 ###

`to(Msg) -> any()`

<a name="trim_and_normalize-1"></a>

### trim_and_normalize/1 * ###

`trim_and_normalize(Bin) -> any()`

<a name="trim_ws-1"></a>

### trim_ws/1 * ###

`trim_ws(Bin) -> any()`

Recursively trim space characters from the beginning of the binary

<a name="trim_ws_end-2"></a>

### trim_ws_end/2 * ###

`trim_ws_end(Value, N) -> any()`

<a name="trim_ws_test-0"></a>

### trim_ws_test/0 * ###

`trim_ws_test() -> any()`

<a name="upper_bin-1"></a>

### upper_bin/1 * ###

`upper_bin(Item) -> any()`

<a name="validate_large_message_from_http_test-0"></a>

### validate_large_message_from_http_test/0 * ###

`validate_large_message_from_http_test() -> any()`

Ensure that we can validate a signature on an extremely large and complex
message that is sent over HTTP, signed with the codec.

<a name="verify-3"></a>

### verify/3 ###

`verify(MsgToVerify, Req, Opts) -> any()`

Verify different forms of httpsig committed messages. `dev_message:verify`
already places the keys from the commitment message into the root of the
message.

<a name="verify_auth-2"></a>

### verify_auth/2 * ###

`verify_auth(Verifier, Msg) -> any()`

same verify/3, but with an empty Request Message Context

<a name="verify_auth-3"></a>

### verify_auth/3 * ###

`verify_auth(X1, Req, Res) -> any()`

Given the signature name, and the Request/Response Message Context
verify the named signature by constructing the signature base and comparing


--- END OF FILE: docs/resources/source-code/dev_codec_httpsig.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_json.md ---
# [Module dev_codec_json.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_json.erl)




A simple JSON codec for HyperBEAM's message format.

<a name="description"></a>

## Description ##
Takes a
message as TABM and returns an encoded JSON string representation.
This codec utilizes the httpsig@1.0 codec for signing and verifying.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td></td></tr><tr><td valign="top"><a href="#committed-1">committed/1</a></td><td></td></tr><tr><td valign="top"><a href="#content_type-1">content_type/1</a></td><td>Return the content type for the codec.</td></tr><tr><td valign="top"><a href="#deserialize-3">deserialize/3</a></td><td>Deserialize the JSON string found at the given path.</td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Decode a JSON string to a message.</td></tr><tr><td valign="top"><a href="#serialize-3">serialize/3</a></td><td>Serialize a message to a JSON string.</td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Encode a message to a JSON string.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="commit-3"></a>

### commit/3 ###

`commit(Msg, Req, Opts) -> any()`

<a name="committed-1"></a>

### committed/1 ###

`committed(Msg) -> any()`

<a name="content_type-1"></a>

### content_type/1 ###

`content_type(X1) -> any()`

Return the content type for the codec.

<a name="deserialize-3"></a>

### deserialize/3 ###

`deserialize(Base, Req, Opts) -> any()`

Deserialize the JSON string found at the given path.

<a name="from-1"></a>

### from/1 ###

`from(Map) -> any()`

Decode a JSON string to a message.

<a name="serialize-3"></a>

### serialize/3 ###

`serialize(Base, Msg, Opts) -> any()`

Serialize a message to a JSON string.

<a name="to-1"></a>

### to/1 ###

`to(Msg) -> any()`

Encode a message to a JSON string.

<a name="verify-3"></a>

### verify/3 ###

`verify(Msg, Req, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_codec_json.md ---

--- START OF FILE: docs/resources/source-code/dev_codec_structured.md ---
# [Module dev_codec_structured.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_codec_structured.erl)




A device implementing the codec interface (to/1, from/1) for
HyperBEAM's internal, richly typed message format.

<a name="description"></a>

## Description ##

This format mirrors HTTP Structured Fields, aside from its limitations of
compound type depths, as well as limited floating point representations.

As with all AO-Core codecs, its target format (the format it expects to
receive in the `to/1` function, and give in `from/1`) is TABM.

For more details, see the HTTP Structured Fields (RFC-9651) specification.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td></td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td></td></tr><tr><td valign="top"><a href="#decode_value-2">decode_value/2</a></td><td>Convert non-binary values to binary for serialization.</td></tr><tr><td valign="top"><a href="#encode_value-1">encode_value/1</a></td><td>Convert a term to a binary representation, emitting its type for
serialization as a separate tag.</td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Convert a rich message into a 'Type-Annotated-Binary-Message' (TABM).</td></tr><tr><td valign="top"><a href="#implicit_keys-1">implicit_keys/1</a></td><td>Find the implicit keys of a TABM.</td></tr><tr><td valign="top"><a href="#list_encoding_test-0">list_encoding_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_ao_types-1">parse_ao_types/1*</a></td><td>Parse the <code>ao-types</code> field of a TABM and return a map of keys and their
types.</td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Convert a TABM into a native HyperBEAM message.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="commit-3"></a>

### commit/3 ###

`commit(Msg, Req, Opts) -> any()`

<a name="committed-3"></a>

### committed/3 ###

`committed(Msg, Req, Opts) -> any()`

<a name="decode_value-2"></a>

### decode_value/2 ###

`decode_value(Type, Value) -> any()`

Convert non-binary values to binary for serialization.

<a name="encode_value-1"></a>

### encode_value/1 ###

`encode_value(Value) -> any()`

Convert a term to a binary representation, emitting its type for
serialization as a separate tag.

<a name="from-1"></a>

### from/1 ###

`from(Bin) -> any()`

Convert a rich message into a 'Type-Annotated-Binary-Message' (TABM).

<a name="implicit_keys-1"></a>

### implicit_keys/1 ###

`implicit_keys(Req) -> any()`

Find the implicit keys of a TABM.

<a name="list_encoding_test-0"></a>

### list_encoding_test/0 * ###

`list_encoding_test() -> any()`

<a name="parse_ao_types-1"></a>

### parse_ao_types/1 * ###

`parse_ao_types(Msg) -> any()`

Parse the `ao-types` field of a TABM and return a map of keys and their
types

<a name="to-1"></a>

### to/1 ###

`to(Bin) -> any()`

Convert a TABM into a native HyperBEAM message.

<a name="verify-3"></a>

### verify/3 ###

`verify(Msg, Req, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_codec_structured.md ---

--- START OF FILE: docs/resources/source-code/dev_cron.md ---
# [Module dev_cron.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_cron.erl)




A device that inserts new messages into the schedule to allow processes
to passively 'call' themselves without user interaction.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#every-3">every/3</a></td><td>Exported function for scheduling a recurring message.</td></tr><tr><td valign="top"><a href="#every_worker_loop-4">every_worker_loop/4*</a></td><td></td></tr><tr><td valign="top"><a href="#every_worker_loop_test-0">every_worker_loop_test/0*</a></td><td>This test verifies that a recurring task can be scheduled and executed.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Exported function for getting device info.</td></tr><tr><td valign="top"><a href="#info-3">info/3</a></td><td></td></tr><tr><td valign="top"><a href="#once-3">once/3</a></td><td>Exported function for scheduling a one-time message.</td></tr><tr><td valign="top"><a href="#once_executed_test-0">once_executed_test/0*</a></td><td>This test verifies that a one-time task can be scheduled and executed.</td></tr><tr><td valign="top"><a href="#once_worker-3">once_worker/3*</a></td><td>Internal function for scheduling a one-time message.</td></tr><tr><td valign="top"><a href="#parse_time-1">parse_time/1*</a></td><td>Parse a time string into milliseconds.</td></tr><tr><td valign="top"><a href="#stop-3">stop/3</a></td><td>Exported function for stopping a scheduled task.</td></tr><tr><td valign="top"><a href="#stop_every_test-0">stop_every_test/0*</a></td><td>This test verifies that a recurring task can be stopped by
calling the stop function with the task ID.</td></tr><tr><td valign="top"><a href="#stop_once_test-0">stop_once_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_worker-0">test_worker/0*</a></td><td>This is a helper function that is used to test the cron device.</td></tr><tr><td valign="top"><a href="#test_worker-1">test_worker/1*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="every-3"></a>

### every/3 ###

`every(Msg1, Msg2, Opts) -> any()`

Exported function for scheduling a recurring message.

<a name="every_worker_loop-4"></a>

### every_worker_loop/4 * ###

`every_worker_loop(CronPath, Req, Opts, IntervalMillis) -> any()`

<a name="every_worker_loop_test-0"></a>

### every_worker_loop_test/0 * ###

`every_worker_loop_test() -> any()`

This test verifies that a recurring task can be scheduled and executed.

<a name="info-1"></a>

### info/1 ###

`info(X1) -> any()`

Exported function for getting device info.

<a name="info-3"></a>

### info/3 ###

`info(Msg1, Msg2, Opts) -> any()`

<a name="once-3"></a>

### once/3 ###

`once(Msg1, Msg2, Opts) -> any()`

Exported function for scheduling a one-time message.

<a name="once_executed_test-0"></a>

### once_executed_test/0 * ###

`once_executed_test() -> any()`

This test verifies that a one-time task can be scheduled and executed.

<a name="once_worker-3"></a>

### once_worker/3 * ###

`once_worker(Path, Req, Opts) -> any()`

Internal function for scheduling a one-time message.

<a name="parse_time-1"></a>

### parse_time/1 * ###

`parse_time(BinString) -> any()`

Parse a time string into milliseconds.

<a name="stop-3"></a>

### stop/3 ###

`stop(Msg1, Msg2, Opts) -> any()`

Exported function for stopping a scheduled task.

<a name="stop_every_test-0"></a>

### stop_every_test/0 * ###

`stop_every_test() -> any()`

This test verifies that a recurring task can be stopped by
calling the stop function with the task ID.

<a name="stop_once_test-0"></a>

### stop_once_test/0 * ###

`stop_once_test() -> any()`

<a name="test_worker-0"></a>

### test_worker/0 * ###

`test_worker() -> any()`

This is a helper function that is used to test the cron device.
It is used to increment a counter and update the state of the worker.

<a name="test_worker-1"></a>

### test_worker/1 * ###

`test_worker(State) -> any()`


--- END OF FILE: docs/resources/source-code/dev_cron.md ---

--- START OF FILE: docs/resources/source-code/dev_cu.md ---
# [Module dev_cu.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_cu.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#execute-2">execute/2</a></td><td></td></tr><tr><td valign="top"><a href="#push-2">push/2</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="execute-2"></a>

### execute/2 ###

`execute(CarrierMsg, S) -> any()`

<a name="push-2"></a>

### push/2 ###

`push(Msg, S) -> any()`


--- END OF FILE: docs/resources/source-code/dev_cu.md ---

--- START OF FILE: docs/resources/source-code/dev_dedup.md ---
# [Module dev_dedup.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_dedup.erl)




A device that deduplicates messages send to a process.

<a name="description"></a>

## Description ##
Only runs on the first pass of the `compute` key call if executed
in a stack. Currently the device stores its list of already seen
items in memory, but at some point it will likely make sense to
drop them in the cache.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#dedup_test-0">dedup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#dedup_with_multipass_test-0">dedup_with_multipass_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#handle-4">handle/4*</a></td><td>Forward the keys function to the message device, handle all others
with deduplication.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="dedup_test-0"></a>

### dedup_test/0 * ###

`dedup_test() -> any()`

<a name="dedup_with_multipass_test-0"></a>

### dedup_with_multipass_test/0 * ###

`dedup_with_multipass_test() -> any()`

<a name="handle-4"></a>

### handle/4 * ###

`handle(Key, M1, M2, Opts) -> any()`

Forward the keys function to the message device, handle all others
with deduplication. We only act on the first pass.

<a name="info-1"></a>

### info/1 ###

`info(M1) -> any()`


--- END OF FILE: docs/resources/source-code/dev_dedup.md ---

--- START OF FILE: docs/resources/source-code/dev_delegated_compute.md ---
# [Module dev_delegated_compute.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_delegated_compute.erl)




Simple wrapper module that enables compute on remote machines,
implementing the JSON-Iface.

<a name="description"></a>

## Description ##
This can be used either as a standalone, to
bring trusted results into the local node, or as the `Execution-Device` of
an AO process.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td></td></tr><tr><td valign="top"><a href="#do_compute-3">do_compute/3*</a></td><td>Execute computation on a remote machine via relay and the JSON-Iface.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Initialize or normalize the compute-lite device.</td></tr><tr><td valign="top"><a href="#normalize-3">normalize/3</a></td><td></td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="compute-3"></a>

### compute/3 ###

`compute(Msg1, Msg2, Opts) -> any()`

<a name="do_compute-3"></a>

### do_compute/3 * ###

`do_compute(ProcID, Msg2, Opts) -> any()`

Execute computation on a remote machine via relay and the JSON-Iface.

<a name="init-3"></a>

### init/3 ###

`init(Msg1, Msg2, Opts) -> any()`

Initialize or normalize the compute-lite device. For now, we don't
need to do anything special here.

<a name="normalize-3"></a>

### normalize/3 ###

`normalize(Msg1, Msg2, Opts) -> any()`

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(Msg1, Msg2, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_delegated_compute.md ---

--- START OF FILE: docs/resources/source-code/dev_faff.md ---
# [Module dev_faff.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_faff.erl)




A module that implements a 'friends and family' pricing policy.

<a name="description"></a>

## Description ##

It will allow users to process requests only if their addresses are
in the allow-list for the node.

Fundamentally against the spirit of permissionlessness, but it is useful if
you are running a node for your own purposes and would not like to allow
others to make use of it -- even for a fee. It also serves as a useful
example of how to implement a custom pricing policy, as it implements stubs
for both the pricing and ledger P4 APIs.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#debit-3">debit/3</a></td><td>Debit the user's account if the request is allowed.</td></tr><tr><td valign="top"><a href="#estimate-3">estimate/3</a></td><td>Decide whether or not to service a request from a given address.</td></tr><tr><td valign="top"><a href="#is_admissible-2">is_admissible/2*</a></td><td>Check whether all of the signers of the request are in the allow-list.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="debit-3"></a>

### debit/3 ###

`debit(X1, Req, NodeMsg) -> any()`

Debit the user's account if the request is allowed.

<a name="estimate-3"></a>

### estimate/3 ###

`estimate(X1, Msg, NodeMsg) -> any()`

Decide whether or not to service a request from a given address.

<a name="is_admissible-2"></a>

### is_admissible/2 * ###

`is_admissible(Msg, NodeMsg) -> any()`

Check whether all of the signers of the request are in the allow-list.


--- END OF FILE: docs/resources/source-code/dev_faff.md ---

--- START OF FILE: docs/resources/source-code/dev_genesis_wasm.md ---
# [Module dev_genesis_wasm.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_genesis_wasm.erl)




A device that mimics an environment suitable for `legacynet` AO
processes, using HyperBEAM infrastructure.

<a name="description"></a>

## Description ##
This allows existing `legacynet`
AO process definitions to be used in HyperBEAM.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#collect_events-1">collect_events/1*</a></td><td>Collect events from the port and log them.</td></tr><tr><td valign="top"><a href="#collect_events-2">collect_events/2*</a></td><td></td></tr><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>All the <code>delegated-compute@1.0</code> device to execute the request.</td></tr><tr><td valign="top"><a href="#ensure_started-1">ensure_started/1*</a></td><td>Ensure the local <code>genesis-wasm@1.0</code> is live.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Initialize the device.</td></tr><tr><td valign="top"><a href="#is_genesis_wasm_server_running-1">is_genesis_wasm_server_running/1*</a></td><td>Check if the genesis-wasm server is running, using the cached process ID
if available.</td></tr><tr><td valign="top"><a href="#log_server_events-1">log_server_events/1*</a></td><td>Log lines of output from the genesis-wasm server.</td></tr><tr><td valign="top"><a href="#normalize-3">normalize/3</a></td><td>Normalize the device.</td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td>Snapshot the device.</td></tr><tr><td valign="top"><a href="#status-1">status/1*</a></td><td>Check if the genesis-wasm server is running by requesting its status
endpoint.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="collect_events-1"></a>

### collect_events/1 * ###

`collect_events(Port) -> any()`

Collect events from the port and log them.

<a name="collect_events-2"></a>

### collect_events/2 * ###

`collect_events(Port, Acc) -> any()`

<a name="compute-3"></a>

### compute/3 ###

`compute(Msg, Msg2, Opts) -> any()`

All the `delegated-compute@1.0` device to execute the request. We then apply
the `patch@1.0` device, applying any state patches that the AO process may have
requested.

<a name="ensure_started-1"></a>

### ensure_started/1 * ###

`ensure_started(Opts) -> any()`

Ensure the local `genesis-wasm@1.0` is live. If it not, start it.

<a name="init-3"></a>

### init/3 ###

`init(Msg, Msg2, Opts) -> any()`

Initialize the device.

<a name="is_genesis_wasm_server_running-1"></a>

### is_genesis_wasm_server_running/1 * ###

`is_genesis_wasm_server_running(Opts) -> any()`

Check if the genesis-wasm server is running, using the cached process ID
if available.

<a name="log_server_events-1"></a>

### log_server_events/1 * ###

`log_server_events(Bin) -> any()`

Log lines of output from the genesis-wasm server.

<a name="normalize-3"></a>

### normalize/3 ###

`normalize(Msg, Msg2, Opts) -> any()`

Normalize the device.

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(Msg, Msg2, Opts) -> any()`

Snapshot the device.

<a name="status-1"></a>

### status/1 * ###

`status(Opts) -> any()`

Check if the genesis-wasm server is running by requesting its status
endpoint.


--- END OF FILE: docs/resources/source-code/dev_genesis_wasm.md ---

--- START OF FILE: docs/resources/source-code/dev_green_zone.md ---
# [Module dev_green_zone.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_green_zone.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_trusted_node-4">add_trusted_node/4*</a></td><td></td></tr><tr><td valign="top"><a href="#become-3">become/3</a></td><td></td></tr><tr><td valign="top"><a href="#calculate_node_message-3">calculate_node_message/3*</a></td><td></td></tr><tr><td valign="top"><a href="#decrypt_zone_key-2">decrypt_zone_key/2*</a></td><td></td></tr><tr><td valign="top"><a href="#default_zone_required_opts-1">default_zone_required_opts/1*</a></td><td></td></tr><tr><td valign="top"><a href="#encrypt_payload-2">encrypt_payload/2*</a></td><td></td></tr><tr><td valign="top"><a href="#finalize_become-5">finalize_become/5*</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td></td></tr><tr><td valign="top"><a href="#join-3">join/3</a></td><td></td></tr><tr><td valign="top"><a href="#join_peer-5">join_peer/5*</a></td><td></td></tr><tr><td valign="top"><a href="#key-3">key/3</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_set_zone_opts-4">maybe_set_zone_opts/4*</a></td><td></td></tr><tr><td valign="top"><a href="#rsa_wallet_integration_test-0">rsa_wallet_integration_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#try_mount_encrypted_volume-2">try_mount_encrypted_volume/2*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_join-3">validate_join/3*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_peer_opts-2">validate_peer_opts/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_trusted_node-4"></a>

### add_trusted_node/4 * ###

<pre><code>
add_trusted_node(NodeAddr::binary(), Report::map(), RequesterPubKey::term(), Opts::map()) -&gt; ok
</code></pre>
<br />

<a name="become-3"></a>

### become/3 ###

<pre><code>
become(M1::term(), M2::term(), Opts::map()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="calculate_node_message-3"></a>

### calculate_node_message/3 * ###

`calculate_node_message(RequiredOpts, Req, List) -> any()`

<a name="decrypt_zone_key-2"></a>

### decrypt_zone_key/2 * ###

<pre><code>
decrypt_zone_key(EncZoneKey::binary(), Opts::map()) -&gt; {ok, binary()} | {error, binary()}
</code></pre>
<br />

<a name="default_zone_required_opts-1"></a>

### default_zone_required_opts/1 * ###

`default_zone_required_opts(Opts) -> any()`

<a name="encrypt_payload-2"></a>

### encrypt_payload/2 * ###

<pre><code>
encrypt_payload(AESKey::binary(), RequesterPubKey::term()) -&gt; binary()
</code></pre>
<br />

<a name="finalize_become-5"></a>

### finalize_become/5 * ###

`finalize_become(KeyResp, NodeLocation, NodeID, GreenZoneAES, Opts) -> any()`

<a name="init-3"></a>

### init/3 ###

<pre><code>
init(M1::term(), M2::term(), Opts::map()) -&gt; {ok, binary()}
</code></pre>
<br />

<a name="join-3"></a>

### join/3 ###

<pre><code>
join(M1::term(), M2::term(), Opts::map()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="join_peer-5"></a>

### join_peer/5 * ###

<pre><code>
join_peer(PeerLocation::binary(), PeerID::binary(), M1::term(), M2::term(), Opts::map()) -&gt; {ok, map()} | {error, map()}
</code></pre>
<br />

<a name="key-3"></a>

### key/3 ###

<pre><code>
key(M1::term(), M2::term(), Opts::map()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="maybe_set_zone_opts-4"></a>

### maybe_set_zone_opts/4 * ###

`maybe_set_zone_opts(PeerLocation, PeerID, Req, InitOpts) -> any()`

<a name="rsa_wallet_integration_test-0"></a>

### rsa_wallet_integration_test/0 * ###

`rsa_wallet_integration_test() -> any()`

<a name="try_mount_encrypted_volume-2"></a>

### try_mount_encrypted_volume/2 * ###

`try_mount_encrypted_volume(AESKey, Opts) -> any()`

<a name="validate_join-3"></a>

### validate_join/3 * ###

<pre><code>
validate_join(M1::term(), Req::map(), Opts::map()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="validate_peer_opts-2"></a>

### validate_peer_opts/2 * ###

`validate_peer_opts(Req, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_green_zone.md ---

--- START OF FILE: docs/resources/source-code/dev_hyperbuddy.md ---
# [Module dev_hyperbuddy.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_hyperbuddy.erl)




A device that renders a REPL-like interface for AO-Core via HTML.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#format-3">format/3</a></td><td>Employ HyperBEAM's internal pretty printer to format a message.</td></tr><tr><td valign="top"><a href="#info-0">info/0</a></td><td>Export an explicit list of files via http.</td></tr><tr><td valign="top"><a href="#metrics-3">metrics/3</a></td><td>The main HTML page for the REPL device.</td></tr><tr><td valign="top"><a href="#return_file-1">return_file/1*</a></td><td>Read a file from disk and serve it as a static HTML page.</td></tr><tr><td valign="top"><a href="#serve-4">serve/4*</a></td><td>Serve a file from the priv directory.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="format-3"></a>

### format/3 ###

`format(Base, X2, X3) -> any()`

Employ HyperBEAM's internal pretty printer to format a message.

<a name="info-0"></a>

### info/0 ###

`info() -> any()`

Export an explicit list of files via http.

<a name="metrics-3"></a>

### metrics/3 ###

`metrics(X1, Req, Opts) -> any()`

The main HTML page for the REPL device.

<a name="return_file-1"></a>

### return_file/1 * ###

`return_file(Name) -> any()`

Read a file from disk and serve it as a static HTML page.

<a name="serve-4"></a>

### serve/4 * ###

`serve(Key, M1, M2, Opts) -> any()`

Serve a file from the priv directory. Only serves files that are explicitly
listed in the `routes` field of the `info/0` return value.


--- END OF FILE: docs/resources/source-code/dev_hyperbuddy.md ---

--- START OF FILE: docs/resources/source-code/dev_json_iface.md ---
# [Module dev_json_iface.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_json_iface.erl)




A device that provides a way for WASM execution to interact with
the HyperBEAM (and AO) systems, using JSON as a shared data representation.

<a name="description"></a>

## Description ##

The interface is easy to use. It works as follows:

1. The device is given a message that contains a process definition, WASM
environment, and a message that contains the data to be processed,
including the image to be used in part of `execute{pass=1}`.
2. The device is called with `execute{pass=2}`, which reads the result of
the process execution from the WASM environment and adds it to the
message.

The device has the following requirements and interface:

```

       M1/Computed when /Pass == 1 ->
           Assumes:
               M1/priv/wasm/instance
               M1/Process
               M2/Message
               M2/Assignment/Block-Height
           Generates:
               /wasm/handler
               /wasm/params
           Side-effects:
               Writes the process and message as JSON representations into the
               WASM environment.
       M1/Computed when M2/Pass == 2 ->
           Assumes:
               M1/priv/wasm/instance
               M2/Results
               M2/Process
           Generates:
               /Results/Outbox
               /Results/Data
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#aos_stack_benchmark_test_-0">aos_stack_benchmark_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_aos_call_test_-0">basic_aos_call_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>On first pass prepare the call, on second pass get the results.</td></tr><tr><td valign="top"><a href="#denormalize_message-1">denormalize_message/1*</a></td><td>Normalize a message for AOS-compatibility.</td></tr><tr><td valign="top"><a href="#env_read-3">env_read/3*</a></td><td>Read the results out of the execution environment.</td></tr><tr><td valign="top"><a href="#env_write-5">env_write/5*</a></td><td>Write the message and process into the execution environment.</td></tr><tr><td valign="top"><a href="#generate_aos_msg-2">generate_aos_msg/2</a></td><td></td></tr><tr><td valign="top"><a href="#generate_stack-1">generate_stack/1</a></td><td></td></tr><tr><td valign="top"><a href="#generate_stack-2">generate_stack/2</a></td><td></td></tr><tr><td valign="top"><a href="#header_case_string-1">header_case_string/1*</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Initialize the device.</td></tr><tr><td valign="top"><a href="#json_to_message-2">json_to_message/2</a></td><td>Translates a compute result -- either from a WASM execution using the
JSON-Iface, or from a <code>Legacy</code> CU -- and transforms it into a result message.</td></tr><tr><td valign="top"><a href="#maybe_list_to_binary-1">maybe_list_to_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#message_to_json_struct-1">message_to_json_struct/1</a></td><td></td></tr><tr><td valign="top"><a href="#message_to_json_struct-2">message_to_json_struct/2*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_results-1">normalize_results/1*</a></td><td>Normalize the results of an evaluation.</td></tr><tr><td valign="top"><a href="#postprocess_outbox-3">postprocess_outbox/3*</a></td><td>Post-process messages in the outbox to add the correct <code>from-process</code>
and <code>from-image</code> tags.</td></tr><tr><td valign="top"><a href="#prep_call-3">prep_call/3*</a></td><td>Prepare the WASM environment for execution by writing the process string and
the message as JSON representations into the WASM environment.</td></tr><tr><td valign="top"><a href="#prepare_header_case_tags-1">prepare_header_case_tags/1*</a></td><td>Convert a message without an <code>original-tags</code> field into a list of
key-value pairs, with the keys in HTTP header-case.</td></tr><tr><td valign="top"><a href="#prepare_tags-1">prepare_tags/1*</a></td><td>Prepare the tags of a message as a key-value list, for use in the
construction of the JSON-Struct message.</td></tr><tr><td valign="top"><a href="#preprocess_results-2">preprocess_results/2*</a></td><td>After the process returns messages from an evaluation, the
signing node needs to add some tags to each message and spawn such that
the target process knows these messages are created by a process.</td></tr><tr><td valign="top"><a href="#results-3">results/3*</a></td><td>Read the computed results out of the WASM environment, assuming that
the environment has been set up by <code>prep_call/3</code> and that the WASM executor
has been called with <code>computed{pass=1}</code>.</td></tr><tr><td valign="top"><a href="#safe_to_id-1">safe_to_id/1*</a></td><td></td></tr><tr><td valign="top"><a href="#tags_to_map-1">tags_to_map/1*</a></td><td>Convert a message with tags into a map of their key-value pairs.</td></tr><tr><td valign="top"><a href="#test_init-0">test_init/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="aos_stack_benchmark_test_-0"></a>

### aos_stack_benchmark_test_/0 * ###

`aos_stack_benchmark_test_() -> any()`

<a name="basic_aos_call_test_-0"></a>

### basic_aos_call_test_/0 * ###

`basic_aos_call_test_() -> any()`

<a name="compute-3"></a>

### compute/3 ###

`compute(M1, M2, Opts) -> any()`

On first pass prepare the call, on second pass get the results.

<a name="denormalize_message-1"></a>

### denormalize_message/1 * ###

`denormalize_message(Message) -> any()`

Normalize a message for AOS-compatibility.

<a name="env_read-3"></a>

### env_read/3 * ###

`env_read(M1, M2, Opts) -> any()`

Read the results out of the execution environment.

<a name="env_write-5"></a>

### env_write/5 * ###

`env_write(ProcessStr, MsgStr, Base, Req, Opts) -> any()`

Write the message and process into the execution environment.

<a name="generate_aos_msg-2"></a>

### generate_aos_msg/2 ###

`generate_aos_msg(ProcID, Code) -> any()`

<a name="generate_stack-1"></a>

### generate_stack/1 ###

`generate_stack(File) -> any()`

<a name="generate_stack-2"></a>

### generate_stack/2 ###

`generate_stack(File, Mode) -> any()`

<a name="header_case_string-1"></a>

### header_case_string/1 * ###

`header_case_string(Key) -> any()`

<a name="init-3"></a>

### init/3 ###

`init(M1, M2, Opts) -> any()`

Initialize the device.

<a name="json_to_message-2"></a>

### json_to_message/2 ###

`json_to_message(JSON, Opts) -> any()`

Translates a compute result -- either from a WASM execution using the
JSON-Iface, or from a `Legacy` CU -- and transforms it into a result message.

<a name="maybe_list_to_binary-1"></a>

### maybe_list_to_binary/1 * ###

`maybe_list_to_binary(List) -> any()`

<a name="message_to_json_struct-1"></a>

### message_to_json_struct/1 ###

`message_to_json_struct(RawMsg) -> any()`

<a name="message_to_json_struct-2"></a>

### message_to_json_struct/2 * ###

`message_to_json_struct(RawMsg, Features) -> any()`

<a name="normalize_results-1"></a>

### normalize_results/1 * ###

`normalize_results(Msg) -> any()`

Normalize the results of an evaluation.

<a name="postprocess_outbox-3"></a>

### postprocess_outbox/3 * ###

`postprocess_outbox(Msg, Proc, Opts) -> any()`

Post-process messages in the outbox to add the correct `from-process`
and `from-image` tags.

<a name="prep_call-3"></a>

### prep_call/3 * ###

`prep_call(M1, M2, Opts) -> any()`

Prepare the WASM environment for execution by writing the process string and
the message as JSON representations into the WASM environment.

<a name="prepare_header_case_tags-1"></a>

### prepare_header_case_tags/1 * ###

`prepare_header_case_tags(TABM) -> any()`

Convert a message without an `original-tags` field into a list of
key-value pairs, with the keys in HTTP header-case.

<a name="prepare_tags-1"></a>

### prepare_tags/1 * ###

`prepare_tags(Msg) -> any()`

Prepare the tags of a message as a key-value list, for use in the
construction of the JSON-Struct message.

<a name="preprocess_results-2"></a>

### preprocess_results/2 * ###

`preprocess_results(Msg, Opts) -> any()`

After the process returns messages from an evaluation, the
signing node needs to add some tags to each message and spawn such that
the target process knows these messages are created by a process.

<a name="results-3"></a>

### results/3 * ###

`results(M1, M2, Opts) -> any()`

Read the computed results out of the WASM environment, assuming that
the environment has been set up by `prep_call/3` and that the WASM executor
has been called with `computed{pass=1}`.

<a name="safe_to_id-1"></a>

### safe_to_id/1 * ###

`safe_to_id(ID) -> any()`

<a name="tags_to_map-1"></a>

### tags_to_map/1 * ###

`tags_to_map(Msg) -> any()`

Convert a message with tags into a map of their key-value pairs.

<a name="test_init-0"></a>

### test_init/0 * ###

`test_init() -> any()`


--- END OF FILE: docs/resources/source-code/dev_json_iface.md ---

--- START OF FILE: docs/resources/source-code/dev_local_name.md ---
# [Module dev_local_name.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_local_name.erl)




A device for registering and looking up local names.

<a name="description"></a>

## Description ##
This device uses
the node message to store a local cache of its known names, and the typical
non-volatile storage of the node message to store the names long-term.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#default_lookup-4">default_lookup/4*</a></td><td>Handle all other requests by delegating to the lookup function.</td></tr><tr><td valign="top"><a href="#direct_register-2">direct_register/2</a></td><td>Register a name without checking if the caller is an operator.</td></tr><tr><td valign="top"><a href="#find_names-1">find_names/1*</a></td><td>Returns a message containing all known names.</td></tr><tr><td valign="top"><a href="#generate_test_opts-0">generate_test_opts/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_test-0">http_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Export only the <code>lookup</code> and <code>register</code> functions.</td></tr><tr><td valign="top"><a href="#load_names-1">load_names/1*</a></td><td>Loads all known names from the cache and returns the new <code>node message</code>
with those names loaded into it.</td></tr><tr><td valign="top"><a href="#lookup-3">lookup/3</a></td><td>Takes a <code>key</code> argument and returns the value of the name, if it exists.</td></tr><tr><td valign="top"><a href="#lookup_opts_name_test-0">lookup_opts_name_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#no_names_test-0">no_names_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#register-3">register/3</a></td><td>Takes a <code>key</code> and <code>value</code> argument and registers the name.</td></tr><tr><td valign="top"><a href="#register_test-0">register_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#unauthorized_test-0">unauthorized_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#update_names-2">update_names/2*</a></td><td>Updates the node message with the new names.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="default_lookup-4"></a>

### default_lookup/4 * ###

`default_lookup(Key, X2, Req, Opts) -> any()`

Handle all other requests by delegating to the lookup function.

<a name="direct_register-2"></a>

### direct_register/2 ###

`direct_register(Req, Opts) -> any()`

Register a name without checking if the caller is an operator. Exported
for use by other devices, but not publicly available.

<a name="find_names-1"></a>

### find_names/1 * ###

`find_names(Opts) -> any()`

Returns a message containing all known names.

<a name="generate_test_opts-0"></a>

### generate_test_opts/0 * ###

`generate_test_opts() -> any()`

<a name="http_test-0"></a>

### http_test/0 * ###

`http_test() -> any()`

<a name="info-1"></a>

### info/1 ###

`info(Opts) -> any()`

Export only the `lookup` and `register` functions.

<a name="load_names-1"></a>

### load_names/1 * ###

`load_names(Opts) -> any()`

Loads all known names from the cache and returns the new `node message`
with those names loaded into it.

<a name="lookup-3"></a>

### lookup/3 ###

`lookup(X1, Req, Opts) -> any()`

Takes a `key` argument and returns the value of the name, if it exists.

<a name="lookup_opts_name_test-0"></a>

### lookup_opts_name_test/0 * ###

`lookup_opts_name_test() -> any()`

<a name="no_names_test-0"></a>

### no_names_test/0 * ###

`no_names_test() -> any()`

<a name="register-3"></a>

### register/3 ###

`register(X1, Req, Opts) -> any()`

Takes a `key` and `value` argument and registers the name. The caller
must be the node operator in order to register a name.

<a name="register_test-0"></a>

### register_test/0 * ###

`register_test() -> any()`

<a name="unauthorized_test-0"></a>

### unauthorized_test/0 * ###

`unauthorized_test() -> any()`

<a name="update_names-2"></a>

### update_names/2 * ###

`update_names(LocalNames, Opts) -> any()`

Updates the node message with the new names. Further HTTP requests will
use this new message, removing the need to look up the names from non-volatile
storage.


--- END OF FILE: docs/resources/source-code/dev_local_name.md ---

--- START OF FILE: docs/resources/source-code/dev_lookup.md ---
# [Module dev_lookup.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_lookup.erl)




A device that looks up an ID from a local store and returns it, honoring
the `accept` key to return the correct format.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#aos2_message_lookup_test-0">aos2_message_lookup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#binary_lookup_test-0">binary_lookup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_lookup_test-0">http_lookup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#message_lookup_test-0">message_lookup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#read-3">read/3</a></td><td>Fetch a resource from the cache using "target" ID extracted from the message.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="aos2_message_lookup_test-0"></a>

### aos2_message_lookup_test/0 * ###

`aos2_message_lookup_test() -> any()`

<a name="binary_lookup_test-0"></a>

### binary_lookup_test/0 * ###

`binary_lookup_test() -> any()`

<a name="http_lookup_test-0"></a>

### http_lookup_test/0 * ###

`http_lookup_test() -> any()`

<a name="message_lookup_test-0"></a>

### message_lookup_test/0 * ###

`message_lookup_test() -> any()`

<a name="read-3"></a>

### read/3 ###

`read(M1, M2, Opts) -> any()`

Fetch a resource from the cache using "target" ID extracted from the message


--- END OF FILE: docs/resources/source-code/dev_lookup.md ---

--- START OF FILE: docs/resources/source-code/dev_lua_lib.md ---
# [Module dev_lua_lib.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_lua_lib.erl)




A module for providing AO library functions to the Lua environment.

<a name="description"></a>

## Description ##

This module contains the implementation of the functions, each by the name
that should be used in the `ao` table in the Lua environment. Every export
is imported into the Lua environment.

Each function adheres closely to the Luerl calling convention, adding the
appropriate node message as a third argument:

fun(Args, State, NodeMsg) -> {ResultTerms, NewState}

As Lua allows for multiple return values, each function returns a list of
terms to grant to the caller. Matching the tuple convention used by AO-Core,
the first term is typically the status, and the second term is the result.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#convert_as-1">convert_as/1*</a></td><td>Converts any <code>as</code> terms from Lua to their HyperBEAM equivalents.</td></tr><tr><td valign="top"><a href="#event-3">event/3</a></td><td>Allows Lua scripts to signal events using the HyperBEAM hosts internal
event system.</td></tr><tr><td valign="top"><a href="#install-3">install/3</a></td><td>Install the library into the given Lua environment.</td></tr><tr><td valign="top"><a href="#resolve-3">resolve/3</a></td><td>A wrapper function for performing AO-Core resolutions.</td></tr><tr><td valign="top"><a href="#return-2">return/2*</a></td><td>Helper function for returning a result from a Lua function.</td></tr><tr><td valign="top"><a href="#set-3">set/3</a></td><td>Wrapper for <code>hb_ao</code>'s <code>set</code> functionality.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="convert_as-1"></a>

### convert_as/1 * ###

`convert_as(Other) -> any()`

Converts any `as` terms from Lua to their HyperBEAM equivalents.

<a name="event-3"></a>

### event/3 ###

`event(X1, ExecState, Opts) -> any()`

Allows Lua scripts to signal events using the HyperBEAM hosts internal
event system.

<a name="install-3"></a>

### install/3 ###

`install(Base, State, Opts) -> any()`

Install the library into the given Lua environment.

<a name="resolve-3"></a>

### resolve/3 ###

`resolve(Msgs, ExecState, ExecOpts) -> any()`

A wrapper function for performing AO-Core resolutions. Offers both the
single-message (using `hb_singleton:from/1` to parse) and multiple-message
(using `hb_ao:resolve_many/2`) variants.

<a name="return-2"></a>

### return/2 * ###

`return(Result, ExecState) -> any()`

Helper function for returning a result from a Lua function.

<a name="set-3"></a>

### set/3 ###

`set(X1, ExecState, ExecOpts) -> any()`

Wrapper for `hb_ao`'s `set` functionality.


--- END OF FILE: docs/resources/source-code/dev_lua_lib.md ---

--- START OF FILE: docs/resources/source-code/dev_lua_test.md ---
# [Module dev_lua_test.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_lua_test.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#exec_test-2">exec_test/2*</a></td><td>Generate an EUnit test for a given function.</td></tr><tr><td valign="top"><a href="#exec_test_-0">exec_test_/0*</a></td><td>Main entrypoint for Lua tests.</td></tr><tr><td valign="top"><a href="#new_state-1">new_state/1*</a></td><td>Create a new Lua environment for a given script.</td></tr><tr><td valign="top"><a href="#parse_spec-1">parse_spec/1</a></td><td>Parse a string representation of test descriptions received from the
command line via the <code>LUA_TESTS</code> environment variable.</td></tr><tr><td valign="top"><a href="#suite-2">suite/2*</a></td><td>Generate an EUnit test suite for a given Lua script.</td></tr><tr><td valign="top"><a href="#terminates_with-2">terminates_with/2*</a></td><td>Check if a string terminates with a given suffix.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="exec_test-2"></a>

### exec_test/2 * ###

`exec_test(State, Function) -> any()`

Generate an EUnit test for a given function.

<a name="exec_test_-0"></a>

### exec_test_/0 * ###

`exec_test_() -> any()`

Main entrypoint for Lua tests.

<a name="new_state-1"></a>

### new_state/1 * ###

`new_state(File) -> any()`

Create a new Lua environment for a given script.

<a name="parse_spec-1"></a>

### parse_spec/1 ###

`parse_spec(Str) -> any()`

Parse a string representation of test descriptions received from the
command line via the `LUA_TESTS` environment variable.

Supported syntax in loose BNF/RegEx:

Definitions := (ModDef,)+
ModDef      := ModName(TestDefs)?
ModName     := ModuleInLUA_SCRIPTS|(FileName[.lua])?
TestDefs    := (:TestDef)+
TestDef     := TestName

File names ending in `.lua` are assumed to be relative paths from the current
working directory. Module names lacking the `.lua` extension are assumed to
be modules found in the `LUA_SCRIPTS` environment variable (defaulting to
`scripts/`).

For example, to run a single test one could call the following:

LUA_TESTS=~/src/LuaScripts/test.yourTest rebar3 lua-tests

To specify that one would like to run all of the tests in the
`scripts/test.lua` file and two tests from the `scripts/test2.lua` file, the
user could provide the following test definition:

LUA_TESTS="test,scripts/test2.userTest1|userTest2" rebar3 lua-tests

<a name="suite-2"></a>

### suite/2 * ###

`suite(File, Funcs) -> any()`

Generate an EUnit test suite for a given Lua script. If the `Funcs` is
the atom `tests` we find all of the global functions in the script, then
filter for those ending in `_test` in a similar fashion to Eunit.

<a name="terminates_with-2"></a>

### terminates_with/2 * ###

`terminates_with(String, Suffix) -> any()`

Check if a string terminates with a given suffix.


--- END OF FILE: docs/resources/source-code/dev_lua_test.md ---

--- START OF FILE: docs/resources/source-code/dev_lua.md ---
# [Module dev_lua.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_lua.erl)




A device that calls a Lua script upon a request and returns the result.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#ao_core_resolution_from_lua_test-0">ao_core_resolution_from_lua_test/0*</a></td><td>Run an AO-Core resolution from the Lua environment.</td></tr><tr><td valign="top"><a href="#ao_core_sandbox_test-0">ao_core_sandbox_test/0*</a></td><td>Run an AO-Core resolution from the Lua environment.</td></tr><tr><td valign="top"><a href="#aos_authority_not_trusted_test-0">aos_authority_not_trusted_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#aos_process_benchmark_test_-0">aos_process_benchmark_test_/0*</a></td><td>Benchmark the performance of Lua executions.</td></tr><tr><td valign="top"><a href="#compute-4">compute/4*</a></td><td>Call the Lua script with the given arguments.</td></tr><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decode a Lua result into a HyperBEAM <code>structured@1.0</code> message.</td></tr><tr><td valign="top"><a href="#decode_params-2">decode_params/2*</a></td><td>Decode a list of Lua references, as found in a stack trace, into a
list of Erlang terms.</td></tr><tr><td valign="top"><a href="#decode_stacktrace-2">decode_stacktrace/2*</a></td><td>Parse a Lua stack trace into a list of messages.</td></tr><tr><td valign="top"><a href="#decode_stacktrace-3">decode_stacktrace/3*</a></td><td></td></tr><tr><td valign="top"><a href="#direct_benchmark_test-0">direct_benchmark_test/0*</a></td><td>Benchmark the performance of Lua executions.</td></tr><tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Encode a HyperBEAM <code>structured@1.0</code> message into a Lua term.</td></tr><tr><td valign="top"><a href="#ensure_initialized-3">ensure_initialized/3*</a></td><td>Initialize the Lua VM if it is not already initialized.</td></tr><tr><td valign="top"><a href="#error_response_test-0">error_response_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#execute_aos_call-1">execute_aos_call/1*</a></td><td></td></tr><tr><td valign="top"><a href="#execute_aos_call-2">execute_aos_call/2*</a></td><td></td></tr><tr><td valign="top"><a href="#find_scripts-2">find_scripts/2*</a></td><td>Find the script in the base message, either by ID or by string.</td></tr><tr><td valign="top"><a href="#functions-3">functions/3</a></td><td>Return a list of all functions in the Lua environment.</td></tr><tr><td valign="top"><a href="#generate_lua_process-1">generate_lua_process/1*</a></td><td>Generate a Lua process message.</td></tr><tr><td valign="top"><a href="#generate_stack-1">generate_stack/1*</a></td><td>Generate a stack message for the Lua process.</td></tr><tr><td valign="top"><a href="#generate_test_message-1">generate_test_message/1*</a></td><td>Generate a test message for a Lua process.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>All keys that are not directly available in the base message are
resolved by calling the Lua function in the script of the same name.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Initialize the device state, loading the script into memory if it is
a reference.</td></tr><tr><td valign="top"><a href="#initialize-3">initialize/3*</a></td><td>Initialize a new Lua state with a given base message and script.</td></tr><tr><td valign="top"><a href="#invoke_aos_test-0">invoke_aos_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#invoke_non_compute_key_test-0">invoke_non_compute_key_test/0*</a></td><td>Call a non-compute key on a Lua device message and ensure that the
function of the same name in the script is called.</td></tr><tr><td valign="top"><a href="#load_scripts-2">load_scripts/2*</a></td><td>Load a list of scripts for installation into the Lua VM.</td></tr><tr><td valign="top"><a href="#load_scripts-3">load_scripts/3*</a></td><td></td></tr><tr><td valign="top"><a href="#load_scripts_by_id_test-0">load_scripts_by_id_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#lua_http_preprocessor_test-0">lua_http_preprocessor_test/0*</a></td><td>Use a Lua script as a preprocessor on the HTTP server via <code>~meta@1.0</code>.</td></tr><tr><td valign="top"><a href="#multiple_scripts_test-0">multiple_scripts_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize-3">normalize/3</a></td><td>Restore the Lua state from a snapshot, if it exists.</td></tr><tr><td valign="top"><a href="#process_response-2">process_response/2*</a></td><td>Process a response to a Luerl invocation.</td></tr><tr><td valign="top"><a href="#pure_lua_process_benchmark_test_-0">pure_lua_process_benchmark_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#pure_lua_process_test-0">pure_lua_process_test/0*</a></td><td>Call a process whose <code>execution-device</code> is set to <code>lua@5.3a</code>.</td></tr><tr><td valign="top"><a href="#sandbox-3">sandbox/3*</a></td><td>Sandbox (render inoperable) a set of Lua functions.</td></tr><tr><td valign="top"><a href="#sandboxed_failure_test-0">sandboxed_failure_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_invocation_test-0">simple_invocation_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td>Snapshot the Lua state from a live computation.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="ao_core_resolution_from_lua_test-0"></a>

### ao_core_resolution_from_lua_test/0 * ###

`ao_core_resolution_from_lua_test() -> any()`

Run an AO-Core resolution from the Lua environment.

<a name="ao_core_sandbox_test-0"></a>

### ao_core_sandbox_test/0 * ###

`ao_core_sandbox_test() -> any()`

Run an AO-Core resolution from the Lua environment.

<a name="aos_authority_not_trusted_test-0"></a>

### aos_authority_not_trusted_test/0 * ###

`aos_authority_not_trusted_test() -> any()`

<a name="aos_process_benchmark_test_-0"></a>

### aos_process_benchmark_test_/0 * ###

`aos_process_benchmark_test_() -> any()`

Benchmark the performance of Lua executions.

<a name="compute-4"></a>

### compute/4 * ###

`compute(Key, RawBase, Req, Opts) -> any()`

Call the Lua script with the given arguments.

<a name="decode-1"></a>

### decode/1 ###

`decode(EncMsg) -> any()`

Decode a Lua result into a HyperBEAM `structured@1.0` message.

<a name="decode_params-2"></a>

### decode_params/2 * ###

`decode_params(Rest, State) -> any()`

Decode a list of Lua references, as found in a stack trace, into a
list of Erlang terms.

<a name="decode_stacktrace-2"></a>

### decode_stacktrace/2 * ###

`decode_stacktrace(StackTrace, State0) -> any()`

Parse a Lua stack trace into a list of messages.

<a name="decode_stacktrace-3"></a>

### decode_stacktrace/3 * ###

`decode_stacktrace(Rest, State, Acc) -> any()`

<a name="direct_benchmark_test-0"></a>

### direct_benchmark_test/0 * ###

`direct_benchmark_test() -> any()`

Benchmark the performance of Lua executions.

<a name="encode-1"></a>

### encode/1 ###

`encode(Map) -> any()`

Encode a HyperBEAM `structured@1.0` message into a Lua term.

<a name="ensure_initialized-3"></a>

### ensure_initialized/3 * ###

`ensure_initialized(Base, Req, Opts) -> any()`

Initialize the Lua VM if it is not already initialized. Optionally takes
the script as a  Binary string. If not provided, the script will be loaded
from the base message.

<a name="error_response_test-0"></a>

### error_response_test/0 * ###

`error_response_test() -> any()`

<a name="execute_aos_call-1"></a>

### execute_aos_call/1 * ###

`execute_aos_call(Base) -> any()`

<a name="execute_aos_call-2"></a>

### execute_aos_call/2 * ###

`execute_aos_call(Base, Req) -> any()`

<a name="find_scripts-2"></a>

### find_scripts/2 * ###

`find_scripts(Base, Opts) -> any()`

Find the script in the base message, either by ID or by string.

<a name="functions-3"></a>

### functions/3 ###

`functions(Base, Req, Opts) -> any()`

Return a list of all functions in the Lua environment.

<a name="generate_lua_process-1"></a>

### generate_lua_process/1 * ###

`generate_lua_process(File) -> any()`

Generate a Lua process message.

<a name="generate_stack-1"></a>

### generate_stack/1 * ###

`generate_stack(File) -> any()`

Generate a stack message for the Lua process.

<a name="generate_test_message-1"></a>

### generate_test_message/1 * ###

`generate_test_message(Process) -> any()`

Generate a test message for a Lua process.

<a name="info-1"></a>

### info/1 ###

`info(Base) -> any()`

All keys that are not directly available in the base message are
resolved by calling the Lua function in the script of the same name.
Additionally, we exclude the `keys`, `set`, `encode` and `decode` functions
which are `message@1.0` core functions, and Lua public utility functions.

<a name="init-3"></a>

### init/3 ###

`init(Base, Req, Opts) -> any()`

Initialize the device state, loading the script into memory if it is
a reference.

<a name="initialize-3"></a>

### initialize/3 * ###

`initialize(Base, Scripts, Opts) -> any()`

Initialize a new Lua state with a given base message and script.

<a name="invoke_aos_test-0"></a>

### invoke_aos_test/0 * ###

`invoke_aos_test() -> any()`

<a name="invoke_non_compute_key_test-0"></a>

### invoke_non_compute_key_test/0 * ###

`invoke_non_compute_key_test() -> any()`

Call a non-compute key on a Lua device message and ensure that the
function of the same name in the script is called.

<a name="load_scripts-2"></a>

### load_scripts/2 * ###

`load_scripts(Scripts, Opts) -> any()`

Load a list of scripts for installation into the Lua VM.

<a name="load_scripts-3"></a>

### load_scripts/3 * ###

`load_scripts(Rest, Opts, Acc) -> any()`

<a name="load_scripts_by_id_test-0"></a>

### load_scripts_by_id_test/0 * ###

`load_scripts_by_id_test() -> any()`

<a name="lua_http_preprocessor_test-0"></a>

### lua_http_preprocessor_test/0 * ###

`lua_http_preprocessor_test() -> any()`

Use a Lua script as a preprocessor on the HTTP server via `~meta@1.0`.

<a name="multiple_scripts_test-0"></a>

### multiple_scripts_test/0 * ###

`multiple_scripts_test() -> any()`

<a name="normalize-3"></a>

### normalize/3 ###

`normalize(Base, Req, RawOpts) -> any()`

Restore the Lua state from a snapshot, if it exists.

<a name="process_response-2"></a>

### process_response/2 * ###

`process_response(X1, Priv) -> any()`

Process a response to a Luerl invocation. Returns the typical AO-Core
HyperBEAM response format.

<a name="pure_lua_process_benchmark_test_-0"></a>

### pure_lua_process_benchmark_test_/0 * ###

`pure_lua_process_benchmark_test_() -> any()`

<a name="pure_lua_process_test-0"></a>

### pure_lua_process_test/0 * ###

`pure_lua_process_test() -> any()`

Call a process whose `execution-device` is set to `lua@5.3a`.

<a name="sandbox-3"></a>

### sandbox/3 * ###

`sandbox(State, Map, Opts) -> any()`

Sandbox (render inoperable) a set of Lua functions. Each function is
referred to as if it is a path in AO-Core, with its value being what to
return to the caller. For example, 'os.exit' would be referred to as
referred to as `os/exit`. If preferred, a list rather than a map may be
provided, in which case the functions all return `sandboxed`.

<a name="sandboxed_failure_test-0"></a>

### sandboxed_failure_test/0 * ###

`sandboxed_failure_test() -> any()`

<a name="simple_invocation_test-0"></a>

### simple_invocation_test/0 * ###

`simple_invocation_test() -> any()`

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(Base, Req, Opts) -> any()`

Snapshot the Lua state from a live computation. Normalizes its `priv`
state element, then serializes the state to a binary.


--- END OF FILE: docs/resources/source-code/dev_lua.md ---

--- START OF FILE: docs/resources/source-code/dev_manifest.md ---
# [Module dev_manifest.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_manifest.erl)




An Arweave path manifest resolution device.

<a name="description"></a>

## Description ##
Follows the v1 schema:
https://specs.ar.io/?tx=lXLd0OPwo-dJLB_Amz5jgIeDhiOkjXuM3-r0H_aiNj0<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#info-0">info/0</a></td><td>Use the <code>route/4</code> function as the handler for all requests, aside
from <code>keys</code> and <code>set</code>, which are handled by the default resolver.</td></tr><tr><td valign="top"><a href="#manifest-3">manifest/3*</a></td><td>Find and deserialize a manifest from the given base.</td></tr><tr><td valign="top"><a href="#route-4">route/4*</a></td><td>Route a request to the associated data via its manifest.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="info-0"></a>

### info/0 ###

`info() -> any()`

Use the `route/4` function as the handler for all requests, aside
from `keys` and `set`, which are handled by the default resolver.

<a name="manifest-3"></a>

### manifest/3 * ###

`manifest(Base, Req, Opts) -> any()`

Find and deserialize a manifest from the given base.

<a name="route-4"></a>

### route/4 * ###

`route(Key, M1, M2, Opts) -> any()`

Route a request to the associated data via its manifest.


--- END OF FILE: docs/resources/source-code/dev_manifest.md ---

--- START OF FILE: docs/resources/source-code/dev_message.md ---
# [Module dev_message.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_message.erl)




The identity device: For non-reserved keys, it simply returns a key
from the message as it is found in the message's underlying Erlang map.

<a name="description"></a>

## Description ##
Private keys (`priv[.*]`) are not included.
Reserved keys are: `id`, `commitments`, `committers`, `keys`, `path`,
`set`, `remove`, `get`, and `verify`. Their function comments describe the
behaviour of the device when these keys are set.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#calculate_ids-3">calculate_ids/3*</a></td><td></td></tr><tr><td valign="top"><a href="#cannot_get_private_keys_test-0">cannot_get_private_keys_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#case_insensitive_get-2">case_insensitive_get/2*</a></td><td>Key matching should be case insensitive, following RFC-9110, so we
implement a case-insensitive key lookup rather than delegating to
<code>maps:get/2</code>.</td></tr><tr><td valign="top"><a href="#case_insensitive_get_test-0">case_insensitive_get_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td>Commit to a message, using the <code>commitment-device</code> key to specify the
device that should be used to commit to the message.</td></tr><tr><td valign="top"><a href="#commitment_ids_from_committers-2">commitment_ids_from_committers/2*</a></td><td>Returns a list of commitment IDs in a commitments map that are relevant
for a list of given committer addresses.</td></tr><tr><td valign="top"><a href="#commitment_ids_from_request-3">commitment_ids_from_request/3*</a></td><td>Implements a standardized form of specifying commitment IDs for a
message request.</td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td>Return the list of committed keys from a message.</td></tr><tr><td valign="top"><a href="#committers-1">committers/1</a></td><td>Return the committers of a message that are present in the given request.</td></tr><tr><td valign="top"><a href="#committers-2">committers/2</a></td><td></td></tr><tr><td valign="top"><a href="#committers-3">committers/3</a></td><td></td></tr><tr><td valign="top"><a href="#exec_for_commitment-5">exec_for_commitment/5*</a></td><td>Execute a function for a single commitment in the context of its
parent message.</td></tr><tr><td valign="top"><a href="#get-2">get/2</a></td><td>Return the value associated with the key as it exists in the message's
underlying Erlang map.</td></tr><tr><td valign="top"><a href="#get-3">get/3</a></td><td></td></tr><tr><td valign="top"><a href="#get_keys_mod_test-0">get_keys_mod_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#id-1">id/1</a></td><td>Return the ID of a message, using the <code>committers</code> list if it exists.</td></tr><tr><td valign="top"><a href="#id-2">id/2</a></td><td></td></tr><tr><td valign="top"><a href="#id-3">id/3</a></td><td></td></tr><tr><td valign="top"><a href="#id_device-1">id_device/1*</a></td><td>Locate the ID device of a message.</td></tr><tr><td valign="top"><a href="#info-0">info/0</a></td><td>Return the info for the identity device.</td></tr><tr><td valign="top"><a href="#is_private_mod_test-0">is_private_mod_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#key_from_device_test-0">key_from_device_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#keys-1">keys/1</a></td><td>Get the public keys of a message.</td></tr><tr><td valign="top"><a href="#keys_from_device_test-0">keys_from_device_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#private_keys_are_filtered_test-0">private_keys_are_filtered_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#remove-2">remove/2</a></td><td>Remove a key or keys from a message.</td></tr><tr><td valign="top"><a href="#remove_test-0">remove_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#run_test-0">run_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#set-3">set/3</a></td><td>Deep merge keys in a message.</td></tr><tr><td valign="top"><a href="#set_conflicting_keys_test-0">set_conflicting_keys_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#set_ignore_undefined_test-0">set_ignore_undefined_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#set_path-3">set_path/3</a></td><td>Special case of <code>set/3</code> for setting the <code>path</code> key.</td></tr><tr><td valign="top"><a href="#unset_with_set_test-0">unset_with_set_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td>Verify a message.</td></tr><tr><td valign="top"><a href="#verify_test-0">verify_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#with_relevant_commitments-3">with_relevant_commitments/3*</a></td><td>Return a message with only the relevant commitments for a given request.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="calculate_ids-3"></a>

### calculate_ids/3 * ###

`calculate_ids(Base, Req, NodeOpts) -> any()`

<a name="cannot_get_private_keys_test-0"></a>

### cannot_get_private_keys_test/0 * ###

`cannot_get_private_keys_test() -> any()`

<a name="case_insensitive_get-2"></a>

### case_insensitive_get/2 * ###

`case_insensitive_get(Key, Msg) -> any()`

Key matching should be case insensitive, following RFC-9110, so we
implement a case-insensitive key lookup rather than delegating to
`maps:get/2`. Encode the key to a binary if it is not already.

<a name="case_insensitive_get_test-0"></a>

### case_insensitive_get_test/0 * ###

`case_insensitive_get_test() -> any()`

<a name="commit-3"></a>

### commit/3 ###

`commit(Self, Req, Opts) -> any()`

Commit to a message, using the `commitment-device` key to specify the
device that should be used to commit to the message. If the key is not set,
the default device (`httpsig@1.0`) is used.

<a name="commitment_ids_from_committers-2"></a>

### commitment_ids_from_committers/2 * ###

`commitment_ids_from_committers(CommitterAddrs, Commitments) -> any()`

Returns a list of commitment IDs in a commitments map that are relevant
for a list of given committer addresses.

<a name="commitment_ids_from_request-3"></a>

### commitment_ids_from_request/3 * ###

`commitment_ids_from_request(Base, Req, Opts) -> any()`

Implements a standardized form of specifying commitment IDs for a
message request. The caller may specify a list of committers (by address)
or a list of commitment IDs directly. They may specify both, in which case
the returned list will be the union of the two lists. In each case, they
may specify `all` or `none` for each group. If no specifiers are provided,
the default is `all` for commitments -- also implying `all` for committers.

<a name="committed-3"></a>

### committed/3 ###

`committed(Self, Req, Opts) -> any()`

Return the list of committed keys from a message.

<a name="committers-1"></a>

### committers/1 ###

`committers(Base) -> any()`

Return the committers of a message that are present in the given request.

<a name="committers-2"></a>

### committers/2 ###

`committers(Base, Req) -> any()`

<a name="committers-3"></a>

### committers/3 ###

`committers(X1, X2, NodeOpts) -> any()`

<a name="exec_for_commitment-5"></a>

### exec_for_commitment/5 * ###

`exec_for_commitment(Func, Base, Commitment, Req, Opts) -> any()`

Execute a function for a single commitment in the context of its
parent message.
Note: Assumes that the `commitments` key has already been removed from the
message if applicable.

<a name="get-2"></a>

### get/2 ###

`get(Key, Msg) -> any()`

Return the value associated with the key as it exists in the message's
underlying Erlang map. First check the public keys, then check case-
insensitively if the key is a binary.

<a name="get-3"></a>

### get/3 ###

`get(Key, Msg, Msg2) -> any()`

<a name="get_keys_mod_test-0"></a>

### get_keys_mod_test/0 * ###

`get_keys_mod_test() -> any()`

<a name="id-1"></a>

### id/1 ###

`id(Base) -> any()`

Return the ID of a message, using the `committers` list if it exists.
If the `committers` key is `all`, return the ID including all known
commitments -- `none` yields the ID without any commitments. If the
`committers` key is a list/map, return the ID including only the specified
commitments.

The `id-device` key in the message can be used to specify the device that
should be used to calculate the ID. If it is not set, the default device
(`httpsig@1.0`) is used.

Note: This function _does not_ use AO-Core's `get/3` function, as it
as it would require significant computation. We may want to change this
if/when non-map message structures are created.

<a name="id-2"></a>

### id/2 ###

`id(Base, Req) -> any()`

<a name="id-3"></a>

### id/3 ###

`id(Base, Req, NodeOpts) -> any()`

<a name="id_device-1"></a>

### id_device/1 * ###

`id_device(X1) -> any()`

Locate the ID device of a message. The ID device is determined the
`device` set in _all_ of the commitments. If no commitments are present,
the default device (`httpsig@1.0`) is used.

<a name="info-0"></a>

### info/0 ###

`info() -> any()`

Return the info for the identity device.

<a name="is_private_mod_test-0"></a>

### is_private_mod_test/0 * ###

`is_private_mod_test() -> any()`

<a name="key_from_device_test-0"></a>

### key_from_device_test/0 * ###

`key_from_device_test() -> any()`

<a name="keys-1"></a>

### keys/1 ###

`keys(Msg) -> any()`

Get the public keys of a message.

<a name="keys_from_device_test-0"></a>

### keys_from_device_test/0 * ###

`keys_from_device_test() -> any()`

<a name="private_keys_are_filtered_test-0"></a>

### private_keys_are_filtered_test/0 * ###

`private_keys_are_filtered_test() -> any()`

<a name="remove-2"></a>

### remove/2 ###

`remove(Message1, X2) -> any()`

Remove a key or keys from a message.

<a name="remove_test-0"></a>

### remove_test/0 * ###

`remove_test() -> any()`

<a name="run_test-0"></a>

### run_test/0 * ###

`run_test() -> any()`

<a name="set-3"></a>

### set/3 ###

`set(Message1, NewValuesMsg, Opts) -> any()`

Deep merge keys in a message. Takes a map of key-value pairs and sets
them in the message, overwriting any existing values.

<a name="set_conflicting_keys_test-0"></a>

### set_conflicting_keys_test/0 * ###

`set_conflicting_keys_test() -> any()`

<a name="set_ignore_undefined_test-0"></a>

### set_ignore_undefined_test/0 * ###

`set_ignore_undefined_test() -> any()`

<a name="set_path-3"></a>

### set_path/3 ###

`set_path(Message1, X2, Opts) -> any()`

Special case of `set/3` for setting the `path` key. This cannot be set
using the normal `set` function, as the `path` is a reserved key, necessary
for AO-Core to know the key to evaluate in requests.

<a name="unset_with_set_test-0"></a>

### unset_with_set_test/0 * ###

`unset_with_set_test() -> any()`

<a name="verify-3"></a>

### verify/3 ###

`verify(Self, Req, Opts) -> any()`

Verify a message. By default, all commitments are verified. The
`committers` key in the request can be used to specify that only the
commitments from specific committers should be verified. Similarly, specific
commitments can be specified using the `commitments` key.

<a name="verify_test-0"></a>

### verify_test/0 * ###

`verify_test() -> any()`

<a name="with_relevant_commitments-3"></a>

### with_relevant_commitments/3 * ###

`with_relevant_commitments(Base, Req, Opts) -> any()`

Return a message with only the relevant commitments for a given request.
See `commitment_ids_from_request/3` for more information on the request format.


--- END OF FILE: docs/resources/source-code/dev_message.md ---

--- START OF FILE: docs/resources/source-code/dev_meta.md ---
# [Module dev_meta.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_meta.erl)




The hyperbeam meta device, which is the default entry point
for all messages processed by the machine.

<a name="description"></a>

## Description ##
This device executes a
AO-Core singleton request, after first applying the node's
pre-processor, if set. The pre-processor can halt the request by
returning an error, or return a modified version if it deems necessary --
the result of the pre-processor is used as the request for the AO-Core
resolver. Additionally, a post-processor can be set, which is executed after
the AO-Core resolver has returned a result.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_dynamic_keys-1">add_dynamic_keys/1*</a></td><td>Add dynamic keys to the node message.</td></tr><tr><td valign="top"><a href="#adopt_node_message-2">adopt_node_message/2</a></td><td>Attempt to adopt changes to a node message.</td></tr><tr><td valign="top"><a href="#authorized_set_node_msg_succeeds_test-0">authorized_set_node_msg_succeeds_test/0*</a></td><td>Test that we can set the node message if the request is signed by the
owner of the node.</td></tr><tr><td valign="top"><a href="#claim_node_test-0">claim_node_test/0*</a></td><td>Test that we can claim the node correctly and set the node message after.</td></tr><tr><td valign="top"><a href="#config_test-0">config_test/0*</a></td><td>Test that we can get the node message.</td></tr><tr><td valign="top"><a href="#embed_status-1">embed_status/1*</a></td><td>Wrap the result of a device call in a status.</td></tr><tr><td valign="top"><a href="#filter_node_msg-1">filter_node_msg/1*</a></td><td>Remove items from the node message that are not encodable into a
message.</td></tr><tr><td valign="top"><a href="#halt_request_test-0">halt_request_test/0*</a></td><td>Test that we can halt a request if the preprocessor returns an error.</td></tr><tr><td valign="top"><a href="#handle-2">handle/2</a></td><td>Normalize and route messages downstream based on their path.</td></tr><tr><td valign="top"><a href="#handle_initialize-2">handle_initialize/2*</a></td><td></td></tr><tr><td valign="top"><a href="#handle_resolve-3">handle_resolve/3*</a></td><td>Handle an AO-Core request, which is a list of messages.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Ensure that the helper function <code>adopt_node_message/2</code> is not exported.</td></tr><tr><td valign="top"><a href="#info-3">info/3</a></td><td>Get/set the node message.</td></tr><tr><td valign="top"><a href="#is-2">is/2</a></td><td>Check if the request in question is signed by a given <code>role</code> on the node.</td></tr><tr><td valign="top"><a href="#is-3">is/3</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_sign-2">maybe_sign/2*</a></td><td>Sign the result of a device call if the node is configured to do so.</td></tr><tr><td valign="top"><a href="#message_to_status-1">message_to_status/1*</a></td><td>Get the HTTP status code from a transaction (if it exists).</td></tr><tr><td valign="top"><a href="#modify_request_test-0">modify_request_test/0*</a></td><td>Test that a preprocessor can modify a request.</td></tr><tr><td valign="top"><a href="#permanent_node_message_test-0">permanent_node_message_test/0*</a></td><td>Test that a permanent node message cannot be changed.</td></tr><tr><td valign="top"><a href="#priv_inaccessible_test-0">priv_inaccessible_test/0*</a></td><td>Test that we can't get the node message if the requested key is private.</td></tr><tr><td valign="top"><a href="#resolve_processor-5">resolve_processor/5*</a></td><td>Execute a message from the node message upon the user's request.</td></tr><tr><td valign="top"><a href="#status_code-1">status_code/1*</a></td><td>Calculate the appropriate HTTP status code for an AO-Core result.</td></tr><tr><td valign="top"><a href="#unauthorized_set_node_msg_fails_test-0">unauthorized_set_node_msg_fails_test/0*</a></td><td>Test that we can't set the node message if the request is not signed by
the owner of the node.</td></tr><tr><td valign="top"><a href="#uninitialized_node_test-0">uninitialized_node_test/0*</a></td><td>Test that an uninitialized node will not run computation.</td></tr><tr><td valign="top"><a href="#update_node_message-2">update_node_message/2*</a></td><td>Validate that the request is signed by the operator of the node, then
allow them to update the node message.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_dynamic_keys-1"></a>

### add_dynamic_keys/1 * ###

`add_dynamic_keys(NodeMsg) -> any()`

Add dynamic keys to the node message.

<a name="adopt_node_message-2"></a>

### adopt_node_message/2 ###

`adopt_node_message(Request, NodeMsg) -> any()`

Attempt to adopt changes to a node message.

<a name="authorized_set_node_msg_succeeds_test-0"></a>

### authorized_set_node_msg_succeeds_test/0 * ###

`authorized_set_node_msg_succeeds_test() -> any()`

Test that we can set the node message if the request is signed by the
owner of the node.

<a name="claim_node_test-0"></a>

### claim_node_test/0 * ###

`claim_node_test() -> any()`

Test that we can claim the node correctly and set the node message after.

<a name="config_test-0"></a>

### config_test/0 * ###

`config_test() -> any()`

Test that we can get the node message.

<a name="embed_status-1"></a>

### embed_status/1 * ###

`embed_status(X1) -> any()`

Wrap the result of a device call in a status.

<a name="filter_node_msg-1"></a>

### filter_node_msg/1 * ###

`filter_node_msg(Msg) -> any()`

Remove items from the node message that are not encodable into a
message.

<a name="halt_request_test-0"></a>

### halt_request_test/0 * ###

`halt_request_test() -> any()`

Test that we can halt a request if the preprocessor returns an error.

<a name="handle-2"></a>

### handle/2 ###

`handle(NodeMsg, RawRequest) -> any()`

Normalize and route messages downstream based on their path. Messages
with a `Meta` key are routed to the `handle_meta/2` function, while all
other messages are routed to the `handle_resolve/2` function.

<a name="handle_initialize-2"></a>

### handle_initialize/2 * ###

`handle_initialize(Rest, NodeMsg) -> any()`

<a name="handle_resolve-3"></a>

### handle_resolve/3 * ###

`handle_resolve(Req, Msgs, NodeMsg) -> any()`

Handle an AO-Core request, which is a list of messages. We apply
the node's pre-processor to the request first, and then resolve the request
using the node's AO-Core implementation if its response was `ok`.
After execution, we run the node's `postprocessor` message on the result of
the request before returning the result it grants back to the user.

<a name="info-1"></a>

### info/1 ###

`info(X1) -> any()`

Ensure that the helper function `adopt_node_message/2` is not exported.
The naming of this method carefully avoids a clash with the exported `info/3`
function. We would like the node information to be easily accessible via the
`info` endpoint, but AO-Core also uses `info` as the name of the function
that grants device information. The device call takes two or fewer arguments,
so we are safe to use the name for both purposes in this case, as the user
info call will match the three-argument version of the function. If in the
future the `request` is added as an argument to AO-Core's internal `info`
function, we will need to find a different approach.

<a name="info-3"></a>

### info/3 ###

`info(X1, Request, NodeMsg) -> any()`

Get/set the node message. If the request is a `POST`, we check that the
request is signed by the owner of the node. If not, we return the node message
as-is, aside all keys that are private (according to `hb_private`).

<a name="is-2"></a>

### is/2 ###

`is(Request, NodeMsg) -> any()`

Check if the request in question is signed by a given `role` on the node.
The `role` can be one of `operator` or `initiator`.

<a name="is-3"></a>

### is/3 ###

`is(X1, Request, NodeMsg) -> any()`

<a name="maybe_sign-2"></a>

### maybe_sign/2 * ###

`maybe_sign(Res, NodeMsg) -> any()`

Sign the result of a device call if the node is configured to do so.

<a name="message_to_status-1"></a>

### message_to_status/1 * ###

`message_to_status(Item) -> any()`

Get the HTTP status code from a transaction (if it exists).

<a name="modify_request_test-0"></a>

### modify_request_test/0 * ###

`modify_request_test() -> any()`

Test that a preprocessor can modify a request.

<a name="permanent_node_message_test-0"></a>

### permanent_node_message_test/0 * ###

`permanent_node_message_test() -> any()`

Test that a permanent node message cannot be changed.

<a name="priv_inaccessible_test-0"></a>

### priv_inaccessible_test/0 * ###

`priv_inaccessible_test() -> any()`

Test that we can't get the node message if the requested key is private.

<a name="resolve_processor-5"></a>

### resolve_processor/5 * ###

`resolve_processor(PathKey, Processor, Req, Query, NodeMsg) -> any()`

Execute a message from the node message upon the user's request. The
invocation of the processor provides a request of the following form:

```

       /path => preprocess | postprocess
       /request => the original request singleton
       /body => list of messages the user wishes to process
```

<a name="status_code-1"></a>

### status_code/1 * ###

`status_code(X1) -> any()`

Calculate the appropriate HTTP status code for an AO-Core result.
The order of precedence is:
1. The status code from the message.
2. The HTTP representation of the status code.
3. The default status code.

<a name="unauthorized_set_node_msg_fails_test-0"></a>

### unauthorized_set_node_msg_fails_test/0 * ###

`unauthorized_set_node_msg_fails_test() -> any()`

Test that we can't set the node message if the request is not signed by
the owner of the node.

<a name="uninitialized_node_test-0"></a>

### uninitialized_node_test/0 * ###

`uninitialized_node_test() -> any()`

Test that an uninitialized node will not run computation.

<a name="update_node_message-2"></a>

### update_node_message/2 * ###

`update_node_message(Request, NodeMsg) -> any()`

Validate that the request is signed by the operator of the node, then
allow them to update the node message.


--- END OF FILE: docs/resources/source-code/dev_meta.md ---

--- START OF FILE: docs/resources/source-code/dev_monitor.md ---
# [Module dev_monitor.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_monitor.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_monitor-2">add_monitor/2</a></td><td></td></tr><tr><td valign="top"><a href="#end_of_schedule-1">end_of_schedule/1</a></td><td></td></tr><tr><td valign="top"><a href="#execute-2">execute/2</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td></td></tr><tr><td valign="top"><a href="#signal-2">signal/2*</a></td><td></td></tr><tr><td valign="top"><a href="#uses-0">uses/0</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_monitor-2"></a>

### add_monitor/2 ###

`add_monitor(Mon, State) -> any()`

<a name="end_of_schedule-1"></a>

### end_of_schedule/1 ###

`end_of_schedule(State) -> any()`

<a name="execute-2"></a>

### execute/2 ###

`execute(Message, State) -> any()`

<a name="init-3"></a>

### init/3 ###

`init(State, X2, InitState) -> any()`

<a name="signal-2"></a>

### signal/2 * ###

`signal(State, Signal) -> any()`

<a name="uses-0"></a>

### uses/0 ###

`uses() -> any()`


--- END OF FILE: docs/resources/source-code/dev_monitor.md ---

--- START OF FILE: docs/resources/source-code/dev_multipass.md ---
# [Module dev_multipass.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_multipass.erl)




A device that triggers repass events until a certain counter has been
reached.

<a name="description"></a>

## Description ##
This is useful for certain types of stacks that need various
execution passes to be completed in sequence across devices.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#basic_multipass_test-0">basic_multipass_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#handle-4">handle/4*</a></td><td>Forward the keys function to the message device, handle all others
with deduplication.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="basic_multipass_test-0"></a>

### basic_multipass_test/0 * ###

`basic_multipass_test() -> any()`

<a name="handle-4"></a>

### handle/4 * ###

`handle(Key, M1, M2, Opts) -> any()`

Forward the keys function to the message device, handle all others
with deduplication. We only act on the first pass.

<a name="info-1"></a>

### info/1 ###

`info(M1) -> any()`


--- END OF FILE: docs/resources/source-code/dev_multipass.md ---

--- START OF FILE: docs/resources/source-code/dev_name.md ---
# [Module dev_name.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_name.erl)




A device for resolving names to their corresponding values, through the
use of a `resolver` interface.

<a name="description"></a>

## Description ##
Each `resolver` is a message that can be
given a `key` and returns an associated value. The device will attempt to
match the key against each resolver in turn, and return the value of the
first resolver that matches.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#execute_resolver-3">execute_resolver/3*</a></td><td>Execute a resolver with the given key and return its value.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Configure the <code>default</code> key to proxy to the <code>resolver/4</code> function.</td></tr><tr><td valign="top"><a href="#load_and_execute_test-0">load_and_execute_test/0*</a></td><td>Test that we can resolve messages from a name loaded with the device.</td></tr><tr><td valign="top"><a href="#match_resolver-3">match_resolver/3*</a></td><td>Find the first resolver that matches the key and return its value.</td></tr><tr><td valign="top"><a href="#message_lookup_device_resolver-1">message_lookup_device_resolver/1*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_resolvers_test-0">multiple_resolvers_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#no_resolvers_test-0">no_resolvers_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve-4">resolve/4*</a></td><td>Resolve a name to its corresponding value.</td></tr><tr><td valign="top"><a href="#single_resolver_test-0">single_resolver_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="execute_resolver-3"></a>

### execute_resolver/3 * ###

`execute_resolver(Key, Resolver, Opts) -> any()`

Execute a resolver with the given key and return its value.

<a name="info-1"></a>

### info/1 ###

`info(X1) -> any()`

Configure the `default` key to proxy to the `resolver/4` function.
Exclude the `keys` and `set` keys from being processed by this device, as
these are needed to modify the base message itself.

<a name="load_and_execute_test-0"></a>

### load_and_execute_test/0 * ###

`load_and_execute_test() -> any()`

Test that we can resolve messages from a name loaded with the device.

<a name="match_resolver-3"></a>

### match_resolver/3 * ###

`match_resolver(Key, Resolvers, Opts) -> any()`

Find the first resolver that matches the key and return its value.

<a name="message_lookup_device_resolver-1"></a>

### message_lookup_device_resolver/1 * ###

`message_lookup_device_resolver(Msg) -> any()`

<a name="multiple_resolvers_test-0"></a>

### multiple_resolvers_test/0 * ###

`multiple_resolvers_test() -> any()`

<a name="no_resolvers_test-0"></a>

### no_resolvers_test/0 * ###

`no_resolvers_test() -> any()`

<a name="resolve-4"></a>

### resolve/4 * ###

`resolve(Key, X2, Req, Opts) -> any()`

Resolve a name to its corresponding value. The name is given by the key
called. For example, `GET /~name@1.0/hello&load=false` grants the value of
`hello`. If the `load` key is set to `true`, the value is treated as a
pointer and its contents is loaded from the cache. For example,
`GET /~name@1.0/reference` yields the message at the path specified by the
`reference` key.

<a name="single_resolver_test-0"></a>

### single_resolver_test/0 * ###

`single_resolver_test() -> any()`


--- END OF FILE: docs/resources/source-code/dev_name.md ---

--- START OF FILE: docs/resources/source-code/dev_node_process.md ---
# [Module dev_node_process.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_node_process.erl)




A device that implements the singleton pattern for processes specific
to an individual node.

<a name="description"></a>

## Description ##

This device uses the `local-name@1.0` device to
register processes with names locally, persistenting them across reboots.

Definitions of singleton processes are expected to be found with their
names in the `node_processes` section of the node message.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#augment_definition-2">augment_definition/2*</a></td><td>Augment the given process definition with the node's address.</td></tr><tr><td valign="top"><a href="#generate_test_opts-0">generate_test_opts/0*</a></td><td>Helper function to generate a test environment and its options.</td></tr><tr><td valign="top"><a href="#generate_test_opts-1">generate_test_opts/1*</a></td><td></td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Register a default handler for the device.</td></tr><tr><td valign="top"><a href="#lookup-4">lookup/4*</a></td><td>Lookup a process by name.</td></tr><tr><td valign="top"><a href="#lookup_execute_test-0">lookup_execute_test/0*</a></td><td>Test that a process can be spawned, executed upon, and its result retrieved.</td></tr><tr><td valign="top"><a href="#lookup_no_spawn_test-0">lookup_no_spawn_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#lookup_spawn_test-0">lookup_spawn_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#spawn_register-2">spawn_register/2*</a></td><td>Spawn a new process according to the process definition found in the
node message, and register it with the given name.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="augment_definition-2"></a>

### augment_definition/2 * ###

`augment_definition(BaseDef, Opts) -> any()`

Augment the given process definition with the node's address.

<a name="generate_test_opts-0"></a>

### generate_test_opts/0 * ###

`generate_test_opts() -> any()`

Helper function to generate a test environment and its options.

<a name="generate_test_opts-1"></a>

### generate_test_opts/1 * ###

`generate_test_opts(Defs) -> any()`

<a name="info-1"></a>

### info/1 ###

`info(Opts) -> any()`

Register a default handler for the device. Inherits `keys` and `set`
from the default device.

<a name="lookup-4"></a>

### lookup/4 * ###

`lookup(Name, Base, Req, Opts) -> any()`

Lookup a process by name.

<a name="lookup_execute_test-0"></a>

### lookup_execute_test/0 * ###

`lookup_execute_test() -> any()`

Test that a process can be spawned, executed upon, and its result retrieved.

<a name="lookup_no_spawn_test-0"></a>

### lookup_no_spawn_test/0 * ###

`lookup_no_spawn_test() -> any()`

<a name="lookup_spawn_test-0"></a>

### lookup_spawn_test/0 * ###

`lookup_spawn_test() -> any()`

<a name="spawn_register-2"></a>

### spawn_register/2 * ###

`spawn_register(Name, Opts) -> any()`

Spawn a new process according to the process definition found in the
node message, and register it with the given name.


--- END OF FILE: docs/resources/source-code/dev_node_process.md ---

--- START OF FILE: docs/resources/source-code/dev_p4.md ---
# [Module dev_p4.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_p4.erl)




The HyperBEAM core payment ledger.

<a name="description"></a>

## Description ##

This module allows the operator to
specify another device that can act as a pricing mechanism for transactions
on the node, as well as orchestrating a payment ledger to calculate whether
the node should fulfil services for users.

The device requires the following node message settings in order to function:

- `p4_pricing-device`: The device that will estimate the cost of a request.
- `p4_ledger-device`: The device that will act as a payment ledger.

The pricing device should implement the following keys:

```
<code>GET /estimate?type=pre|post&body=[...]&request=RequestMessage</code><code>GET /price?type=pre|post&body=[...]&request=RequestMessage</code>
```

The `body` key is used to pass either the request or response messages to the
device. The `type` key is used to specify whether the inquiry is for a request
(pre) or a response (post) object. Requests carry lists of messages that will
be executed, while responses carry the results of the execution. The `price`
key may return `infinity` if the node will not serve a user under any
circumstances. Else, the value returned by the `price` key will be passed to
the ledger device as the `amount` key.

The ledger device should implement the following keys:

```
<code>POST /credit?message=PaymentMessage&request=RequestMessage</code><code>POST /debit?amount=PriceMessage&type=pre|post&request=RequestMessage</code>
```

The `type` key is optional and defaults to `pre`. If `type` is set to `post`,
the debit must be applied to the ledger, whereas the `pre` type is used to
check whether the debit would succeed before execution.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#balance-3">balance/3</a></td><td>Get the balance of a user in the ledger.</td></tr><tr><td valign="top"><a href="#faff_test-0">faff_test/0*</a></td><td>Simple test of p4's capabilities with the <code>faff@1.0</code> device.</td></tr><tr><td valign="top"><a href="#is_chargable_req-2">is_chargable_req/2*</a></td><td>The node operator may elect to make certain routes non-chargable, using
the <code>routes</code> syntax also used to declare routes in <code>router@1.0</code>.</td></tr><tr><td valign="top"><a href="#non_chargable_route_test-0">non_chargable_route_test/0*</a></td><td>Test that a non-chargable route is not charged for.</td></tr><tr><td valign="top"><a href="#postprocess-3">postprocess/3</a></td><td>Postprocess the request after it has been fulfilled.</td></tr><tr><td valign="top"><a href="#preprocess-3">preprocess/3</a></td><td>Estimate the cost of a transaction and decide whether to proceed with
a request.</td></tr><tr><td valign="top"><a href="#test_opts-1">test_opts/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_opts-2">test_opts/2*</a></td><td></td></tr><tr><td valign="top"><a href="#test_opts-3">test_opts/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="balance-3"></a>

### balance/3 ###

`balance(X1, Req, NodeMsg) -> any()`

Get the balance of a user in the ledger.

<a name="faff_test-0"></a>

### faff_test/0 * ###

`faff_test() -> any()`

Simple test of p4's capabilities with the `faff@1.0` device.

<a name="is_chargable_req-2"></a>

### is_chargable_req/2 * ###

`is_chargable_req(Req, NodeMsg) -> any()`

The node operator may elect to make certain routes non-chargable, using
the `routes` syntax also used to declare routes in `router@1.0`.

<a name="non_chargable_route_test-0"></a>

### non_chargable_route_test/0 * ###

`non_chargable_route_test() -> any()`

Test that a non-chargable route is not charged for.

<a name="postprocess-3"></a>

### postprocess/3 ###

`postprocess(State, RawResponse, NodeMsg) -> any()`

Postprocess the request after it has been fulfilled.

<a name="preprocess-3"></a>

### preprocess/3 ###

`preprocess(State, Raw, NodeMsg) -> any()`

Estimate the cost of a transaction and decide whether to proceed with
a request. The default behavior if `pricing-device` or `p4_balances` are
not set is to proceed, so it is important that a user initialize them.

<a name="test_opts-1"></a>

### test_opts/1 * ###

`test_opts(Opts) -> any()`

<a name="test_opts-2"></a>

### test_opts/2 * ###

`test_opts(Opts, PricingDev) -> any()`

<a name="test_opts-3"></a>

### test_opts/3 * ###

`test_opts(Opts, PricingDev, LedgerDev) -> any()`


--- END OF FILE: docs/resources/source-code/dev_p4.md ---

--- START OF FILE: docs/resources/source-code/dev_patch.md ---
# [Module dev_patch.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_patch.erl)




A device that finds `PATCH` requests in the `results/outbox`
of its message, and applies them to it.

<a name="description"></a>

## Description ##
This can be useful for processes
whose computation would like to manipulate data outside of the `results` key
of its message.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>Find <code>PATCH</code> requests in the <code>results/outbox</code> of the message, and apply
them to the state.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Default process device hooks.</td></tr><tr><td valign="top"><a href="#normalize-3">normalize/3</a></td><td></td></tr><tr><td valign="top"><a href="#patch_to_submessage_test-0">patch_to_submessage_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td></td></tr><tr><td valign="top"><a href="#uninitialized_patch_test-0">uninitialized_patch_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="compute-3"></a>

### compute/3 ###

`compute(Msg1, Msg2, Opts) -> any()`

Find `PATCH` requests in the `results/outbox` of the message, and apply
them to the state.

<a name="init-3"></a>

### init/3 ###

`init(Msg1, Msg2, Opts) -> any()`

Default process device hooks.

<a name="normalize-3"></a>

### normalize/3 ###

`normalize(Msg1, Msg2, Opts) -> any()`

<a name="patch_to_submessage_test-0"></a>

### patch_to_submessage_test/0 * ###

`patch_to_submessage_test() -> any()`

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(Msg1, Msg2, Opts) -> any()`

<a name="uninitialized_patch_test-0"></a>

### uninitialized_patch_test/0 * ###

`uninitialized_patch_test() -> any()`


--- END OF FILE: docs/resources/source-code/dev_patch.md ---

--- START OF FILE: docs/resources/source-code/dev_poda.md ---
# [Module dev_poda.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_poda.erl)




A simple exemplar decentralized proof of authority consensus algorithm
for AO processes.

<a name="description"></a>

## Description ##

This device is split into two flows, spanning three
actions.

Execution flow:
1. Initialization.
2. Validation of incoming messages before execution.
Commitment flow:
1. Adding commitments to results, either on a CU or MU.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_commitments-2">add_commitments/2*</a></td><td></td></tr><tr><td valign="top"><a href="#commit_to_results-2">commit_to_results/2*</a></td><td></td></tr><tr><td valign="top"><a href="#execute-3">execute/3</a></td><td></td></tr><tr><td valign="top"><a href="#extract_opts-1">extract_opts/1*</a></td><td></td></tr><tr><td valign="top"><a href="#find_process-2">find_process/2*</a></td><td>Find the process that this message is targeting, in order to
determine which commitments to add.</td></tr><tr><td valign="top"><a href="#init-2">init/2</a></td><td></td></tr><tr><td valign="top"><a href="#is_user_signed-1">is_user_signed/1</a></td><td>Determines if a user committed.</td></tr><tr><td valign="top"><a href="#pfiltermap-2">pfiltermap/2*</a></td><td>Helper function for parallel execution of commitment
gathering.</td></tr><tr><td valign="top"><a href="#push-2">push/2</a></td><td>Hook used by the MU pathway (currently) to add commitments to an
outbound message if the computation requests it.</td></tr><tr><td valign="top"><a href="#return_error-2">return_error/2*</a></td><td></td></tr><tr><td valign="top"><a href="#validate-2">validate/2*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_commitment-3">validate_commitment/3*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_stage-3">validate_stage/3*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_stage-4">validate_stage/4*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_commitments-2"></a>

### add_commitments/2 * ###

`add_commitments(NewMsg, S) -> any()`

<a name="commit_to_results-2"></a>

### commit_to_results/2 * ###

`commit_to_results(Msg, S) -> any()`

<a name="execute-3"></a>

### execute/3 ###

`execute(Outer, S, Opts) -> any()`

<a name="extract_opts-1"></a>

### extract_opts/1 * ###

`extract_opts(Params) -> any()`

<a name="find_process-2"></a>

### find_process/2 * ###

`find_process(Item, X2) -> any()`

Find the process that this message is targeting, in order to
determine which commitments to add.

<a name="init-2"></a>

### init/2 ###

`init(S, Params) -> any()`

<a name="is_user_signed-1"></a>

### is_user_signed/1 ###

`is_user_signed(Tx) -> any()`

Determines if a user committed

<a name="pfiltermap-2"></a>

### pfiltermap/2 * ###

`pfiltermap(Pred, List) -> any()`

Helper function for parallel execution of commitment
gathering.

<a name="push-2"></a>

### push/2 ###

`push(Item, S) -> any()`

Hook used by the MU pathway (currently) to add commitments to an
outbound message if the computation requests it.

<a name="return_error-2"></a>

### return_error/2 * ###

`return_error(S, Reason) -> any()`

<a name="validate-2"></a>

### validate/2 * ###

`validate(Msg, Opts) -> any()`

<a name="validate_commitment-3"></a>

### validate_commitment/3 * ###

`validate_commitment(Msg, Comm, Opts) -> any()`

<a name="validate_stage-3"></a>

### validate_stage/3 * ###

`validate_stage(X1, Msg, Opts) -> any()`

<a name="validate_stage-4"></a>

### validate_stage/4 * ###

`validate_stage(X1, Tx, Content, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/dev_poda.md ---

--- START OF FILE: docs/resources/source-code/dev_process_cache.md ---
# [Module dev_process_cache.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_process_cache.erl)




A wrapper around the hb_cache module that provides a more
convenient interface for reading the result of a process at a given slot or
message ID.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#find_latest_outputs-1">find_latest_outputs/1*</a></td><td>Test for retrieving the latest computed output for a process.</td></tr><tr><td valign="top"><a href="#first_with_path-4">first_with_path/4*</a></td><td>Find the latest assignment with the requested path suffix.</td></tr><tr><td valign="top"><a href="#first_with_path-5">first_with_path/5*</a></td><td></td></tr><tr><td valign="top"><a href="#latest-2">latest/2</a></td><td>Retrieve the latest slot for a given process.</td></tr><tr><td valign="top"><a href="#latest-3">latest/3</a></td><td></td></tr><tr><td valign="top"><a href="#latest-4">latest/4</a></td><td></td></tr><tr><td valign="top"><a href="#path-3">path/3*</a></td><td>Calculate the path of a result, given a process ID and a slot.</td></tr><tr><td valign="top"><a href="#path-4">path/4*</a></td><td></td></tr><tr><td valign="top"><a href="#process_cache_suite_test_-0">process_cache_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read the result of a process at a given slot.</td></tr><tr><td valign="top"><a href="#read-3">read/3</a></td><td></td></tr><tr><td valign="top"><a href="#test_write_and_read_output-1">test_write_and_read_output/1*</a></td><td>Test for writing multiple computed outputs, then getting them by
their slot number and by their signed and unsigned IDs.</td></tr><tr><td valign="top"><a href="#write-4">write/4</a></td><td>Write a process computation result to the cache.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="find_latest_outputs-1"></a>

### find_latest_outputs/1 * ###

`find_latest_outputs(Opts) -> any()`

Test for retrieving the latest computed output for a process.

<a name="first_with_path-4"></a>

### first_with_path/4 * ###

`first_with_path(ProcID, RequiredPath, Slots, Opts) -> any()`

Find the latest assignment with the requested path suffix.

<a name="first_with_path-5"></a>

### first_with_path/5 * ###

`first_with_path(ProcID, Required, Rest, Opts, Store) -> any()`

<a name="latest-2"></a>

### latest/2 ###

`latest(ProcID, Opts) -> any()`

Retrieve the latest slot for a given process. Optionally state a limit
on the slot number to search for, as well as a required path that the slot
must have.

<a name="latest-3"></a>

### latest/3 ###

`latest(ProcID, RequiredPath, Opts) -> any()`

<a name="latest-4"></a>

### latest/4 ###

`latest(ProcID, RawRequiredPath, Limit, Opts) -> any()`

<a name="path-3"></a>

### path/3 * ###

`path(ProcID, Ref, Opts) -> any()`

Calculate the path of a result, given a process ID and a slot.

<a name="path-4"></a>

### path/4 * ###

`path(ProcID, Ref, PathSuffix, Opts) -> any()`

<a name="process_cache_suite_test_-0"></a>

### process_cache_suite_test_/0 * ###

`process_cache_suite_test_() -> any()`

<a name="read-2"></a>

### read/2 ###

`read(ProcID, Opts) -> any()`

Read the result of a process at a given slot.

<a name="read-3"></a>

### read/3 ###

`read(ProcID, SlotRef, Opts) -> any()`

<a name="test_write_and_read_output-1"></a>

### test_write_and_read_output/1 * ###

`test_write_and_read_output(Opts) -> any()`

Test for writing multiple computed outputs, then getting them by
their slot number and by their signed and unsigned IDs.

<a name="write-4"></a>

### write/4 ###

`write(ProcID, Slot, Msg, Opts) -> any()`

Write a process computation result to the cache.


--- END OF FILE: docs/resources/source-code/dev_process_cache.md ---

--- START OF FILE: docs/resources/source-code/dev_process_worker.md ---
# [Module dev_process_worker.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_process_worker.erl)




A long-lived process worker that keeps state in memory between
calls.

<a name="description"></a>

## Description ##
Implements the interface of `hb_ao` to receive and respond
to computation requests regarding a process as a singleton.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#await-5">await/5</a></td><td>Await a resolution from a worker executing the <code>process@1.0</code> device.</td></tr><tr><td valign="top"><a href="#group-3">group/3</a></td><td>Returns a group name for a request.</td></tr><tr><td valign="top"><a href="#grouper_test-0">grouper_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#info_test-0">info_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#notify_compute-4">notify_compute/4</a></td><td>Notify any waiters for a specific slot of the computed results.</td></tr><tr><td valign="top"><a href="#notify_compute-5">notify_compute/5*</a></td><td></td></tr><tr><td valign="top"><a href="#process_to_group_name-2">process_to_group_name/2*</a></td><td></td></tr><tr><td valign="top"><a href="#send_notification-4">send_notification/4*</a></td><td></td></tr><tr><td valign="top"><a href="#server-3">server/3</a></td><td>Spawn a new worker process.</td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td>Stop a worker process.</td></tr><tr><td valign="top"><a href="#test_init-0">test_init/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="await-5"></a>

### await/5 ###

`await(Worker, GroupName, Msg1, Msg2, Opts) -> any()`

Await a resolution from a worker executing the `process@1.0` device.

<a name="group-3"></a>

### group/3 ###

`group(Msg1, Msg2, Opts) -> any()`

Returns a group name for a request. The worker is responsible for all
computation work on the same process on a single node, so we use the
process ID as the group name.

<a name="grouper_test-0"></a>

### grouper_test/0 * ###

`grouper_test() -> any()`

<a name="info_test-0"></a>

### info_test/0 * ###

`info_test() -> any()`

<a name="notify_compute-4"></a>

### notify_compute/4 ###

`notify_compute(GroupName, SlotToNotify, Msg3, Opts) -> any()`

Notify any waiters for a specific slot of the computed results.

<a name="notify_compute-5"></a>

### notify_compute/5 * ###

`notify_compute(GroupName, SlotToNotify, Msg3, Opts, Count) -> any()`

<a name="process_to_group_name-2"></a>

### process_to_group_name/2 * ###

`process_to_group_name(Msg1, Opts) -> any()`

<a name="send_notification-4"></a>

### send_notification/4 * ###

`send_notification(Listener, GroupName, SlotToNotify, Msg3) -> any()`

<a name="server-3"></a>

### server/3 ###

`server(GroupName, Msg1, Opts) -> any()`

Spawn a new worker process. This is called after the end of the first
execution of `hb_ao:resolve/3`, so the state we are given is the
already current.

<a name="stop-1"></a>

### stop/1 ###

`stop(Worker) -> any()`

Stop a worker process.

<a name="test_init-0"></a>

### test_init/0 * ###

`test_init() -> any()`


--- END OF FILE: docs/resources/source-code/dev_process_worker.md ---

--- START OF FILE: docs/resources/source-code/dev_process.md ---
# [Module dev_process.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_process.erl)




This module contains the device implementation of AO processes
in AO-Core.

<a name="description"></a>

## Description ##

The core functionality of the module is in 'routing' requests
for different functionality (scheduling, computing, and pushing messages)
to the appropriate device. This is achieved by swapping out the device
of the process message with the necessary component in order to run the
execution, then swapping it back before returning. Computation is supported
as a stack of devices, customizable by the user, while the scheduling
device is (by default) a single device.

This allows the devices to share state as needed. Additionally, after each
computation step the device caches the result at a path relative to the
process definition itself, such that the process message's ID can act as an
immutable reference to the process's growing list of interactions. See
`dev_process_cache` for details.

The external API of the device is as follows:

```

   GET /ID/Schedule:                Returns the messages in the schedule
   POST /ID/Schedule:               Adds a message to the schedule
   GET /ID/Compute/[IDorSlotNum]:   Returns the state of the process after
                                    applying a message
   GET /ID/Now:                     Returns the <code>/Results</code> key of the latest
                                    computed message
```

An example process definition will look like this:

```

       Device: Process/1.0
       Scheduler-Device: Scheduler/1.0
       Execution-Device: Stack/1.0
       Execution-Stack: "Scheduler/1.0", "Cron/1.0", "WASM/1.0", "PoDA/1.0"
       Cron-Frequency: 10-Minutes
       WASM-Image: WASMImageID
       PoDA:
           Device: PoDA/1.0
           Authority: A
           Authority: B
           Authority: C
           Quorum: 2
```

Runtime options:
Cache-Frequency: The number of assignments that will be computed
before the full (restorable) state should be cached.
Cache-Keys:      A list of the keys that should be cached for all
assignments, in addition to `/Results`.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#aos_browsable_state_test_-0">aos_browsable_state_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#aos_compute_test_-0">aos_compute_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#aos_persistent_worker_benchmark_test_-0">aos_persistent_worker_benchmark_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#aos_state_access_via_http_test_-0">aos_state_access_via_http_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#aos_state_patch_test_-0">aos_state_patch_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#as_process-2">as_process/2</a></td><td>Change the message to for that has the device set as this module.</td></tr><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>Compute the result of an assignment applied to the process state, if it
is the next message.</td></tr><tr><td valign="top"><a href="#compute_slot-5">compute_slot/5*</a></td><td>Compute a single slot for a process, given an initialized state.</td></tr><tr><td valign="top"><a href="#compute_to_slot-5">compute_to_slot/5*</a></td><td>Continually get and apply the next assignment from the scheduler until
we reach the target slot that the user has requested.</td></tr><tr><td valign="top"><a href="#default_device-3">default_device/3*</a></td><td>Returns the default device for a given piece of functionality.</td></tr><tr><td valign="top"><a href="#default_device_index-1">default_device_index/1*</a></td><td></td></tr><tr><td valign="top"><a href="#dev_test_process-0">dev_test_process/0</a></td><td>Generate a device that has a stack of two <code>dev_test</code>s for
execution.</td></tr><tr><td valign="top"><a href="#do_test_restore-0">do_test_restore/0</a></td><td></td></tr><tr><td valign="top"><a href="#ensure_loaded-3">ensure_loaded/3*</a></td><td>Ensure that the process message we have in memory is live and
up-to-date.</td></tr><tr><td valign="top"><a href="#ensure_process_key-2">ensure_process_key/2</a></td><td>Helper function to store a copy of the <code>process</code> key in the message.</td></tr><tr><td valign="top"><a href="#get_scheduler_slot_test-0">get_scheduler_slot_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_wasm_process_by_id_test-0">http_wasm_process_by_id_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>When the info key is called, we should return the process exports.</td></tr><tr><td valign="top"><a href="#init-0">init/0</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3*</a></td><td>Before computation begins, a boot phase is required.</td></tr><tr><td valign="top"><a href="#next-3">next/3*</a></td><td></td></tr><tr><td valign="top"><a href="#now-3">now/3</a></td><td>Returns the known state of the process at either the current slot, or
the latest slot in the cache depending on the <code>process_now_from_cache</code> option.</td></tr><tr><td valign="top"><a href="#now_results_test_-0">now_results_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#persistent_process_test-0">persistent_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#prior_results_accessible_test_-0">prior_results_accessible_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#process_id-3">process_id/3</a></td><td>Returns the process ID of the current process.</td></tr><tr><td valign="top"><a href="#push-3">push/3</a></td><td>Recursively push messages to the scheduler until we find a message
that does not lead to any further messages being scheduled.</td></tr><tr><td valign="top"><a href="#recursive_path_resolution_test-0">recursive_path_resolution_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#restore_test_-0">restore_test_/0*</a></td><td>Manually test state restoration without using the cache.</td></tr><tr><td valign="top"><a href="#run_as-4">run_as/4*</a></td><td>Run a message against Msg1, with the device being swapped out for
the device found at <code>Key</code>.</td></tr><tr><td valign="top"><a href="#schedule-3">schedule/3</a></td><td>Wraps functions in the Scheduler device.</td></tr><tr><td valign="top"><a href="#schedule_aos_call-2">schedule_aos_call/2</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_aos_call-3">schedule_aos_call/3</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_on_process_test-0">schedule_on_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_test_message-2">schedule_test_message/2*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_test_message-3">schedule_test_message/3*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_wasm_call-3">schedule_wasm_call/3*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_wasm_call-4">schedule_wasm_call/4*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_wasm_persistent_worker_benchmark_test-0">simple_wasm_persistent_worker_benchmark_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#slot-3">slot/3</a></td><td></td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td></td></tr><tr><td valign="top"><a href="#store_result-5">store_result/5*</a></td><td>Store the resulting state in the cache, potentially with the snapshot
key.</td></tr><tr><td valign="top"><a href="#test_aos_process-0">test_aos_process/0</a></td><td>Generate a process message with a random number, and the
<code>dev_wasm</code> device for execution.</td></tr><tr><td valign="top"><a href="#test_aos_process-1">test_aos_process/1</a></td><td></td></tr><tr><td valign="top"><a href="#test_aos_process-2">test_aos_process/2*</a></td><td></td></tr><tr><td valign="top"><a href="#test_base_process-0">test_base_process/0*</a></td><td>Generate a process message with a random number, and no
executor.</td></tr><tr><td valign="top"><a href="#test_base_process-1">test_base_process/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_device_compute_test-0">test_device_compute_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_wasm_process-1">test_wasm_process/1</a></td><td></td></tr><tr><td valign="top"><a href="#test_wasm_process-2">test_wasm_process/2*</a></td><td></td></tr><tr><td valign="top"><a href="#wasm_compute_from_id_test-0">wasm_compute_from_id_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#wasm_compute_test-0">wasm_compute_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="aos_browsable_state_test_-0"></a>

### aos_browsable_state_test_/0 * ###

`aos_browsable_state_test_() -> any()`

<a name="aos_compute_test_-0"></a>

### aos_compute_test_/0 * ###

`aos_compute_test_() -> any()`

<a name="aos_persistent_worker_benchmark_test_-0"></a>

### aos_persistent_worker_benchmark_test_/0 * ###

`aos_persistent_worker_benchmark_test_() -> any()`

<a name="aos_state_access_via_http_test_-0"></a>

### aos_state_access_via_http_test_/0 * ###

`aos_state_access_via_http_test_() -> any()`

<a name="aos_state_patch_test_-0"></a>

### aos_state_patch_test_/0 * ###

`aos_state_patch_test_() -> any()`

<a name="as_process-2"></a>

### as_process/2 ###

`as_process(Msg1, Opts) -> any()`

Change the message to for that has the device set as this module.
In situations where the key that is `run_as` returns a message with a
transformed device, this is useful.

<a name="compute-3"></a>

### compute/3 ###

`compute(Msg1, Msg2, Opts) -> any()`

Compute the result of an assignment applied to the process state, if it
is the next message.

<a name="compute_slot-5"></a>

### compute_slot/5 * ###

`compute_slot(ProcID, State, RawInputMsg, ReqMsg, Opts) -> any()`

Compute a single slot for a process, given an initialized state.

<a name="compute_to_slot-5"></a>

### compute_to_slot/5 * ###

`compute_to_slot(ProcID, Msg1, Msg2, TargetSlot, Opts) -> any()`

Continually get and apply the next assignment from the scheduler until
we reach the target slot that the user has requested.

<a name="default_device-3"></a>

### default_device/3 * ###

`default_device(Msg1, Key, Opts) -> any()`

Returns the default device for a given piece of functionality. Expects
the `process/variant` key to be set in the message. The `execution-device`
_must_ be set in all processes aside those marked with `ao.TN.1` variant.
This is in order to ensure that post-mainnet processes do not default to
using infrastructure that should not be present on nodes in the future.

<a name="default_device_index-1"></a>

### default_device_index/1 * ###

`default_device_index(X1) -> any()`

<a name="dev_test_process-0"></a>

### dev_test_process/0 ###

`dev_test_process() -> any()`

Generate a device that has a stack of two `dev_test`s for
execution. This should generate a message state has doubled
`Already-Seen` elements for each assigned slot.

<a name="do_test_restore-0"></a>

### do_test_restore/0 ###

`do_test_restore() -> any()`

<a name="ensure_loaded-3"></a>

### ensure_loaded/3 * ###

`ensure_loaded(Msg1, Msg2, Opts) -> any()`

Ensure that the process message we have in memory is live and
up-to-date.

<a name="ensure_process_key-2"></a>

### ensure_process_key/2 ###

`ensure_process_key(Msg1, Opts) -> any()`

Helper function to store a copy of the `process` key in the message.

<a name="get_scheduler_slot_test-0"></a>

### get_scheduler_slot_test/0 * ###

`get_scheduler_slot_test() -> any()`

<a name="http_wasm_process_by_id_test-0"></a>

### http_wasm_process_by_id_test/0 * ###

`http_wasm_process_by_id_test() -> any()`

<a name="info-1"></a>

### info/1 ###

`info(Msg1) -> any()`

When the info key is called, we should return the process exports.

<a name="init-0"></a>

### init/0 ###

`init() -> any()`

<a name="init-3"></a>

### init/3 * ###

`init(Msg1, Msg2, Opts) -> any()`

Before computation begins, a boot phase is required. This phase
allows devices on the execution stack to initialize themselves. We set the
`Initialized` key to `True` to indicate that the process has been
initialized.

<a name="next-3"></a>

### next/3 * ###

`next(Msg1, Msg2, Opts) -> any()`

<a name="now-3"></a>

### now/3 ###

`now(RawMsg1, Msg2, Opts) -> any()`

Returns the known state of the process at either the current slot, or
the latest slot in the cache depending on the `process_now_from_cache` option.

<a name="now_results_test_-0"></a>

### now_results_test_/0 * ###

`now_results_test_() -> any()`

<a name="persistent_process_test-0"></a>

### persistent_process_test/0 * ###

`persistent_process_test() -> any()`

<a name="prior_results_accessible_test_-0"></a>

### prior_results_accessible_test_/0 * ###

`prior_results_accessible_test_() -> any()`

<a name="process_id-3"></a>

### process_id/3 ###

`process_id(Msg1, Msg2, Opts) -> any()`

Returns the process ID of the current process.

<a name="push-3"></a>

### push/3 ###

`push(Msg1, Msg2, Opts) -> any()`

Recursively push messages to the scheduler until we find a message
that does not lead to any further messages being scheduled.

<a name="recursive_path_resolution_test-0"></a>

### recursive_path_resolution_test/0 * ###

`recursive_path_resolution_test() -> any()`

<a name="restore_test_-0"></a>

### restore_test_/0 * ###

`restore_test_() -> any()`

Manually test state restoration without using the cache.

<a name="run_as-4"></a>

### run_as/4 * ###

`run_as(Key, Msg1, Msg2, Opts) -> any()`

Run a message against Msg1, with the device being swapped out for
the device found at `Key`. After execution, the device is swapped back
to the original device if the device is the same as we left it.

<a name="schedule-3"></a>

### schedule/3 ###

`schedule(Msg1, Msg2, Opts) -> any()`

Wraps functions in the Scheduler device.

<a name="schedule_aos_call-2"></a>

### schedule_aos_call/2 ###

`schedule_aos_call(Msg1, Code) -> any()`

<a name="schedule_aos_call-3"></a>

### schedule_aos_call/3 ###

`schedule_aos_call(Msg1, Code, Opts) -> any()`

<a name="schedule_on_process_test-0"></a>

### schedule_on_process_test/0 * ###

`schedule_on_process_test() -> any()`

<a name="schedule_test_message-2"></a>

### schedule_test_message/2 * ###

`schedule_test_message(Msg1, Text) -> any()`

<a name="schedule_test_message-3"></a>

### schedule_test_message/3 * ###

`schedule_test_message(Msg1, Text, MsgBase) -> any()`

<a name="schedule_wasm_call-3"></a>

### schedule_wasm_call/3 * ###

`schedule_wasm_call(Msg1, FuncName, Params) -> any()`

<a name="schedule_wasm_call-4"></a>

### schedule_wasm_call/4 * ###

`schedule_wasm_call(Msg1, FuncName, Params, Opts) -> any()`

<a name="simple_wasm_persistent_worker_benchmark_test-0"></a>

### simple_wasm_persistent_worker_benchmark_test/0 * ###

`simple_wasm_persistent_worker_benchmark_test() -> any()`

<a name="slot-3"></a>

### slot/3 ###

`slot(Msg1, Msg2, Opts) -> any()`

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(RawMsg1, Msg2, Opts) -> any()`

<a name="store_result-5"></a>

### store_result/5 * ###

`store_result(ProcID, Slot, Msg3, Msg2, Opts) -> any()`

Store the resulting state in the cache, potentially with the snapshot
key.

<a name="test_aos_process-0"></a>

### test_aos_process/0 ###

`test_aos_process() -> any()`

Generate a process message with a random number, and the
`dev_wasm` device for execution.

<a name="test_aos_process-1"></a>

### test_aos_process/1 ###

`test_aos_process(Opts) -> any()`

<a name="test_aos_process-2"></a>

### test_aos_process/2 * ###

`test_aos_process(Opts, Stack) -> any()`

<a name="test_base_process-0"></a>

### test_base_process/0 * ###

`test_base_process() -> any()`

Generate a process message with a random number, and no
executor.

<a name="test_base_process-1"></a>

### test_base_process/1 * ###

`test_base_process(Opts) -> any()`

<a name="test_device_compute_test-0"></a>

### test_device_compute_test/0 * ###

`test_device_compute_test() -> any()`

<a name="test_wasm_process-1"></a>

### test_wasm_process/1 ###

`test_wasm_process(WASMImage) -> any()`

<a name="test_wasm_process-2"></a>

### test_wasm_process/2 * ###

`test_wasm_process(WASMImage, Opts) -> any()`

<a name="wasm_compute_from_id_test-0"></a>

### wasm_compute_from_id_test/0 * ###

`wasm_compute_from_id_test() -> any()`

<a name="wasm_compute_test-0"></a>

### wasm_compute_test/0 * ###

`wasm_compute_test() -> any()`


--- END OF FILE: docs/resources/source-code/dev_process.md ---

--- START OF FILE: docs/resources/source-code/dev_push.md ---
# [Module dev_push.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_push.erl)




`push@1.0` takes a message or slot number, evaluates it, and recursively
pushes the resulting messages to other processes.

<a name="description"></a>

## Description ##
The `push`ing mechanism
continues until the there are no remaining messages to push.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#additional_keys-3">additional_keys/3*</a></td><td>Set the necessary keys in order for the recipient to know where the
message came from.</td></tr><tr><td valign="top"><a href="#do_push-3">do_push/3*</a></td><td>Push a message or slot number.</td></tr><tr><td valign="top"><a href="#extract-2">extract/2*</a></td><td>Return either the <code>target</code> or the <code>hint</code>.</td></tr><tr><td valign="top"><a href="#find_type-2">find_type/2*</a></td><td></td></tr><tr><td valign="top"><a href="#full_push_test_-0">full_push_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#is_async-3">is_async/3*</a></td><td>Determine if the push is asynchronous.</td></tr><tr><td valign="top"><a href="#multi_process_push_test_disabled-0">multi_process_push_test_disabled/0*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_message-2">normalize_message/2*</a></td><td>Augment the message with from-* keys, if it doesn't already have them.</td></tr><tr><td valign="top"><a href="#parse_redirect-1">parse_redirect/1*</a></td><td></td></tr><tr><td valign="top"><a href="#ping_pong_script-1">ping_pong_script/1*</a></td><td></td></tr><tr><td valign="top"><a href="#push-3">push/3</a></td><td>Push either a message or an assigned slot number.</td></tr><tr><td valign="top"><a href="#push_prompts_encoding_change_test-0">push_prompts_encoding_change_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#push_result_message-5">push_result_message/5*</a></td><td></td></tr><tr><td valign="top"><a href="#push_with_mode-3">push_with_mode/3*</a></td><td></td></tr><tr><td valign="top"><a href="#push_with_redirect_hint_test_disabled-0">push_with_redirect_hint_test_disabled/0*</a></td><td></td></tr><tr><td valign="top"><a href="#remote_schedule_result-3">remote_schedule_result/3*</a></td><td></td></tr><tr><td valign="top"><a href="#reply_script-0">reply_script/0*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_initial_message-3">schedule_initial_message/3*</a></td><td>Push a message or a process, prior to pushing the resulting slot number.</td></tr><tr><td valign="top"><a href="#schedule_result-3">schedule_result/3*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule_result-4">schedule_result/4*</a></td><td></td></tr><tr><td valign="top"><a href="#split_target-1">split_target/1*</a></td><td></td></tr><tr><td valign="top"><a href="#target_process-2">target_process/2*</a></td><td>Find the target process ID for a message to push.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="additional_keys-3"></a>

### additional_keys/3 * ###

`additional_keys(FromMsg, ToSched, Opts) -> any()`

Set the necessary keys in order for the recipient to know where the
message came from.

<a name="do_push-3"></a>

### do_push/3 * ###

`do_push(Base, Assignment, Opts) -> any()`

Push a message or slot number.

<a name="extract-2"></a>

### extract/2 * ###

`extract(X1, Raw) -> any()`

Return either the `target` or the `hint`.

<a name="find_type-2"></a>

### find_type/2 * ###

`find_type(Req, Opts) -> any()`

<a name="full_push_test_-0"></a>

### full_push_test_/0 * ###

`full_push_test_() -> any()`

<a name="is_async-3"></a>

### is_async/3 * ###

`is_async(Base, Req, Opts) -> any()`

Determine if the push is asynchronous.

<a name="multi_process_push_test_disabled-0"></a>

### multi_process_push_test_disabled/0 * ###

`multi_process_push_test_disabled() -> any()`

<a name="normalize_message-2"></a>

### normalize_message/2 * ###

`normalize_message(MsgToPush, Opts) -> any()`

Augment the message with from-* keys, if it doesn't already have them.

<a name="parse_redirect-1"></a>

### parse_redirect/1 * ###

`parse_redirect(Location) -> any()`

<a name="ping_pong_script-1"></a>

### ping_pong_script/1 * ###

`ping_pong_script(Limit) -> any()`

<a name="push-3"></a>

### push/3 ###

`push(Base, Req, Opts) -> any()`

Push either a message or an assigned slot number.

<a name="push_prompts_encoding_change_test-0"></a>

### push_prompts_encoding_change_test/0 * ###

`push_prompts_encoding_change_test() -> any()`

<a name="push_result_message-5"></a>

### push_result_message/5 * ###

`push_result_message(Base, FromSlot, Key, MsgToPush, Opts) -> any()`

<a name="push_with_mode-3"></a>

### push_with_mode/3 * ###

`push_with_mode(Base, Req, Opts) -> any()`

<a name="push_with_redirect_hint_test_disabled-0"></a>

### push_with_redirect_hint_test_disabled/0 * ###

`push_with_redirect_hint_test_disabled() -> any()`

<a name="remote_schedule_result-3"></a>

### remote_schedule_result/3 * ###

`remote_schedule_result(Location, SignedReq, Opts) -> any()`

<a name="reply_script-0"></a>

### reply_script/0 * ###

`reply_script() -> any()`

<a name="schedule_initial_message-3"></a>

### schedule_initial_message/3 * ###

`schedule_initial_message(Base, Req, Opts) -> any()`

Push a message or a process, prior to pushing the resulting slot number.

<a name="schedule_result-3"></a>

### schedule_result/3 * ###

`schedule_result(Base, MsgToPush, Opts) -> any()`

<a name="schedule_result-4"></a>

### schedule_result/4 * ###

`schedule_result(Base, MsgToPush, Codec, Opts) -> any()`

<a name="split_target-1"></a>

### split_target/1 * ###

`split_target(RawTarget) -> any()`

<a name="target_process-2"></a>

### target_process/2 * ###

`target_process(MsgToPush, Opts) -> any()`

Find the target process ID for a message to push.


--- END OF FILE: docs/resources/source-code/dev_push.md ---

--- START OF FILE: docs/resources/source-code/dev_relay.md ---
# [Module dev_relay.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_relay.erl)




This module implements the relay device, which is responsible for
relaying messages between nodes and other HTTP(S) endpoints.

<a name="description"></a>

## Description ##

It can be called in either `call` or `cast` mode. In `call` mode, it
returns a `{ok, Result}` tuple, where `Result` is the response from the
remote peer to the message sent. In `cast` mode, the invocation returns
immediately, and the message is relayed asynchronously. No response is given
and the device returns `{ok, <<"OK">>}`.

Example usage:

```

       curl /~relay@.1.0/call?method=GET?0.path=https://www.arweave.net/
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#call-3">call/3</a></td><td>Execute a <code>call</code> request using a node's routes.</td></tr><tr><td valign="top"><a href="#call_get_test-0">call_get_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#cast-3">cast/3</a></td><td>Execute a request in the same way as <code>call/3</code>, but asynchronously.</td></tr><tr><td valign="top"><a href="#preprocess-3">preprocess/3</a></td><td>Preprocess a request to check if it should be relayed to a different node.</td></tr><tr><td valign="top"><a href="#preprocessor_reroute_to_nearest_test-0">preprocessor_reroute_to_nearest_test/0*</a></td><td>Test that the <code>preprocess/3</code> function re-routes a request to remote
peers, according to the node's routing table.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="call-3"></a>

### call/3 ###

`call(M1, RawM2, Opts) -> any()`

Execute a `call` request using a node's routes.

Supports the following options:
- `target`: The target message to relay. Defaults to the original message.
- `relay-path`: The path to relay the message to. Defaults to the original path.
- `method`: The method to use for the request. Defaults to the original method.
- `requires-sign`: Whether the request requires signing before dispatching.
Defaults to `false`.

<a name="call_get_test-0"></a>

### call_get_test/0 * ###

`call_get_test() -> any()`

<a name="cast-3"></a>

### cast/3 ###

`cast(M1, M2, Opts) -> any()`

Execute a request in the same way as `call/3`, but asynchronously. Always
returns `<<"OK">>`.

<a name="preprocess-3"></a>

### preprocess/3 ###

`preprocess(Msg1, Msg2, Opts) -> any()`

Preprocess a request to check if it should be relayed to a different node.

<a name="preprocessor_reroute_to_nearest_test-0"></a>

### preprocessor_reroute_to_nearest_test/0 * ###

`preprocessor_reroute_to_nearest_test() -> any()`

Test that the `preprocess/3` function re-routes a request to remote
peers, according to the node's routing table.


--- END OF FILE: docs/resources/source-code/dev_relay.md ---

--- START OF FILE: docs/resources/source-code/dev_router.md ---
# [Module dev_router.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_router.erl)




A device that routes outbound messages from the node to their
appropriate network recipients via HTTP.

<a name="description"></a>

## Description ##

All messages are initially
routed to a single process per node, which then load-balances them
between downstream workers that perform the actual requests.

The routes for the router are defined in the `routes` key of the `Opts`,
as a precidence-ordered list of maps. The first map that matches the
message will be used to determine the route.

Multiple nodes can be specified as viable for a single route, with the
`Choose` key determining how many nodes to choose from the list (defaulting
to 1). The `Strategy` key determines the load distribution strategy,
which can be one of `Random`, `By-Base`, or `Nearest`. The route may also
define additional parallel execution parameters, which are used by the
`hb_http` module to manage control of requests.

The structure of the routes should be as follows:

```

       Node?: The node to route the message to.
       Nodes?: A list of nodes to route the message to.
       Strategy?: The load distribution strategy to use.
       Choose?: The number of nodes to choose from the list.
       Template?: A message template to match the message against, either as a
                  map or a path regex.
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_route_test-0">add_route_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#apply_route-2">apply_route/2*</a></td><td>Apply a node map's rules for transforming the path of the message.</td></tr><tr><td valign="top"><a href="#apply_routes-3">apply_routes/3*</a></td><td>Generate a <code>uri</code> key for each node in a route.</td></tr><tr><td valign="top"><a href="#binary_to_bignum-1">binary_to_bignum/1*</a></td><td>Cast a human-readable or native-encoded ID to a big integer.</td></tr><tr><td valign="top"><a href="#by_base_determinism_test-0">by_base_determinism_test/0*</a></td><td>Ensure that <code>By-Base</code> always chooses the same node for the same
hashpath.</td></tr><tr><td valign="top"><a href="#choose-5">choose/5*</a></td><td>Implements the load distribution strategies if given a cluster.</td></tr><tr><td valign="top"><a href="#choose_1_test-1">choose_1_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#choose_n_test-1">choose_n_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#device_call_from_singleton_test-0">device_call_from_singleton_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#dynamic_route_provider_test-0">dynamic_route_provider_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#dynamic_router_test-0">dynamic_router_test/0*</a></td><td>Example of a Lua script being used as the <code>route_provider</code> for a
HyperBEAM node.</td></tr><tr><td valign="top"><a href="#dynamic_routing_by_performance-0">dynamic_routing_by_performance/0*</a></td><td></td></tr><tr><td valign="top"><a href="#dynamic_routing_by_performance_test_-0">dynamic_routing_by_performance_test_/0*</a></td><td>Demonstrates routing tables being dynamically created and adjusted
according to the real-time performance of nodes.</td></tr><tr><td valign="top"><a href="#explicit_route_test-0">explicit_route_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#extract_base-2">extract_base/2*</a></td><td>Extract the base message ID from a request message.</td></tr><tr><td valign="top"><a href="#field_distance-2">field_distance/2*</a></td><td>Calculate the minimum distance between two numbers
(either progressing backwards or forwards), assuming a
256-bit field.</td></tr><tr><td valign="top"><a href="#find_target_path-2">find_target_path/2*</a></td><td>Find the target path to route for a request message.</td></tr><tr><td valign="top"><a href="#generate_hashpaths-1">generate_hashpaths/1*</a></td><td></td></tr><tr><td valign="top"><a href="#generate_nodes-1">generate_nodes/1*</a></td><td></td></tr><tr><td valign="top"><a href="#get_routes_test-0">get_routes_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#is_relevant-3">is_relevant/3</a></td><td>is_relevant looks at the relevant_routes paths opt and if any incoming message path matches it will
make the request relevant for preprocessing.</td></tr><tr><td valign="top"><a href="#load_routes-1">load_routes/1*</a></td><td>Load the current routes for the node.</td></tr><tr><td valign="top"><a href="#local_dynamic_router_test-0">local_dynamic_router_test/0*</a></td><td>Example of a Lua script being used as the <code>route_provider</code> for a
HyperBEAM node.</td></tr><tr><td valign="top"><a href="#local_process_route_provider_test-0">local_process_route_provider_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#lowest_distance-1">lowest_distance/1*</a></td><td>Find the node with the lowest distance to the given hashpath.</td></tr><tr><td valign="top"><a href="#lowest_distance-2">lowest_distance/2*</a></td><td></td></tr><tr><td valign="top"><a href="#match-3">match/3</a></td><td>Find the first matching template in a list of known routes.</td></tr><tr><td valign="top"><a href="#match_routes-3">match_routes/3*</a></td><td></td></tr><tr><td valign="top"><a href="#match_routes-4">match_routes/4*</a></td><td></td></tr><tr><td valign="top"><a href="#preprocess-3">preprocess/3</a></td><td>Preprocess a request to check if it should be relayed to a different node.</td></tr><tr><td valign="top"><a href="#register-3">register/3</a></td><td></td></tr><tr><td valign="top"><a href="#relay_nearest_test-0">relay_nearest_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#route-2">route/2</a></td><td>Find the appropriate route for the given message.</td></tr><tr><td valign="top"><a href="#route-3">route/3</a></td><td></td></tr><tr><td valign="top"><a href="#route_provider_test-0">route_provider_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#route_regex_matches_test-0">route_regex_matches_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#route_template_message_matches_test-0">route_template_message_matches_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#routes-3">routes/3</a></td><td>Device function that returns all known routes.</td></tr><tr><td valign="top"><a href="#simulate-4">simulate/4*</a></td><td></td></tr><tr><td valign="top"><a href="#simulation_distribution-2">simulation_distribution/2*</a></td><td></td></tr><tr><td valign="top"><a href="#simulation_occurences-2">simulation_occurences/2*</a></td><td></td></tr><tr><td valign="top"><a href="#strategy_suite_test_-0">strategy_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#template_matches-3">template_matches/3*</a></td><td>Check if a message matches a message template or path regex.</td></tr><tr><td valign="top"><a href="#unique_nodes-1">unique_nodes/1*</a></td><td></td></tr><tr><td valign="top"><a href="#unique_test-1">unique_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#weighted_random_strategy_test-0">weighted_random_strategy_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#within_norms-3">within_norms/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_route_test-0"></a>

### add_route_test/0 * ###

`add_route_test() -> any()`

<a name="apply_route-2"></a>

### apply_route/2 * ###

`apply_route(Msg, Route) -> any()`

Apply a node map's rules for transforming the path of the message.
Supports the following keys:
- `opts`: A map of options to pass to the request.
- `prefix`: The prefix to add to the path.
- `suffix`: The suffix to add to the path.
- `replace`: A regex to replace in the path.

<a name="apply_routes-3"></a>

### apply_routes/3 * ###

`apply_routes(Msg, R, Opts) -> any()`

Generate a `uri` key for each node in a route.

<a name="binary_to_bignum-1"></a>

### binary_to_bignum/1 * ###

`binary_to_bignum(Bin) -> any()`

Cast a human-readable or native-encoded ID to a big integer.

<a name="by_base_determinism_test-0"></a>

### by_base_determinism_test/0 * ###

`by_base_determinism_test() -> any()`

Ensure that `By-Base` always chooses the same node for the same
hashpath.

<a name="choose-5"></a>

### choose/5 * ###

`choose(N, X2, Hashpath, Nodes, Opts) -> any()`

Implements the load distribution strategies if given a cluster.

<a name="choose_1_test-1"></a>

### choose_1_test/1 * ###

`choose_1_test(Strategy) -> any()`

<a name="choose_n_test-1"></a>

### choose_n_test/1 * ###

`choose_n_test(Strategy) -> any()`

<a name="device_call_from_singleton_test-0"></a>

### device_call_from_singleton_test/0 * ###

`device_call_from_singleton_test() -> any()`

<a name="dynamic_route_provider_test-0"></a>

### dynamic_route_provider_test/0 * ###

`dynamic_route_provider_test() -> any()`

<a name="dynamic_router_test-0"></a>

### dynamic_router_test/0 * ###

`dynamic_router_test() -> any()`

Example of a Lua script being used as the `route_provider` for a
HyperBEAM node. The script utilized in this example dynamically adjusts the
likelihood of routing to a given node, depending upon price and performance.
also include preprocessing support for routing

<a name="dynamic_routing_by_performance-0"></a>

### dynamic_routing_by_performance/0 * ###

`dynamic_routing_by_performance() -> any()`

<a name="dynamic_routing_by_performance_test_-0"></a>

### dynamic_routing_by_performance_test_/0 * ###

`dynamic_routing_by_performance_test_() -> any()`

Demonstrates routing tables being dynamically created and adjusted
according to the real-time performance of nodes. This test utilizes the
`dynamic-router` script to manage routes and recalculate weights based on the
reported performance.

<a name="explicit_route_test-0"></a>

### explicit_route_test/0 * ###

`explicit_route_test() -> any()`

<a name="extract_base-2"></a>

### extract_base/2 * ###

`extract_base(RawPath, Opts) -> any()`

Extract the base message ID from a request message. Produces a single
binary ID that can be used for routing decisions.

<a name="field_distance-2"></a>

### field_distance/2 * ###

`field_distance(A, B) -> any()`

Calculate the minimum distance between two numbers
(either progressing backwards or forwards), assuming a
256-bit field.

<a name="find_target_path-2"></a>

### find_target_path/2 * ###

`find_target_path(Msg, Opts) -> any()`

Find the target path to route for a request message.

<a name="generate_hashpaths-1"></a>

### generate_hashpaths/1 * ###

`generate_hashpaths(Runs) -> any()`

<a name="generate_nodes-1"></a>

### generate_nodes/1 * ###

`generate_nodes(N) -> any()`

<a name="get_routes_test-0"></a>

### get_routes_test/0 * ###

`get_routes_test() -> any()`

<a name="is_relevant-3"></a>

### is_relevant/3 ###

`is_relevant(Msg1, Msg2, Opts) -> any()`

is_relevant looks at the relevant_routes paths opt and if any incoming message path matches it will
make the request relevant for preprocessing.

<a name="load_routes-1"></a>

### load_routes/1 * ###

`load_routes(Opts) -> any()`

Load the current routes for the node. Allows either explicit routes from
the node message's `routes` key, or dynamic routes generated by resolving the
`route_provider` message.

<a name="local_dynamic_router_test-0"></a>

### local_dynamic_router_test/0 * ###

`local_dynamic_router_test() -> any()`

Example of a Lua script being used as the `route_provider` for a
HyperBEAM node. The script utilized in this example dynamically adjusts the
likelihood of routing to a given node, depending upon price and performance.

<a name="local_process_route_provider_test-0"></a>

### local_process_route_provider_test/0 * ###

`local_process_route_provider_test() -> any()`

<a name="lowest_distance-1"></a>

### lowest_distance/1 * ###

`lowest_distance(Nodes) -> any()`

Find the node with the lowest distance to the given hashpath.

<a name="lowest_distance-2"></a>

### lowest_distance/2 * ###

`lowest_distance(Nodes, X) -> any()`

<a name="match-3"></a>

### match/3 ###

`match(Base, Req, Opts) -> any()`

Find the first matching template in a list of known routes. Allows the
path to be specified by either the explicit `path` (for internal use by this
module), or `route-path` for use by external devices and users.

<a name="match_routes-3"></a>

### match_routes/3 * ###

`match_routes(ToMatch, Routes, Opts) -> any()`

<a name="match_routes-4"></a>

### match_routes/4 * ###

`match_routes(ToMatch, Routes, Keys, Opts) -> any()`

<a name="preprocess-3"></a>

### preprocess/3 ###

`preprocess(Msg1, Msg2, Opts) -> any()`

Preprocess a request to check if it should be relayed to a different node.

<a name="register-3"></a>

### register/3 ###

`register(M1, M2, Opts) -> any()`

<a name="relay_nearest_test-0"></a>

### relay_nearest_test/0 * ###

`relay_nearest_test() -> any()`

<a name="route-2"></a>

### route/2 ###

`route(Msg, Opts) -> any()`

Find the appropriate route for the given message. If we are able to
resolve to a single host+path, we return that directly. Otherwise, we return
the matching route (including a list of nodes under `nodes`) from the list of
routes.

If we have a route that has multiple resolving nodes, check
the load distribution strategy and choose a node. Supported strategies:

```

            All: Return all nodes (default).
         Random: Distribute load evenly across all nodes, non-deterministically.
        By-Base: According to the base message's hashpath.
      By-Weight: According to the node's <code>weight</code> key.
        Nearest: According to the distance of the node's wallet address to the
                 base message's hashpath.
```

`By-Base` will ensure that all traffic for the same hashpath is routed to the
same node, minimizing work duplication, while `Random` ensures a more even
distribution of the requests.

Can operate as a `~router@1.0` device, which will ignore the base message,
routing based on the Opts and request message provided, or as a standalone
function, taking only the request message and the `Opts` map.

<a name="route-3"></a>

### route/3 ###

`route(X1, Msg, Opts) -> any()`

<a name="route_provider_test-0"></a>

### route_provider_test/0 * ###

`route_provider_test() -> any()`

<a name="route_regex_matches_test-0"></a>

### route_regex_matches_test/0 * ###

`route_regex_matches_test() -> any()`

<a name="route_template_message_matches_test-0"></a>

### route_template_message_matches_test/0 * ###

`route_template_message_matches_test() -> any()`

<a name="routes-3"></a>

### routes/3 ###

`routes(M1, M2, Opts) -> any()`

Device function that returns all known routes.

<a name="simulate-4"></a>

### simulate/4 * ###

`simulate(Runs, ChooseN, Nodes, Strategy) -> any()`

<a name="simulation_distribution-2"></a>

### simulation_distribution/2 * ###

`simulation_distribution(SimRes, Nodes) -> any()`

<a name="simulation_occurences-2"></a>

### simulation_occurences/2 * ###

`simulation_occurences(SimRes, Nodes) -> any()`

<a name="strategy_suite_test_-0"></a>

### strategy_suite_test_/0 * ###

`strategy_suite_test_() -> any()`

<a name="template_matches-3"></a>

### template_matches/3 * ###

`template_matches(ToMatch, Template, Opts) -> any()`

Check if a message matches a message template or path regex.

<a name="unique_nodes-1"></a>

### unique_nodes/1 * ###

`unique_nodes(Simulation) -> any()`

<a name="unique_test-1"></a>

### unique_test/1 * ###

`unique_test(Strategy) -> any()`

<a name="weighted_random_strategy_test-0"></a>

### weighted_random_strategy_test/0 * ###

`weighted_random_strategy_test() -> any()`

<a name="within_norms-3"></a>

### within_norms/3 * ###

`within_norms(SimRes, Nodes, TestSize) -> any()`


--- END OF FILE: docs/resources/source-code/dev_router.md ---

--- START OF FILE: docs/resources/source-code/dev_scheduler_cache.md ---
# [Module dev_scheduler_cache.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_scheduler_cache.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#latest-2">latest/2</a></td><td>Get the latest assignment from the cache.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td>Get the assignments for a process.</td></tr><tr><td valign="top"><a href="#read-3">read/3</a></td><td>Get an assignment message from the cache.</td></tr><tr><td valign="top"><a href="#read_location-2">read_location/2</a></td><td>Read the latest known scheduler location for an address.</td></tr><tr><td valign="top"><a href="#write-2">write/2</a></td><td>Write an assignment message into the cache.</td></tr><tr><td valign="top"><a href="#write_location-2">write_location/2</a></td><td>Write the latest known scheduler location for an address.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="latest-2"></a>

### latest/2 ###

`latest(ProcID, Opts) -> any()`

Get the latest assignment from the cache.

<a name="list-2"></a>

### list/2 ###

`list(ProcID, Opts) -> any()`

Get the assignments for a process.

<a name="read-3"></a>

### read/3 ###

`read(ProcID, Slot, Opts) -> any()`

Get an assignment message from the cache.

<a name="read_location-2"></a>

### read_location/2 ###

`read_location(Address, Opts) -> any()`

Read the latest known scheduler location for an address.

<a name="write-2"></a>

### write/2 ###

`write(Assignment, Opts) -> any()`

Write an assignment message into the cache.

<a name="write_location-2"></a>

### write_location/2 ###

`write_location(LocationMsg, Opts) -> any()`

Write the latest known scheduler location for an address.


--- END OF FILE: docs/resources/source-code/dev_scheduler_cache.md ---

--- START OF FILE: docs/resources/source-code/dev_scheduler_formats.md ---
# [Module dev_scheduler_formats.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_scheduler_formats.erl)




This module is used by dev_scheduler in order to produce outputs that
are compatible with various forms of AO clients.

<a name="description"></a>

## Description ##

It features two main formats:

- `application/json`
- `application/http`

The `application/json` format is a legacy format that is not recommended for
new integrations of the AO protocol.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#aos2_normalize_data-1">aos2_normalize_data/1*</a></td><td>The <code>hb_gateway_client</code> module expects all JSON structures to at least
have a <code>data</code> field.</td></tr><tr><td valign="top"><a href="#aos2_normalize_types-1">aos2_normalize_types/1</a></td><td>Normalize an AOS2 formatted message to ensure that all field NAMES and
types are correct.</td></tr><tr><td valign="top"><a href="#aos2_to_assignment-2">aos2_to_assignment/2</a></td><td>Create and normalize an assignment from an AOS2-style JSON structure.</td></tr><tr><td valign="top"><a href="#aos2_to_assignments-3">aos2_to_assignments/3</a></td><td>Convert an AOS2-style JSON structure to a normalized HyperBEAM
assignments response.</td></tr><tr><td valign="top"><a href="#assignment_to_aos2-2">assignment_to_aos2/2*</a></td><td>Convert an assignment to an AOS2-compatible JSON structure.</td></tr><tr><td valign="top"><a href="#assignments_to_aos2-4">assignments_to_aos2/4</a></td><td></td></tr><tr><td valign="top"><a href="#assignments_to_bundle-4">assignments_to_bundle/4</a></td><td>Generate a <code>GET /schedule</code> response for a process as HTTP-sig bundles.</td></tr><tr><td valign="top"><a href="#assignments_to_bundle-5">assignments_to_bundle/5*</a></td><td></td></tr><tr><td valign="top"><a href="#cursor-2">cursor/2*</a></td><td>Generate a cursor for an assignment.</td></tr><tr><td valign="top"><a href="#format_opts-1">format_opts/1*</a></td><td>For all scheduler format operations, we do not calculate hashpaths,
perform cache lookups, or await inprogress results.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="aos2_normalize_data-1"></a>

### aos2_normalize_data/1 * ###

`aos2_normalize_data(JSONStruct) -> any()`

The `hb_gateway_client` module expects all JSON structures to at least
have a `data` field. This function ensures that.

<a name="aos2_normalize_types-1"></a>

### aos2_normalize_types/1 ###

`aos2_normalize_types(Msg) -> any()`

Normalize an AOS2 formatted message to ensure that all field NAMES and
types are correct. This involves converting field names to integers and
specific field names to their canonical form.
NOTE: This will result in a message that is not verifiable! It is, however,
necessary for gaining compatibility with the AOS2-style scheduling API.

<a name="aos2_to_assignment-2"></a>

### aos2_to_assignment/2 ###

`aos2_to_assignment(A, RawOpts) -> any()`

Create and normalize an assignment from an AOS2-style JSON structure.
NOTE: This method is destructive to the verifiability of the assignment.

<a name="aos2_to_assignments-3"></a>

### aos2_to_assignments/3 ###

`aos2_to_assignments(ProcID, Body, RawOpts) -> any()`

Convert an AOS2-style JSON structure to a normalized HyperBEAM
assignments response.

<a name="assignment_to_aos2-2"></a>

### assignment_to_aos2/2 * ###

`assignment_to_aos2(Assignment, RawOpts) -> any()`

Convert an assignment to an AOS2-compatible JSON structure.

<a name="assignments_to_aos2-4"></a>

### assignments_to_aos2/4 ###

`assignments_to_aos2(ProcID, Assignments, More, RawOpts) -> any()`

<a name="assignments_to_bundle-4"></a>

### assignments_to_bundle/4 ###

`assignments_to_bundle(ProcID, Assignments, More, Opts) -> any()`

Generate a `GET /schedule` response for a process as HTTP-sig bundles.

<a name="assignments_to_bundle-5"></a>

### assignments_to_bundle/5 * ###

`assignments_to_bundle(ProcID, Assignments, More, TimeInfo, RawOpts) -> any()`

<a name="cursor-2"></a>

### cursor/2 * ###

`cursor(Assignment, RawOpts) -> any()`

Generate a cursor for an assignment. This should be the slot number, at
least in the case of mainnet `ao.N.1` assignments. In the case of legacynet
(`ao.TN.1`) assignments, we may want to use the assignment ID.

<a name="format_opts-1"></a>

### format_opts/1 * ###

`format_opts(Opts) -> any()`

For all scheduler format operations, we do not calculate hashpaths,
perform cache lookups, or await inprogress results.


--- END OF FILE: docs/resources/source-code/dev_scheduler_formats.md ---

--- START OF FILE: docs/resources/source-code/dev_scheduler_registry.md ---
# [Module dev_scheduler_registry.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_scheduler_registry.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#create_and_find_process_test-0">create_and_find_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#create_multiple_processes_test-0">create_multiple_processes_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#find-1">find/1</a></td><td>Find a process associated with the processor ID in the local registry
If the process is not found, it will not create a new one.</td></tr><tr><td valign="top"><a href="#find-2">find/2</a></td><td>Find a process associated with the processor ID in the local registry
If the process is not found and <code>GenIfNotHosted</code> is true, it attemps to create a new one.</td></tr><tr><td valign="top"><a href="#find-3">find/3</a></td><td>Same as <code>find/2</code> but with additional options passed when spawning a new process (if needed).</td></tr><tr><td valign="top"><a href="#find_non_existent_process_test-0">find_non_existent_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#get_all_processes_test-0">get_all_processes_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#get_processes-0">get_processes/0</a></td><td>Return a list of all currently registered ProcID.</td></tr><tr><td valign="top"><a href="#get_wallet-0">get_wallet/0</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_new_proc-3">maybe_new_proc/3*</a></td><td></td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="create_and_find_process_test-0"></a>

### create_and_find_process_test/0 * ###

`create_and_find_process_test() -> any()`

<a name="create_multiple_processes_test-0"></a>

### create_multiple_processes_test/0 * ###

`create_multiple_processes_test() -> any()`

<a name="find-1"></a>

### find/1 ###

`find(ProcID) -> any()`

Find a process associated with the processor ID in the local registry
If the process is not found, it will not create a new one

<a name="find-2"></a>

### find/2 ###

`find(ProcID, GenIfNotHosted) -> any()`

Find a process associated with the processor ID in the local registry
If the process is not found and `GenIfNotHosted` is true, it attemps to create a new one

<a name="find-3"></a>

### find/3 ###

`find(ProcID, GenIfNotHosted, Opts) -> any()`

Same as `find/2` but with additional options passed when spawning a new process (if needed)

<a name="find_non_existent_process_test-0"></a>

### find_non_existent_process_test/0 * ###

`find_non_existent_process_test() -> any()`

<a name="get_all_processes_test-0"></a>

### get_all_processes_test/0 * ###

`get_all_processes_test() -> any()`

<a name="get_processes-0"></a>

### get_processes/0 ###

`get_processes() -> any()`

Return a list of all currently registered ProcID.

<a name="get_wallet-0"></a>

### get_wallet/0 ###

`get_wallet() -> any()`

<a name="maybe_new_proc-3"></a>

### maybe_new_proc/3 * ###

`maybe_new_proc(ProcID, GenIfNotHosted, Opts) -> any()`

<a name="start-0"></a>

### start/0 ###

`start() -> any()`


--- END OF FILE: docs/resources/source-code/dev_scheduler_registry.md ---

--- START OF FILE: docs/resources/source-code/dev_scheduler_server.md ---
# [Module dev_scheduler_server.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_scheduler_server.erl)




A long-lived server that schedules messages for a process.

<a name="description"></a>

## Description ##
It acts as a deliberate 'bottleneck' to prevent the server accidentally
assigning multiple messages to the same slot.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#assign-3">assign/3*</a></td><td>Assign a message to the next slot.</td></tr><tr><td valign="top"><a href="#do_assign-3">do_assign/3*</a></td><td>Generate and store the actual assignment message.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Get the current slot from the scheduling server.</td></tr><tr><td valign="top"><a href="#maybe_inform_recipient-5">maybe_inform_recipient/5*</a></td><td></td></tr><tr><td valign="top"><a href="#new_proc_test_-0">new_proc_test_/0*</a></td><td>Test the basic functionality of the server.</td></tr><tr><td valign="top"><a href="#next_hashchain-2">next_hashchain/2*</a></td><td>Create the next element in a chain of hashes that links this and prior
assignments.</td></tr><tr><td valign="top"><a href="#schedule-2">schedule/2</a></td><td>Call the appropriate scheduling server to assign a message.</td></tr><tr><td valign="top"><a href="#server-1">server/1*</a></td><td>The main loop of the server.</td></tr><tr><td valign="top"><a href="#start-2">start/2</a></td><td>Start a scheduling server for a given computation.</td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="assign-3"></a>

### assign/3 * ###

`assign(State, Message, ReplyPID) -> any()`

Assign a message to the next slot.

<a name="do_assign-3"></a>

### do_assign/3 * ###

`do_assign(State, Message, ReplyPID) -> any()`

Generate and store the actual assignment message.

<a name="info-1"></a>

### info/1 ###

`info(ProcID) -> any()`

Get the current slot from the scheduling server.

<a name="maybe_inform_recipient-5"></a>

### maybe_inform_recipient/5 * ###

`maybe_inform_recipient(Mode, ReplyPID, Message, Assignment, State) -> any()`

<a name="new_proc_test_-0"></a>

### new_proc_test_/0 * ###

`new_proc_test_() -> any()`

Test the basic functionality of the server.

<a name="next_hashchain-2"></a>

### next_hashchain/2 * ###

`next_hashchain(HashChain, Message) -> any()`

Create the next element in a chain of hashes that links this and prior
assignments.

<a name="schedule-2"></a>

### schedule/2 ###

`schedule(AOProcID, Message) -> any()`

Call the appropriate scheduling server to assign a message.

<a name="server-1"></a>

### server/1 * ###

`server(State) -> any()`

The main loop of the server. Simply waits for messages to assign and
returns the current slot.

<a name="start-2"></a>

### start/2 ###

`start(ProcID, Opts) -> any()`

Start a scheduling server for a given computation.

<a name="stop-1"></a>

### stop/1 ###

`stop(ProcID) -> any()`


--- END OF FILE: docs/resources/source-code/dev_scheduler_server.md ---

--- START OF FILE: docs/resources/source-code/dev_scheduler.md ---
# [Module dev_scheduler.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_scheduler.erl)




A simple scheduler scheme for AO.

<a name="description"></a>

## Description ##
This device expects a message of the form:
Process: `#{ id, Scheduler: #{ Authority } }`

```

   It exposes the following keys for scheduling:<code>#{ method: GET, path: <<"/info">> }</code> ->
           Returns information about the scheduler.<code>#{ method: GET, path: <<"/slot">> }</code> -> <code>slot(Msg1, Msg2, Opts)</code>
           Returns the current slot for a process.<code>#{ method: GET, path: <<"/schedule">> }</code> -> <code>get_schedule(Msg1, Msg2, Opts)</code>
           Returns the schedule for a process in a cursor-traversable format.<code>#{ method: POST, path: <<"/schedule">> }</code> -> <code>post_schedule(Msg1, Msg2, Opts)</code>
           Schedules a new message for a process, or starts a new scheduler
           for the given message.
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#benchmark_suite-2">benchmark_suite/2*</a></td><td></td></tr><tr><td valign="top"><a href="#benchmark_suite_test_-0">benchmark_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#cache_remote_schedule-2">cache_remote_schedule/2*</a></td><td>Cache a schedule received from a remote scheduler.</td></tr><tr><td valign="top"><a href="#check_lookahead_and_local_cache-4">check_lookahead_and_local_cache/4*</a></td><td>Check if we have a result from a lookahead worker or from our local
cache.</td></tr><tr><td valign="top"><a href="#checkpoint-1">checkpoint/1</a></td><td>Returns the current state of the scheduler.</td></tr><tr><td valign="top"><a href="#do_get_remote_schedule-6">do_get_remote_schedule/6*</a></td><td>Get a schedule from a remote scheduler, unless we already have already
read all of the assignments from the local cache.</td></tr><tr><td valign="top"><a href="#do_post_schedule-4">do_post_schedule/4*</a></td><td>Post schedule the message.</td></tr><tr><td valign="top"><a href="#filter_json_assignments-3">filter_json_assignments/3*</a></td><td>Filter JSON assignment results from a remote legacy scheduler.</td></tr><tr><td valign="top"><a href="#find_message_to_schedule-3">find_message_to_schedule/3*</a></td><td>Search the given base and request message pair to find the message to
schedule.</td></tr><tr><td valign="top"><a href="#find_remote_scheduler-3">find_remote_scheduler/3*</a></td><td>Use the SchedulerLocation to the remote path and return a redirect.</td></tr><tr><td valign="top"><a href="#find_server-3">find_server/3*</a></td><td>Locate the correct scheduling server for a given process.</td></tr><tr><td valign="top"><a href="#find_server-4">find_server/4*</a></td><td></td></tr><tr><td valign="top"><a href="#find_target_id-3">find_target_id/3*</a></td><td>Find the schedule ID from a given request.</td></tr><tr><td valign="top"><a href="#generate_local_schedule-5">generate_local_schedule/5*</a></td><td>Generate a <code>GET /schedule</code> response for a process.</td></tr><tr><td valign="top"><a href="#generate_redirect-3">generate_redirect/3*</a></td><td>Generate a redirect message to a scheduler.</td></tr><tr><td valign="top"><a href="#get_hint-2">get_hint/2*</a></td><td>If a hint is present in the string, return it.</td></tr><tr><td valign="top"><a href="#get_local_assignments-4">get_local_assignments/4*</a></td><td>Get the assignments for a process, and whether the request was truncated.</td></tr><tr><td valign="top"><a href="#get_local_schedule_test-0">get_local_schedule_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#get_remote_schedule-5">get_remote_schedule/5*</a></td><td>Get a schedule from a remote scheduler, but first read all of the
assignments from the local cache that we already know about.</td></tr><tr><td valign="top"><a href="#get_schedule-3">get_schedule/3*</a></td><td>Generate and return a schedule for a process, optionally between
two slots -- labelled as <code>from</code> and <code>to</code>.</td></tr><tr><td valign="top"><a href="#http_get_json_schedule_test_-0">http_get_json_schedule_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_legacy_schedule_as_aos2_test_-0">http_get_legacy_schedule_as_aos2_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_legacy_schedule_slot_range_test_-0">http_get_legacy_schedule_slot_range_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_legacy_schedule_test_-0">http_get_legacy_schedule_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_legacy_slot_test_-0">http_get_legacy_slot_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_schedule-4">http_get_schedule/4*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_schedule-5">http_get_schedule/5*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_schedule_redirect_test-0">http_get_schedule_redirect_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_schedule_test_-0">http_get_schedule_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_get_slot-2">http_get_slot/2*</a></td><td></td></tr><tr><td valign="top"><a href="#http_init-0">http_init/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_init-1">http_init/1*</a></td><td></td></tr><tr><td valign="top"><a href="#http_post_legacy_schedule_test_-0">http_post_legacy_schedule_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_post_schedule_sign-4">http_post_schedule_sign/4*</a></td><td></td></tr><tr><td valign="top"><a href="#http_post_schedule_test-0">http_post_schedule_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#info-0">info/0</a></td><td>This device uses a default_handler to route requests to the correct
function.</td></tr><tr><td valign="top"><a href="#many_clients-1">many_clients/1*</a></td><td></td></tr><tr><td valign="top"><a href="#message_cached_assignments-2">message_cached_assignments/2*</a></td><td>Non-device exported helper to get the cached assignments held in a
process.</td></tr><tr><td valign="top"><a href="#next-3">next/3</a></td><td>Load the schedule for a process into the cache, then return the next
assignment.</td></tr><tr><td valign="top"><a href="#node_from_redirect-2">node_from_redirect/2*</a></td><td>Get the node URL from a redirect.</td></tr><tr><td valign="top"><a href="#post_legacy_schedule-4">post_legacy_schedule/4*</a></td><td></td></tr><tr><td valign="top"><a href="#post_remote_schedule-4">post_remote_schedule/4*</a></td><td></td></tr><tr><td valign="top"><a href="#post_schedule-3">post_schedule/3*</a></td><td>Schedules a new message on the SU.</td></tr><tr><td valign="top"><a href="#read_local_assignments-4">read_local_assignments/4*</a></td><td>Get the assignments for a process.</td></tr><tr><td valign="top"><a href="#redirect_from_graphql_test-0">redirect_from_graphql_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#redirect_to_hint_test-0">redirect_to_hint_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#register-3">register/3</a></td><td>Generate a new scheduler location record and register it.</td></tr><tr><td valign="top"><a href="#register_new_process_test-0">register_new_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#register_scheduler_test-0">register_scheduler_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#remote_slot-3">remote_slot/3*</a></td><td>Get the current slot from a remote scheduler.</td></tr><tr><td valign="top"><a href="#remote_slot-4">remote_slot/4*</a></td><td>Get the current slot from a remote scheduler, based on the variant of
the process's scheduler.</td></tr><tr><td valign="top"><a href="#router-4">router/4</a></td><td>The default handler for the scheduler device.</td></tr><tr><td valign="top"><a href="#schedule-3">schedule/3</a></td><td>A router for choosing between getting the existing schedule, or
scheduling a new message.</td></tr><tr><td valign="top"><a href="#schedule_message_and_get_slot_test-0">schedule_message_and_get_slot_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#single_resolution-1">single_resolution/1*</a></td><td></td></tr><tr><td valign="top"><a href="#slot-3">slot/3</a></td><td>Returns information about the current slot for a process.</td></tr><tr><td valign="top"><a href="#spawn_lookahead_worker-3">spawn_lookahead_worker/3*</a></td><td>Spawn a new Erlang process to fetch the next assignments from the local
cache, if we have them available.</td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td>Helper to ensure that the environment is started.</td></tr><tr><td valign="top"><a href="#status-3">status/3</a></td><td>Returns information about the entire scheduler.</td></tr><tr><td valign="top"><a href="#status_test-0">status_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_process-0">test_process/0</a></td><td>Generate a _transformed_ process message, not as they are generated
by users.</td></tr><tr><td valign="top"><a href="#test_process-1">test_process/1*</a></td><td></td></tr><tr><td valign="top"><a href="#without_hint-1">without_hint/1*</a></td><td>Take a process ID or target with a potential hint and return just the
process ID.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="benchmark_suite-2"></a>

### benchmark_suite/2 * ###

`benchmark_suite(Port, Base) -> any()`

<a name="benchmark_suite_test_-0"></a>

### benchmark_suite_test_/0 * ###

`benchmark_suite_test_() -> any()`

<a name="cache_remote_schedule-2"></a>

### cache_remote_schedule/2 * ###

`cache_remote_schedule(Schedule, Opts) -> any()`

Cache a schedule received from a remote scheduler.

<a name="check_lookahead_and_local_cache-4"></a>

### check_lookahead_and_local_cache/4 * ###

`check_lookahead_and_local_cache(Msg1, ProcID, TargetSlot, Opts) -> any()`

Check if we have a result from a lookahead worker or from our local
cache. If we have a result in the local cache, we may also start a new
lookahead worker to fetch the next assignments if we have them locally,
ahead of time. This can be enabled/disabled with the `scheduler_lookahead`
option.

<a name="checkpoint-1"></a>

### checkpoint/1 ###

`checkpoint(State) -> any()`

Returns the current state of the scheduler.

<a name="do_get_remote_schedule-6"></a>

### do_get_remote_schedule/6 * ###

`do_get_remote_schedule(ProcID, LocalAssignments, From, To, Redirect, Opts) -> any()`

Get a schedule from a remote scheduler, unless we already have already
read all of the assignments from the local cache.

<a name="do_post_schedule-4"></a>

### do_post_schedule/4 * ###

`do_post_schedule(ProcID, PID, Msg2, Opts) -> any()`

Post schedule the message. `Msg2` by this point has been refined to only
committed keys, and to only include the `target` message that is to be
scheduled.

<a name="filter_json_assignments-3"></a>

### filter_json_assignments/3 * ###

`filter_json_assignments(JSONRes, To, From) -> any()`

Filter JSON assignment results from a remote legacy scheduler.

<a name="find_message_to_schedule-3"></a>

### find_message_to_schedule/3 * ###

`find_message_to_schedule(Msg1, Msg2, Opts) -> any()`

Search the given base and request message pair to find the message to
schedule. The precidence order for search is as follows:
1. `Msg2/body`
2. `Msg2`

<a name="find_remote_scheduler-3"></a>

### find_remote_scheduler/3 * ###

`find_remote_scheduler(ProcID, Scheduler, Opts) -> any()`

Use the SchedulerLocation to the remote path and return a redirect.

<a name="find_server-3"></a>

### find_server/3 * ###

`find_server(ProcID, Msg1, Opts) -> any()`

Locate the correct scheduling server for a given process.

<a name="find_server-4"></a>

### find_server/4 * ###

`find_server(ProcID, Msg1, ToSched, Opts) -> any()`

<a name="find_target_id-3"></a>

### find_target_id/3 * ###

`find_target_id(Msg1, Msg2, Opts) -> any()`

Find the schedule ID from a given request. The precidence order for
search is as follows:
[1. `ToSched/id` -- in the case of `POST schedule`, handled locally]
2. `Msg2/target`
3. `Msg2/id` when `Msg2` has `type: Process`
4. `Msg1/process/id`
5. `Msg1/id` when `Msg1` has `type: Process`
6. `Msg2/id`

<a name="generate_local_schedule-5"></a>

### generate_local_schedule/5 * ###

`generate_local_schedule(Format, ProcID, From, To, Opts) -> any()`

Generate a `GET /schedule` response for a process.

<a name="generate_redirect-3"></a>

### generate_redirect/3 * ###

`generate_redirect(ProcID, SchedulerLocation, Opts) -> any()`

Generate a redirect message to a scheduler.

<a name="get_hint-2"></a>

### get_hint/2 * ###

`get_hint(Str, Opts) -> any()`

If a hint is present in the string, return it. Else, return not_found.

<a name="get_local_assignments-4"></a>

### get_local_assignments/4 * ###

`get_local_assignments(ProcID, From, RequestedTo, Opts) -> any()`

Get the assignments for a process, and whether the request was truncated.

<a name="get_local_schedule_test-0"></a>

### get_local_schedule_test/0 * ###

`get_local_schedule_test() -> any()`

<a name="get_remote_schedule-5"></a>

### get_remote_schedule/5 * ###

`get_remote_schedule(RawProcID, From, To, Redirect, Opts) -> any()`

Get a schedule from a remote scheduler, but first read all of the
assignments from the local cache that we already know about.

<a name="get_schedule-3"></a>

### get_schedule/3 * ###

`get_schedule(Msg1, Msg2, Opts) -> any()`

Generate and return a schedule for a process, optionally between
two slots -- labelled as `from` and `to`. If the schedule is not local,
we redirect to the remote scheduler or proxy based on the node opts.

<a name="http_get_json_schedule_test_-0"></a>

### http_get_json_schedule_test_/0 * ###

`http_get_json_schedule_test_() -> any()`

<a name="http_get_legacy_schedule_as_aos2_test_-0"></a>

### http_get_legacy_schedule_as_aos2_test_/0 * ###

`http_get_legacy_schedule_as_aos2_test_() -> any()`

<a name="http_get_legacy_schedule_slot_range_test_-0"></a>

### http_get_legacy_schedule_slot_range_test_/0 * ###

`http_get_legacy_schedule_slot_range_test_() -> any()`

<a name="http_get_legacy_schedule_test_-0"></a>

### http_get_legacy_schedule_test_/0 * ###

`http_get_legacy_schedule_test_() -> any()`

<a name="http_get_legacy_slot_test_-0"></a>

### http_get_legacy_slot_test_/0 * ###

`http_get_legacy_slot_test_() -> any()`

<a name="http_get_schedule-4"></a>

### http_get_schedule/4 * ###

`http_get_schedule(N, PMsg, From, To) -> any()`

<a name="http_get_schedule-5"></a>

### http_get_schedule/5 * ###

`http_get_schedule(N, PMsg, From, To, Format) -> any()`

<a name="http_get_schedule_redirect_test-0"></a>

### http_get_schedule_redirect_test/0 * ###

`http_get_schedule_redirect_test() -> any()`

<a name="http_get_schedule_test_-0"></a>

### http_get_schedule_test_/0 * ###

`http_get_schedule_test_() -> any()`

<a name="http_get_slot-2"></a>

### http_get_slot/2 * ###

`http_get_slot(N, PMsg) -> any()`

<a name="http_init-0"></a>

### http_init/0 * ###

`http_init() -> any()`

<a name="http_init-1"></a>

### http_init/1 * ###

`http_init(Opts) -> any()`

<a name="http_post_legacy_schedule_test_-0"></a>

### http_post_legacy_schedule_test_/0 * ###

`http_post_legacy_schedule_test_() -> any()`

<a name="http_post_schedule_sign-4"></a>

### http_post_schedule_sign/4 * ###

`http_post_schedule_sign(Node, Msg, ProcessMsg, Wallet) -> any()`

<a name="http_post_schedule_test-0"></a>

### http_post_schedule_test/0 * ###

`http_post_schedule_test() -> any()`

<a name="info-0"></a>

### info/0 ###

`info() -> any()`

This device uses a default_handler to route requests to the correct
function.

<a name="many_clients-1"></a>

### many_clients/1 * ###

`many_clients(Opts) -> any()`

<a name="message_cached_assignments-2"></a>

### message_cached_assignments/2 * ###

`message_cached_assignments(Msg, Opts) -> any()`

Non-device exported helper to get the cached assignments held in a
process.

<a name="next-3"></a>

### next/3 ###

`next(Msg1, Msg2, Opts) -> any()`

Load the schedule for a process into the cache, then return the next
assignment. Assumes that Msg1 is a `dev_process` or similar message, having
a `Current-Slot` key. It stores a local cache of the schedule in the
`priv/To-Process` key.

<a name="node_from_redirect-2"></a>

### node_from_redirect/2 * ###

`node_from_redirect(Redirect, Opts) -> any()`

Get the node URL from a redirect.

<a name="post_legacy_schedule-4"></a>

### post_legacy_schedule/4 * ###

`post_legacy_schedule(ProcID, OnlyCommitted, Node, Opts) -> any()`

<a name="post_remote_schedule-4"></a>

### post_remote_schedule/4 * ###

`post_remote_schedule(RawProcID, Redirect, OnlyCommitted, Opts) -> any()`

<a name="post_schedule-3"></a>

### post_schedule/3 * ###

`post_schedule(Msg1, Msg2, Opts) -> any()`

Schedules a new message on the SU. Searches Msg1 for the appropriate ID,
then uses the wallet address of the scheduler to determine if the message is
for this scheduler. If so, it schedules the message and returns the assignment.

<a name="read_local_assignments-4"></a>

### read_local_assignments/4 * ###

`read_local_assignments(ProcID, From, To, Opts) -> any()`

Get the assignments for a process.

<a name="redirect_from_graphql_test-0"></a>

### redirect_from_graphql_test/0 * ###

`redirect_from_graphql_test() -> any()`

<a name="redirect_to_hint_test-0"></a>

### redirect_to_hint_test/0 * ###

`redirect_to_hint_test() -> any()`

<a name="register-3"></a>

### register/3 ###

`register(Msg1, Req, Opts) -> any()`

Generate a new scheduler location record and register it. We both send
the new scheduler-location to the given registry, and return it to the caller.

<a name="register_new_process_test-0"></a>

### register_new_process_test/0 * ###

`register_new_process_test() -> any()`

<a name="register_scheduler_test-0"></a>

### register_scheduler_test/0 * ###

`register_scheduler_test() -> any()`

<a name="remote_slot-3"></a>

### remote_slot/3 * ###

`remote_slot(ProcID, Redirect, Opts) -> any()`

Get the current slot from a remote scheduler.

<a name="remote_slot-4"></a>

### remote_slot/4 * ###

`remote_slot(X1, ProcID, Node, Opts) -> any()`

Get the current slot from a remote scheduler, based on the variant of
the process's scheduler.

<a name="router-4"></a>

### router/4 ###

`router(X1, Msg1, Msg2, Opts) -> any()`

The default handler for the scheduler device.

<a name="schedule-3"></a>

### schedule/3 ###

`schedule(Msg1, Msg2, Opts) -> any()`

A router for choosing between getting the existing schedule, or
scheduling a new message.

<a name="schedule_message_and_get_slot_test-0"></a>

### schedule_message_and_get_slot_test/0 * ###

`schedule_message_and_get_slot_test() -> any()`

<a name="single_resolution-1"></a>

### single_resolution/1 * ###

`single_resolution(Opts) -> any()`

<a name="slot-3"></a>

### slot/3 ###

`slot(M1, M2, Opts) -> any()`

Returns information about the current slot for a process.

<a name="spawn_lookahead_worker-3"></a>

### spawn_lookahead_worker/3 * ###

`spawn_lookahead_worker(ProcID, Slot, Opts) -> any()`

Spawn a new Erlang process to fetch the next assignments from the local
cache, if we have them available.

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

Helper to ensure that the environment is started.

<a name="status-3"></a>

### status/3 ###

`status(M1, M2, Opts) -> any()`

Returns information about the entire scheduler.

<a name="status_test-0"></a>

### status_test/0 * ###

`status_test() -> any()`

<a name="test_process-0"></a>

### test_process/0 ###

`test_process() -> any()`

Generate a _transformed_ process message, not as they are generated
by users. See `dev_process` for examples of AO process messages.

<a name="test_process-1"></a>

### test_process/1 * ###

`test_process(Wallet) -> any()`

<a name="without_hint-1"></a>

### without_hint/1 * ###

`without_hint(Target) -> any()`

Take a process ID or target with a potential hint and return just the
process ID.


--- END OF FILE: docs/resources/source-code/dev_scheduler.md ---

--- START OF FILE: docs/resources/source-code/dev_simple_pay.md ---
# [Module dev_simple_pay.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_simple_pay.erl)




A simple device that allows the operator to specify a price for a
request and then charge the user for it, on a per message basis.

<a name="description"></a>

## Description ##
The device's ledger is stored in the node message at `simple_pay_ledger`,
and can be topped-up by either the operator, or an external device. The
price is specified in the node message at `simple_pay_price`.
This device acts as both a pricing device and a ledger device, by p4's
definition.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#balance-3">balance/3</a></td><td>Get the balance of a user in the ledger.</td></tr><tr><td valign="top"><a href="#debit-3">debit/3</a></td><td>Preprocess a request by checking the ledger and charging the user.</td></tr><tr><td valign="top"><a href="#estimate-3">estimate/3</a></td><td>Estimate the cost of a request by counting the number of messages in
the request, then multiplying by the per-message price.</td></tr><tr><td valign="top"><a href="#get_balance-2">get_balance/2*</a></td><td>Get the balance of a user in the ledger.</td></tr><tr><td valign="top"><a href="#get_balance_and_top_up_test-0">get_balance_and_top_up_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#is_operator-2">is_operator/2*</a></td><td>Check if the request is from the operator.</td></tr><tr><td valign="top"><a href="#set_balance-3">set_balance/3*</a></td><td>Adjust a user's balance, normalizing their wallet ID first.</td></tr><tr><td valign="top"><a href="#test_opts-0">test_opts/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_opts-1">test_opts/1*</a></td><td></td></tr><tr><td valign="top"><a href="#topup-3">topup/3</a></td><td>Top up the user's balance in the ledger.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="balance-3"></a>

### balance/3 ###

`balance(X1, RawReq, NodeMsg) -> any()`

Get the balance of a user in the ledger.

<a name="debit-3"></a>

### debit/3 ###

`debit(X1, RawReq, NodeMsg) -> any()`

Preprocess a request by checking the ledger and charging the user. We
can charge the user at this stage because we know statically what the price
will be

<a name="estimate-3"></a>

### estimate/3 ###

`estimate(X1, EstimateReq, NodeMsg) -> any()`

Estimate the cost of a request by counting the number of messages in
the request, then multiplying by the per-message price. The operator does
not pay for their own requests.

<a name="get_balance-2"></a>

### get_balance/2 * ###

`get_balance(Signer, NodeMsg) -> any()`

Get the balance of a user in the ledger.

<a name="get_balance_and_top_up_test-0"></a>

### get_balance_and_top_up_test/0 * ###

`get_balance_and_top_up_test() -> any()`

<a name="is_operator-2"></a>

### is_operator/2 * ###

`is_operator(Req, NodeMsg) -> any()`

Check if the request is from the operator.

<a name="set_balance-3"></a>

### set_balance/3 * ###

`set_balance(Signer, Amount, NodeMsg) -> any()`

Adjust a user's balance, normalizing their wallet ID first.

<a name="test_opts-0"></a>

### test_opts/0 * ###

`test_opts() -> any()`

<a name="test_opts-1"></a>

### test_opts/1 * ###

`test_opts(Ledger) -> any()`

<a name="topup-3"></a>

### topup/3 ###

`topup(X1, Req, NodeMsg) -> any()`

Top up the user's balance in the ledger.


--- END OF FILE: docs/resources/source-code/dev_simple_pay.md ---

--- START OF FILE: docs/resources/source-code/dev_snp_nif.md ---
# [Module dev_snp_nif.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_snp_nif.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#check_snp_support-0">check_snp_support/0</a></td><td></td></tr><tr><td valign="top"><a href="#compute_launch_digest-1">compute_launch_digest/1</a></td><td></td></tr><tr><td valign="top"><a href="#compute_launch_digest_test-0">compute_launch_digest_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#generate_attestation_report-2">generate_attestation_report/2</a></td><td></td></tr><tr><td valign="top"><a href="#generate_attestation_report_test-0">generate_attestation_report_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#init-0">init/0*</a></td><td></td></tr><tr><td valign="top"><a href="#not_loaded-1">not_loaded/1*</a></td><td></td></tr><tr><td valign="top"><a href="#verify_measurement-2">verify_measurement/2</a></td><td></td></tr><tr><td valign="top"><a href="#verify_measurement_test-0">verify_measurement_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#verify_signature-1">verify_signature/1</a></td><td></td></tr><tr><td valign="top"><a href="#verify_signature_test-0">verify_signature_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="check_snp_support-0"></a>

### check_snp_support/0 ###

`check_snp_support() -> any()`

<a name="compute_launch_digest-1"></a>

### compute_launch_digest/1 ###

`compute_launch_digest(Args) -> any()`

<a name="compute_launch_digest_test-0"></a>

### compute_launch_digest_test/0 * ###

`compute_launch_digest_test() -> any()`

<a name="generate_attestation_report-2"></a>

### generate_attestation_report/2 ###

`generate_attestation_report(UniqueData, VMPL) -> any()`

<a name="generate_attestation_report_test-0"></a>

### generate_attestation_report_test/0 * ###

`generate_attestation_report_test() -> any()`

<a name="init-0"></a>

### init/0 * ###

`init() -> any()`

<a name="not_loaded-1"></a>

### not_loaded/1 * ###

`not_loaded(Line) -> any()`

<a name="verify_measurement-2"></a>

### verify_measurement/2 ###

`verify_measurement(Report, Expected) -> any()`

<a name="verify_measurement_test-0"></a>

### verify_measurement_test/0 * ###

`verify_measurement_test() -> any()`

<a name="verify_signature-1"></a>

### verify_signature/1 ###

`verify_signature(Report) -> any()`

<a name="verify_signature_test-0"></a>

### verify_signature_test/0 * ###

`verify_signature_test() -> any()`


--- END OF FILE: docs/resources/source-code/dev_snp_nif.md ---

--- START OF FILE: docs/resources/source-code/dev_snp.md ---
# [Module dev_snp.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_snp.erl)




This device offers an interface for validating AMD SEV-SNP commitments,
as well as generating them, if called in an appropriate environment.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#execute_is_trusted-3">execute_is_trusted/3*</a></td><td>Ensure that all of the software hashes are trusted.</td></tr><tr><td valign="top"><a href="#generate-3">generate/3</a></td><td>Generate an commitment report and emit it as a message, including all of
the necessary data to generate the nonce (ephemeral node address + node
message ID), as well as the expected measurement (firmware, kernel, and VMSAs
hashes).</td></tr><tr><td valign="top"><a href="#generate_nonce-2">generate_nonce/2*</a></td><td>Generate the nonce to use in the commitment report.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Should take in options to set for the device such as kernel, initrd, firmware,
and append hashes and make them available to the device.</td></tr><tr><td valign="top"><a href="#is_debug-1">is_debug/1*</a></td><td>Ensure that the node's debug policy is disabled.</td></tr><tr><td valign="top"><a href="#real_node_test-0">real_node_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#report_data_matches-3">report_data_matches/3*</a></td><td>Ensure that the report data matches the expected report data.</td></tr><tr><td valign="top"><a href="#trusted-3">trusted/3</a></td><td>Default implementation of a resolver for trusted software.</td></tr><tr><td valign="top"><a href="#verify-3">verify/3</a></td><td>Verify an commitment report message; validating the identity of a
remote node, its ephemeral private address, and the integrity of the report.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="execute_is_trusted-3"></a>

### execute_is_trusted/3 * ###

`execute_is_trusted(M1, Msg, NodeOpts) -> any()`

Ensure that all of the software hashes are trusted. The caller may set
a specific device to use for the `is-trusted` key. The device must then
implement the `trusted` resolver.

<a name="generate-3"></a>

### generate/3 ###

`generate(M1, M2, Opts) -> any()`

Generate an commitment report and emit it as a message, including all of
the necessary data to generate the nonce (ephemeral node address + node
message ID), as well as the expected measurement (firmware, kernel, and VMSAs
hashes).

<a name="generate_nonce-2"></a>

### generate_nonce/2 * ###

`generate_nonce(RawAddress, RawNodeMsgID) -> any()`

Generate the nonce to use in the commitment report.

<a name="init-3"></a>

### init/3 ###

`init(M1, M2, Opts) -> any()`

Should take in options to set for the device such as kernel, initrd, firmware,
and append hashes and make them available to the device. Only runnable once,
and only if the operator is not set to an address (and thus, the node has not
had any priviledged access).

<a name="is_debug-1"></a>

### is_debug/1 * ###

`is_debug(Report) -> any()`

Ensure that the node's debug policy is disabled.

<a name="real_node_test-0"></a>

### real_node_test/0 * ###

`real_node_test() -> any()`

<a name="report_data_matches-3"></a>

### report_data_matches/3 * ###

`report_data_matches(Address, NodeMsgID, ReportData) -> any()`

Ensure that the report data matches the expected report data.

<a name="trusted-3"></a>

### trusted/3 ###

`trusted(Msg1, Msg2, NodeOpts) -> any()`

Default implementation of a resolver for trusted software. Searches the
`trusted` key in the base message for a list of trusted values, and checks
if the value in the request message is a member of that list.

<a name="verify-3"></a>

### verify/3 ###

`verify(M1, M2, NodeOpts) -> any()`

Verify an commitment report message; validating the identity of a
remote node, its ephemeral private address, and the integrity of the report.
The checks that must be performed to validate the report are:
1. Verify the address and the node message ID are the same as the ones
used to generate the nonce.
2. Verify the address that signed the message is the same as the one used
to generate the nonce.
3. Verify that the debug flag is disabled.
4. Verify that the firmware, kernel, and OS (VMSAs) hashes, part of the
measurement, are trusted.
5. Verify the measurement is valid.
6. Verify the report's certificate chain to hardware root of trust.


--- END OF FILE: docs/resources/source-code/dev_snp.md ---

--- START OF FILE: docs/resources/source-code/dev_stack.md ---
# [Module dev_stack.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_stack.erl)




A device that contains a stack of other devices, and manages their
execution.

<a name="description"></a>

## Description ##

It can run in two modes: fold (the default), and map.

In fold mode, it runs upon input messages in the order of their keys. A
stack maintains and passes forward a state (expressed as a message) as it
progresses through devices.

For example, a stack of devices as follows:

```

   Device -> Stack
   Device-Stack/1/Name -> Add-One-Device
   Device-Stack/2/Name -> Add-Two-Device
```

When called with the message:

```

   #{ Path = "FuncName", binary => <code><<"0">></code> }
```

Will produce the output:

```

   #{ Path = "FuncName", binary => <code><<"3">></code> }
   {ok, #{ bin => <code><<"3">></code> }}
```

In map mode, the stack will run over all the devices in the stack, and
combine their results into a single message. Each of the devices'
output values have a key that is the device's name in the `Device-Stack`
(its number if the stack is a list).

You can switch between fold and map modes by setting the `Mode` key in the
`Msg2` to either `Fold` or `Map`, or set it globally for the stack by
setting the `Mode` key in the `Msg1` message. The key in `Msg2` takes
precedence over the key in `Msg1`.

The key that is called upon the device stack is the same key that is used
upon the devices that are contained within it. For example, in the above
scenario we resolve FuncName on the stack, leading FuncName to be called on
Add-One-Device and Add-Two-Device.

A device stack responds to special statuses upon responses as follows:

`skip`: Skips the rest of the device stack for the current pass.

`pass`: Causes the stack to increment its pass number and re-execute
the stack from the first device, maintaining the state
accumulated so far. Only available in fold mode.

In all cases, the device stack will return the accumulated state to the
caller as the result of the call to the stack.

The dev_stack adds additional metadata to the message in order to track
the state of its execution as it progresses through devices. These keys
are as follows:

`Stack-Pass`: The number of times the stack has reset and re-executed
from the first device for the current message.

`Input-Prefix`: The prefix that the device should use for its outputs
and inputs.

`Output-Prefix`: The device that was previously executed.

All counters used by the stack are initialized to 1.

Additionally, as implemented in HyperBEAM, the device stack will honor a
number of options that are passed to it as keys in the message. Each of
these options is also passed through to the devices contained within the
stack during execution. These options include:

`Error-Strategy`: Determines how the stack handles errors from devices.
See `maybe_error/5` for more information.

`Allow-Multipass`: Determines whether the stack is allowed to automatically
re-execute from the first device when the `pass` tag is returned. See
`maybe_pass/3` for more information.

Under-the-hood, dev_stack uses a `default` handler to resolve all calls to
devices, aside `set/2` which it calls itself to mutate the message's `device`
key in order to change which device is currently being executed. This method
allows dev_stack to ensure that the message's HashPath is always correct,
even as it delegates calls to other devices. An example flow for a `dev_stack`
execution is as follows:

```

   	/Msg1/AlicesExcitingKey ->
   		dev_stack:execute ->
   			/Msg1/Set?device=/Device-Stack/1 ->
   			/Msg2/AlicesExcitingKey ->
   			/Msg3/Set?device=/Device-Stack/2 ->
   			/Msg4/AlicesExcitingKey
   			... ->
   			/MsgN/Set?device=[This-Device] ->
   		returns {ok, /MsgN+1} ->
   	/MsgN+1
```

In this example, the `device` key is mutated a number of times, but the
resulting HashPath remains correct and verifiable.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#benchmark_test-0">benchmark_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#example_device_for_stack_test-0">example_device_for_stack_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#generate_append_device-1">generate_append_device/1</a></td><td></td></tr><tr><td valign="top"><a href="#generate_append_device-2">generate_append_device/2*</a></td><td></td></tr><tr><td valign="top"><a href="#increment_pass-2">increment_pass/2*</a></td><td>Helper to increment the pass number.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td></td></tr><tr><td valign="top"><a href="#input_and_output_prefixes_test-0">input_and_output_prefixes_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#input_output_prefixes_passthrough_test-0">input_output_prefixes_passthrough_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#input_prefix-3">input_prefix/3</a></td><td>Return the input prefix for the stack.</td></tr><tr><td valign="top"><a href="#many_devices_test-0">many_devices_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_error-5">maybe_error/5*</a></td><td></td></tr><tr><td valign="top"><a href="#no_prefix_test-0">no_prefix_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#not_found_test-0">not_found_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#output_prefix-3">output_prefix/3</a></td><td>Return the output prefix for the stack.</td></tr><tr><td valign="top"><a href="#output_prefix_test-0">output_prefix_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#pass_test-0">pass_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#prefix-3">prefix/3</a></td><td>Return the default prefix for the stack.</td></tr><tr><td valign="top"><a href="#reinvocation_test-0">reinvocation_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_fold-3">resolve_fold/3*</a></td><td>The main device stack execution engine.</td></tr><tr><td valign="top"><a href="#resolve_fold-4">resolve_fold/4*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_map-3">resolve_map/3*</a></td><td>Map over the devices in the stack, accumulating the output in a single
message of keys and values, where keys are the same as the keys in the
original message (typically a number).</td></tr><tr><td valign="top"><a href="#router-3">router/3*</a></td><td></td></tr><tr><td valign="top"><a href="#router-4">router/4</a></td><td>The device stack key router.</td></tr><tr><td valign="top"><a href="#simple_map_test-0">simple_map_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_stack_execute_test-0">simple_stack_execute_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#skip_test-0">skip_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_prefix_msg-0">test_prefix_msg/0*</a></td><td></td></tr><tr><td valign="top"><a href="#transform-3">transform/3*</a></td><td>Return Message1, transformed such that the device named <code>Key</code> from the
<code>Device-Stack</code> key in the message takes the place of the original <code>Device</code>
key.</td></tr><tr><td valign="top"><a href="#transform_external_call_device_test-0">transform_external_call_device_test/0*</a></td><td>Ensure we can generate a transformer message that can be called to
return a version of msg1 with only that device attached.</td></tr><tr><td valign="top"><a href="#transform_internal_call_device_test-0">transform_internal_call_device_test/0*</a></td><td>Test that the transform function can be called correctly internally
by other functions in the module.</td></tr><tr><td valign="top"><a href="#transformer_message-2">transformer_message/2*</a></td><td>Return a message which, when given a key, will transform the message
such that the device named <code>Key</code> from the <code>Device-Stack</code> key in the message
takes the place of the original <code>Device</code> key.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="benchmark_test-0"></a>

### benchmark_test/0 * ###

`benchmark_test() -> any()`

<a name="example_device_for_stack_test-0"></a>

### example_device_for_stack_test/0 * ###

`example_device_for_stack_test() -> any()`

<a name="generate_append_device-1"></a>

### generate_append_device/1 ###

`generate_append_device(Separator) -> any()`

<a name="generate_append_device-2"></a>

### generate_append_device/2 * ###

`generate_append_device(Separator, Status) -> any()`

<a name="increment_pass-2"></a>

### increment_pass/2 * ###

`increment_pass(Message, Opts) -> any()`

Helper to increment the pass number.

<a name="info-1"></a>

### info/1 ###

`info(Msg) -> any()`

<a name="input_and_output_prefixes_test-0"></a>

### input_and_output_prefixes_test/0 * ###

`input_and_output_prefixes_test() -> any()`

<a name="input_output_prefixes_passthrough_test-0"></a>

### input_output_prefixes_passthrough_test/0 * ###

`input_output_prefixes_passthrough_test() -> any()`

<a name="input_prefix-3"></a>

### input_prefix/3 ###

`input_prefix(Msg1, Msg2, Opts) -> any()`

Return the input prefix for the stack.

<a name="many_devices_test-0"></a>

### many_devices_test/0 * ###

`many_devices_test() -> any()`

<a name="maybe_error-5"></a>

### maybe_error/5 * ###

`maybe_error(Message1, Message2, DevNum, Info, Opts) -> any()`

<a name="no_prefix_test-0"></a>

### no_prefix_test/0 * ###

`no_prefix_test() -> any()`

<a name="not_found_test-0"></a>

### not_found_test/0 * ###

`not_found_test() -> any()`

<a name="output_prefix-3"></a>

### output_prefix/3 ###

`output_prefix(Msg1, Msg2, Opts) -> any()`

Return the output prefix for the stack.

<a name="output_prefix_test-0"></a>

### output_prefix_test/0 * ###

`output_prefix_test() -> any()`

<a name="pass_test-0"></a>

### pass_test/0 * ###

`pass_test() -> any()`

<a name="prefix-3"></a>

### prefix/3 ###

`prefix(Msg1, Msg2, Opts) -> any()`

Return the default prefix for the stack.

<a name="reinvocation_test-0"></a>

### reinvocation_test/0 * ###

`reinvocation_test() -> any()`

<a name="resolve_fold-3"></a>

### resolve_fold/3 * ###

`resolve_fold(Message1, Message2, Opts) -> any()`

The main device stack execution engine. See the moduledoc for more
information.

<a name="resolve_fold-4"></a>

### resolve_fold/4 * ###

`resolve_fold(Message1, Message2, DevNum, Opts) -> any()`

<a name="resolve_map-3"></a>

### resolve_map/3 * ###

`resolve_map(Message1, Message2, Opts) -> any()`

Map over the devices in the stack, accumulating the output in a single
message of keys and values, where keys are the same as the keys in the
original message (typically a number).

<a name="router-3"></a>

### router/3 * ###

`router(Message1, Message2, Opts) -> any()`

<a name="router-4"></a>

### router/4 ###

`router(Key, Message1, Message2, Opts) -> any()`

The device stack key router. Sends the request to `resolve_stack`,
except for `set/2` which is handled by the default implementation in
`dev_message`.

<a name="simple_map_test-0"></a>

### simple_map_test/0 * ###

`simple_map_test() -> any()`

<a name="simple_stack_execute_test-0"></a>

### simple_stack_execute_test/0 * ###

`simple_stack_execute_test() -> any()`

<a name="skip_test-0"></a>

### skip_test/0 * ###

`skip_test() -> any()`

<a name="test_prefix_msg-0"></a>

### test_prefix_msg/0 * ###

`test_prefix_msg() -> any()`

<a name="transform-3"></a>

### transform/3 * ###

`transform(Msg1, Key, Opts) -> any()`

Return Message1, transformed such that the device named `Key` from the
`Device-Stack` key in the message takes the place of the original `Device`
key. This transformation allows dev_stack to correctly track the HashPath
of the message as it delegates execution to devices contained within it.

<a name="transform_external_call_device_test-0"></a>

### transform_external_call_device_test/0 * ###

`transform_external_call_device_test() -> any()`

Ensure we can generate a transformer message that can be called to
return a version of msg1 with only that device attached.

<a name="transform_internal_call_device_test-0"></a>

### transform_internal_call_device_test/0 * ###

`transform_internal_call_device_test() -> any()`

Test that the transform function can be called correctly internally
by other functions in the module.

<a name="transformer_message-2"></a>

### transformer_message/2 * ###

`transformer_message(Msg1, Opts) -> any()`

Return a message which, when given a key, will transform the message
such that the device named `Key` from the `Device-Stack` key in the message
takes the place of the original `Device` key. This allows users to call
a single device from the stack:

/Msg1/Transform/DeviceName/keyInDevice ->
keyInDevice executed on DeviceName against Msg1.


--- END OF FILE: docs/resources/source-code/dev_stack.md ---

--- START OF FILE: docs/resources/source-code/dev_test.md ---
# [Module dev_test.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_test.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>Example implementation of a <code>compute</code> handler.</td></tr><tr><td valign="top"><a href="#compute_test-0">compute_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#delay-3">delay/3</a></td><td>Does nothing, just sleeps <code>Req/duration or 750</code> ms and returns the
appropriate form in order to be used as preprocessor.</td></tr><tr><td valign="top"><a href="#device_with_function_key_module_test-0">device_with_function_key_module_test/0*</a></td><td>Tests the resolution of a default function.</td></tr><tr><td valign="top"><a href="#increment_counter-3">increment_counter/3</a></td><td>Find a test worker's PID and send it an increment message.</td></tr><tr><td valign="top"><a href="#info-1">info/1</a></td><td>Exports a default_handler function that can be used to test the
handler resolution mechanism.</td></tr><tr><td valign="top"><a href="#info-3">info/3</a></td><td>Exports a default_handler function that can be used to test the
handler resolution mechanism.</td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Example <code>init/3</code> handler.</td></tr><tr><td valign="top"><a href="#mul-2">mul/2</a></td><td>Example implementation of an <code>imported</code> function for a WASM
executor.</td></tr><tr><td valign="top"><a href="#postprocess-3">postprocess/3</a></td><td>Set the <code>postprocessor-called</code> key to true in the HTTP server.</td></tr><tr><td valign="top"><a href="#restore-3">restore/3</a></td><td>Example <code>restore/3</code> handler.</td></tr><tr><td valign="top"><a href="#restore_test-0">restore_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td>Do nothing when asked to snapshot.</td></tr><tr><td valign="top"><a href="#test_func-1">test_func/1</a></td><td></td></tr><tr><td valign="top"><a href="#update_state-3">update_state/3</a></td><td>Find a test worker's PID and send it an update message.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="compute-3"></a>

### compute/3 ###

`compute(Msg1, Msg2, Opts) -> any()`

Example implementation of a `compute` handler. Makes a running list of
the slots that have been computed in the state message and places the new
slot number in the results key.

<a name="compute_test-0"></a>

### compute_test/0 * ###

`compute_test() -> any()`

<a name="delay-3"></a>

### delay/3 ###

`delay(Msg1, Req, Opts) -> any()`

Does nothing, just sleeps `Req/duration or 750` ms and returns the
appropriate form in order to be used as preprocessor.

<a name="device_with_function_key_module_test-0"></a>

### device_with_function_key_module_test/0 * ###

`device_with_function_key_module_test() -> any()`

Tests the resolution of a default function.

<a name="increment_counter-3"></a>

### increment_counter/3 ###

`increment_counter(Msg1, Msg2, Opts) -> any()`

Find a test worker's PID and send it an increment message.

<a name="info-1"></a>

### info/1 ###

`info(X1) -> any()`

Exports a default_handler function that can be used to test the
handler resolution mechanism.

<a name="info-3"></a>

### info/3 ###

`info(Msg1, Msg2, Opts) -> any()`

Exports a default_handler function that can be used to test the
handler resolution mechanism.

<a name="init-3"></a>

### init/3 ###

`init(Msg, Msg2, Opts) -> any()`

Example `init/3` handler. Sets the `Already-Seen` key to an empty list.

<a name="mul-2"></a>

### mul/2 ###

`mul(Msg1, Msg2) -> any()`

Example implementation of an `imported` function for a WASM
executor.

<a name="postprocess-3"></a>

### postprocess/3 ###

`postprocess(Msg, X2, Opts) -> any()`

Set the `postprocessor-called` key to true in the HTTP server.

<a name="restore-3"></a>

### restore/3 ###

`restore(Msg, Msg2, Opts) -> any()`

Example `restore/3` handler. Sets the hidden key `Test/Started` to the
value of `Current-Slot` and checks whether the `Already-Seen` key is valid.

<a name="restore_test-0"></a>

### restore_test/0 * ###

`restore_test() -> any()`

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(Msg1, Msg2, Opts) -> any()`

Do nothing when asked to snapshot.

<a name="test_func-1"></a>

### test_func/1 ###

`test_func(X1) -> any()`

<a name="update_state-3"></a>

### update_state/3 ###

`update_state(Msg, Msg2, Opts) -> any()`

Find a test worker's PID and send it an update message.


--- END OF FILE: docs/resources/source-code/dev_test.md ---

--- START OF FILE: docs/resources/source-code/dev_wasi.md ---
# [Module dev_wasi.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_wasi.erl)




A virtual filesystem device.

<a name="description"></a>

## Description ##
Implements a file-system-as-map structure, which is traversible externally.
Each file is a binary and each directory is an AO-Core message.
Additionally, this module adds a series of WASI-preview-1 compatible
functions for accessing the filesystem as imported functions by WASM
modules.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#basic_aos_exec_test-0">basic_aos_exec_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#clock_time_get-3">clock_time_get/3</a></td><td></td></tr><tr><td valign="top"><a href="#compute-1">compute/1</a></td><td></td></tr><tr><td valign="top"><a href="#fd_read-3">fd_read/3</a></td><td>Read from a file using the WASI-p1 standard interface.</td></tr><tr><td valign="top"><a href="#fd_read-5">fd_read/5*</a></td><td></td></tr><tr><td valign="top"><a href="#fd_write-3">fd_write/3</a></td><td>WASM stdlib implementation of <code>fd_write</code>, using the WASI-p1 standard
interface.</td></tr><tr><td valign="top"><a href="#fd_write-5">fd_write/5*</a></td><td></td></tr><tr><td valign="top"><a href="#gen_test_aos_msg-1">gen_test_aos_msg/1*</a></td><td></td></tr><tr><td valign="top"><a href="#gen_test_env-0">gen_test_env/0*</a></td><td></td></tr><tr><td valign="top"><a href="#generate_wasi_stack-3">generate_wasi_stack/3*</a></td><td></td></tr><tr><td valign="top"><a href="#init-0">init/0*</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>On-boot, initialize the virtual file system with:
- Empty stdio files
- WASI-preview-1 compatible functions for accessing the filesystem
- File descriptors for those files.</td></tr><tr><td valign="top"><a href="#parse_iovec-2">parse_iovec/2*</a></td><td>Parse an iovec in WASI-preview-1 format.</td></tr><tr><td valign="top"><a href="#path_open-3">path_open/3</a></td><td>Adds a file descriptor to the state message.</td></tr><tr><td valign="top"><a href="#stdout-1">stdout/1</a></td><td>Return the stdout buffer from a state message.</td></tr><tr><td valign="top"><a href="#vfs_is_serializable_test-0">vfs_is_serializable_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#wasi_stack_is_serializable_test-0">wasi_stack_is_serializable_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="basic_aos_exec_test-0"></a>

### basic_aos_exec_test/0 * ###

`basic_aos_exec_test() -> any()`

<a name="clock_time_get-3"></a>

### clock_time_get/3 ###

`clock_time_get(Msg1, Msg2, Opts) -> any()`

<a name="compute-1"></a>

### compute/1 ###

`compute(Msg1) -> any()`

<a name="fd_read-3"></a>

### fd_read/3 ###

`fd_read(Msg1, Msg2, Opts) -> any()`

Read from a file using the WASI-p1 standard interface.

<a name="fd_read-5"></a>

### fd_read/5 * ###

`fd_read(S, Instance, X3, BytesRead, Opts) -> any()`

<a name="fd_write-3"></a>

### fd_write/3 ###

`fd_write(Msg1, Msg2, Opts) -> any()`

WASM stdlib implementation of `fd_write`, using the WASI-p1 standard
interface.

<a name="fd_write-5"></a>

### fd_write/5 * ###

`fd_write(S, Instance, X3, BytesWritten, Opts) -> any()`

<a name="gen_test_aos_msg-1"></a>

### gen_test_aos_msg/1 * ###

`gen_test_aos_msg(Command) -> any()`

<a name="gen_test_env-0"></a>

### gen_test_env/0 * ###

`gen_test_env() -> any()`

<a name="generate_wasi_stack-3"></a>

### generate_wasi_stack/3 * ###

`generate_wasi_stack(File, Func, Params) -> any()`

<a name="init-0"></a>

### init/0 * ###

`init() -> any()`

<a name="init-3"></a>

### init/3 ###

`init(M1, M2, Opts) -> any()`

On-boot, initialize the virtual file system with:
- Empty stdio files
- WASI-preview-1 compatible functions for accessing the filesystem
- File descriptors for those files.

<a name="parse_iovec-2"></a>

### parse_iovec/2 * ###

`parse_iovec(Instance, Ptr) -> any()`

Parse an iovec in WASI-preview-1 format.

<a name="path_open-3"></a>

### path_open/3 ###

`path_open(Msg1, Msg2, Opts) -> any()`

Adds a file descriptor to the state message.
path_open(M, Instance, [FDPtr, LookupFlag, PathPtr|_]) ->

<a name="stdout-1"></a>

### stdout/1 ###

`stdout(M) -> any()`

Return the stdout buffer from a state message.

<a name="vfs_is_serializable_test-0"></a>

### vfs_is_serializable_test/0 * ###

`vfs_is_serializable_test() -> any()`

<a name="wasi_stack_is_serializable_test-0"></a>

### wasi_stack_is_serializable_test/0 * ###

`wasi_stack_is_serializable_test() -> any()`


--- END OF FILE: docs/resources/source-code/dev_wasi.md ---

--- START OF FILE: docs/resources/source-code/dev_wasm.md ---
# [Module dev_wasm.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/dev_wasm.erl)




A device that executes a WASM image on messages using the Memory-64
preview standard.

<a name="description"></a>

## Description ##

In the backend, this device uses `beamr`: An Erlang wrapper
for WAMR, the WebAssembly Micro Runtime.

The device has the following requirements and interface:

```

       M1/Init ->
           Assumes:
               M1/process
               M1/[Prefix]/image
           Generates:
               /priv/[Prefix]/instance
               /priv/[Prefix]/import-resolver
           Side-effects:
               Creates a WASM executor loaded in memory of the HyperBEAM node.
       M1/Compute ->
           Assumes:
               M1/priv/[Prefix]/instance
               M1/priv/[Prefix]/import-resolver
               M1/process
               M2/message
               M2/message/function OR M1/function
               M2/message/parameters OR M1/parameters
           Generates:
               /results/[Prefix]/type
               /results/[Prefix]/output
           Side-effects:
               Calls the WASM executor with the message and process.
       M1/[Prefix]/state ->
           Assumes:
               M1/priv/[Prefix]/instance
           Generates:
               Raw binary WASM state
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#basic_execution_64_test-0">basic_execution_64_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_execution_test-0">basic_execution_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#benchmark_test-0">benchmark_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#cache_wasm_image-1">cache_wasm_image/1</a></td><td></td></tr><tr><td valign="top"><a href="#cache_wasm_image-2">cache_wasm_image/2</a></td><td></td></tr><tr><td valign="top"><a href="#compute-3">compute/3</a></td><td>Call the WASM executor with a message that has been prepared by a prior
pass.</td></tr><tr><td valign="top"><a href="#default_import_resolver-3">default_import_resolver/3*</a></td><td>Take a BEAMR import call and resolve it using <code>hb_ao</code>.</td></tr><tr><td valign="top"><a href="#import-3">import/3</a></td><td>Handle standard library calls by:
1.</td></tr><tr><td valign="top"><a href="#imported_function_test-0">imported_function_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#info-2">info/2</a></td><td>Export all functions aside the <code>instance/3</code> function.</td></tr><tr><td valign="top"><a href="#init-0">init/0*</a></td><td></td></tr><tr><td valign="top"><a href="#init-3">init/3</a></td><td>Boot a WASM image on the image stated in the <code>process/image</code> field of
the message.</td></tr><tr><td valign="top"><a href="#init_test-0">init_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#input_prefix_test-0">input_prefix_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#instance-3">instance/3</a></td><td>Get the WASM instance from the message.</td></tr><tr><td valign="top"><a href="#normalize-3">normalize/3</a></td><td>Normalize the message to have an open WASM instance, but no literal
<code>State</code> key.</td></tr><tr><td valign="top"><a href="#process_prefixes_test-0">process_prefixes_test/0*</a></td><td>Test that realistic prefixing for a <code>dev_process</code> works --
including both inputs (from <code>Process/</code>) and outputs (to the
Device-Key) work.</td></tr><tr><td valign="top"><a href="#snapshot-3">snapshot/3</a></td><td>Serialize the WASM state to a binary.</td></tr><tr><td valign="top"><a href="#state_export_and_restore_test-0">state_export_and_restore_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#terminate-3">terminate/3</a></td><td>Tear down the WASM executor.</td></tr><tr><td valign="top"><a href="#test_run_wasm-4">test_run_wasm/4*</a></td><td></td></tr><tr><td valign="top"><a href="#undefined_import_stub-3">undefined_import_stub/3*</a></td><td>Log the call to the standard library as an event, and write the
call details into the message.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="basic_execution_64_test-0"></a>

### basic_execution_64_test/0 * ###

`basic_execution_64_test() -> any()`

<a name="basic_execution_test-0"></a>

### basic_execution_test/0 * ###

`basic_execution_test() -> any()`

<a name="benchmark_test-0"></a>

### benchmark_test/0 * ###

`benchmark_test() -> any()`

<a name="cache_wasm_image-1"></a>

### cache_wasm_image/1 ###

`cache_wasm_image(Image) -> any()`

<a name="cache_wasm_image-2"></a>

### cache_wasm_image/2 ###

`cache_wasm_image(Image, Opts) -> any()`

<a name="compute-3"></a>

### compute/3 ###

`compute(RawM1, M2, Opts) -> any()`

Call the WASM executor with a message that has been prepared by a prior
pass.

<a name="default_import_resolver-3"></a>

### default_import_resolver/3 * ###

`default_import_resolver(Msg1, Msg2, Opts) -> any()`

Take a BEAMR import call and resolve it using `hb_ao`.

<a name="import-3"></a>

### import/3 ###

`import(Msg1, Msg2, Opts) -> any()`

Handle standard library calls by:
1. Adding the right prefix to the path from BEAMR.
2. Adding the state to the message at the stdlib path.
3. Resolving the adjusted-path-Msg2 against the added-state-Msg1.
4. If it succeeds, return the new state from the message.
5. If it fails with `not_found`, call the stub handler.

<a name="imported_function_test-0"></a>

### imported_function_test/0 * ###

`imported_function_test() -> any()`

<a name="info-2"></a>

### info/2 ###

`info(Msg1, Opts) -> any()`

Export all functions aside the `instance/3` function.

<a name="init-0"></a>

### init/0 * ###

`init() -> any()`

<a name="init-3"></a>

### init/3 ###

`init(M1, M2, Opts) -> any()`

Boot a WASM image on the image stated in the `process/image` field of
the message.

<a name="init_test-0"></a>

### init_test/0 * ###

`init_test() -> any()`

<a name="input_prefix_test-0"></a>

### input_prefix_test/0 * ###

`input_prefix_test() -> any()`

<a name="instance-3"></a>

### instance/3 ###

`instance(M1, M2, Opts) -> any()`

Get the WASM instance from the message. Note that this function is exported
such that other devices can use it, but it is excluded from calls from AO-Core
resolution directly.

<a name="normalize-3"></a>

### normalize/3 ###

`normalize(RawM1, M2, Opts) -> any()`

Normalize the message to have an open WASM instance, but no literal
`State` key. Ensure that we do not change the hashpath during this process.

<a name="process_prefixes_test-0"></a>

### process_prefixes_test/0 * ###

`process_prefixes_test() -> any()`

Test that realistic prefixing for a `dev_process` works --
including both inputs (from `Process/`) and outputs (to the
Device-Key) work

<a name="snapshot-3"></a>

### snapshot/3 ###

`snapshot(M1, M2, Opts) -> any()`

Serialize the WASM state to a binary.

<a name="state_export_and_restore_test-0"></a>

### state_export_and_restore_test/0 * ###

`state_export_and_restore_test() -> any()`

<a name="terminate-3"></a>

### terminate/3 ###

`terminate(M1, M2, Opts) -> any()`

Tear down the WASM executor.

<a name="test_run_wasm-4"></a>

### test_run_wasm/4 * ###

`test_run_wasm(File, Func, Params, AdditionalMsg) -> any()`

<a name="undefined_import_stub-3"></a>

### undefined_import_stub/3 * ###

`undefined_import_stub(Msg1, Msg2, Opts) -> any()`

Log the call to the standard library as an event, and write the
call details into the message.


--- END OF FILE: docs/resources/source-code/dev_wasm.md ---

--- START OF FILE: docs/resources/source-code/hb_ao_test_vectors.md ---
# [Module hb_ao_test_vectors.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_ao_test_vectors.erl)




Uses a series of different `Opts` values to test the resolution engine's
execution under different circumstances.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#as_path_test-1">as_path_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_get_test-1">basic_get_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_set_test-1">basic_set_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#continue_as_test-1">continue_as_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#deep_recursive_get_test-1">deep_recursive_get_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#deep_set_new_messages_test-0">deep_set_new_messages_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#deep_set_test-1">deep_set_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#deep_set_with_device_test-1">deep_set_with_device_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#denormalized_device_key_test-1">denormalized_device_key_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#device_excludes_test-1">device_excludes_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#device_exports_test-1">device_exports_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#device_with_default_handler_function_test-1">device_with_default_handler_function_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#device_with_handler_function_test-1">device_with_handler_function_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#exec_dummy_device-2">exec_dummy_device/2*</a></td><td>Ensure that we can read a device from the cache then execute it.</td></tr><tr><td valign="top"><a href="#gen_default_device-0">gen_default_device/0*</a></td><td>Create a simple test device that implements the default handler.</td></tr><tr><td valign="top"><a href="#gen_handler_device-0">gen_handler_device/0*</a></td><td>Create a simple test device that implements the handler key.</td></tr><tr><td valign="top"><a href="#generate_device_with_keys_using_args-0">generate_device_with_keys_using_args/0*</a></td><td>Generates a test device with three keys, each of which uses
progressively more of the arguments that can be passed to a device key.</td></tr><tr><td valign="top"><a href="#get_as_with_device_test-1">get_as_with_device_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#get_with_device_test-1">get_with_device_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#key_from_id_device_with_args_test-1">key_from_id_device_with_args_test/1*</a></td><td>Test that arguments are passed to a device key as expected.</td></tr><tr><td valign="top"><a href="#key_to_binary_test-1">key_to_binary_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#list_transform_test-1">list_transform_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#load_as_test-1">load_as_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#load_device_test-0">load_device_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#recursive_get_test-1">recursive_get_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_binary_key_test-1">resolve_binary_key_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_from_multiple_keys_test-1">resolve_from_multiple_keys_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_id_test-1">resolve_id_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_key_twice_test-1">resolve_key_twice_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_path_element_test-1">resolve_path_element_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_simple_test-1">resolve_simple_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#run_all_test_-0">run_all_test_/0*</a></td><td>Run each test in the file with each set of options.</td></tr><tr><td valign="top"><a href="#run_test-0">run_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#set_with_device_test-1">set_with_device_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#start_as_test-1">start_as_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#start_as_with_parameters_test-1">start_as_with_parameters_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_opts-0">test_opts/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_suite-0">test_suite/0*</a></td><td></td></tr><tr><td valign="top"><a href="#untrusted_load_device_test-0">untrusted_load_device_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="as_path_test-1"></a>

### as_path_test/1 * ###

`as_path_test(Opts) -> any()`

<a name="basic_get_test-1"></a>

### basic_get_test/1 * ###

`basic_get_test(Opts) -> any()`

<a name="basic_set_test-1"></a>

### basic_set_test/1 * ###

`basic_set_test(Opts) -> any()`

<a name="continue_as_test-1"></a>

### continue_as_test/1 * ###

`continue_as_test(Opts) -> any()`

<a name="deep_recursive_get_test-1"></a>

### deep_recursive_get_test/1 * ###

`deep_recursive_get_test(Opts) -> any()`

<a name="deep_set_new_messages_test-0"></a>

### deep_set_new_messages_test/0 * ###

`deep_set_new_messages_test() -> any()`

<a name="deep_set_test-1"></a>

### deep_set_test/1 * ###

`deep_set_test(Opts) -> any()`

<a name="deep_set_with_device_test-1"></a>

### deep_set_with_device_test/1 * ###

`deep_set_with_device_test(Opts) -> any()`

<a name="denormalized_device_key_test-1"></a>

### denormalized_device_key_test/1 * ###

`denormalized_device_key_test(Opts) -> any()`

<a name="device_excludes_test-1"></a>

### device_excludes_test/1 * ###

`device_excludes_test(Opts) -> any()`

<a name="device_exports_test-1"></a>

### device_exports_test/1 * ###

`device_exports_test(Opts) -> any()`

<a name="device_with_default_handler_function_test-1"></a>

### device_with_default_handler_function_test/1 * ###

`device_with_default_handler_function_test(Opts) -> any()`

<a name="device_with_handler_function_test-1"></a>

### device_with_handler_function_test/1 * ###

`device_with_handler_function_test(Opts) -> any()`

<a name="exec_dummy_device-2"></a>

### exec_dummy_device/2 * ###

`exec_dummy_device(SigningWallet, Opts) -> any()`

Ensure that we can read a device from the cache then execute it. By
extension, this will also allow us to load a device from Arweave due to the
remote store implementations.

<a name="gen_default_device-0"></a>

### gen_default_device/0 * ###

`gen_default_device() -> any()`

Create a simple test device that implements the default handler.

<a name="gen_handler_device-0"></a>

### gen_handler_device/0 * ###

`gen_handler_device() -> any()`

Create a simple test device that implements the handler key.

<a name="generate_device_with_keys_using_args-0"></a>

### generate_device_with_keys_using_args/0 * ###

`generate_device_with_keys_using_args() -> any()`

Generates a test device with three keys, each of which uses
progressively more of the arguments that can be passed to a device key.

<a name="get_as_with_device_test-1"></a>

### get_as_with_device_test/1 * ###

`get_as_with_device_test(Opts) -> any()`

<a name="get_with_device_test-1"></a>

### get_with_device_test/1 * ###

`get_with_device_test(Opts) -> any()`

<a name="key_from_id_device_with_args_test-1"></a>

### key_from_id_device_with_args_test/1 * ###

`key_from_id_device_with_args_test(Opts) -> any()`

Test that arguments are passed to a device key as expected.
Particularly, we need to ensure that the key function in the device can
specify any arity (1 through 3) and the call is handled correctly.

<a name="key_to_binary_test-1"></a>

### key_to_binary_test/1 * ###

`key_to_binary_test(Opts) -> any()`

<a name="list_transform_test-1"></a>

### list_transform_test/1 * ###

`list_transform_test(Opts) -> any()`

<a name="load_as_test-1"></a>

### load_as_test/1 * ###

`load_as_test(Opts) -> any()`

<a name="load_device_test-0"></a>

### load_device_test/0 * ###

`load_device_test() -> any()`

<a name="recursive_get_test-1"></a>

### recursive_get_test/1 * ###

`recursive_get_test(Opts) -> any()`

<a name="resolve_binary_key_test-1"></a>

### resolve_binary_key_test/1 * ###

`resolve_binary_key_test(Opts) -> any()`

<a name="resolve_from_multiple_keys_test-1"></a>

### resolve_from_multiple_keys_test/1 * ###

`resolve_from_multiple_keys_test(Opts) -> any()`

<a name="resolve_id_test-1"></a>

### resolve_id_test/1 * ###

`resolve_id_test(Opts) -> any()`

<a name="resolve_key_twice_test-1"></a>

### resolve_key_twice_test/1 * ###

`resolve_key_twice_test(Opts) -> any()`

<a name="resolve_path_element_test-1"></a>

### resolve_path_element_test/1 * ###

`resolve_path_element_test(Opts) -> any()`

<a name="resolve_simple_test-1"></a>

### resolve_simple_test/1 * ###

`resolve_simple_test(Opts) -> any()`

<a name="run_all_test_-0"></a>

### run_all_test_/0 * ###

`run_all_test_() -> any()`

Run each test in the file with each set of options. Start and reset
the store for each test.

<a name="run_test-0"></a>

### run_test/0 * ###

`run_test() -> any()`

<a name="set_with_device_test-1"></a>

### set_with_device_test/1 * ###

`set_with_device_test(Opts) -> any()`

<a name="start_as_test-1"></a>

### start_as_test/1 * ###

`start_as_test(Opts) -> any()`

<a name="start_as_with_parameters_test-1"></a>

### start_as_with_parameters_test/1 * ###

`start_as_with_parameters_test(Opts) -> any()`

<a name="test_opts-0"></a>

### test_opts/0 * ###

`test_opts() -> any()`

<a name="test_suite-0"></a>

### test_suite/0 * ###

`test_suite() -> any()`

<a name="untrusted_load_device_test-0"></a>

### untrusted_load_device_test/0 * ###

`untrusted_load_device_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_ao_test_vectors.md ---

--- START OF FILE: docs/resources/source-code/hb_ao.md ---
# [Module hb_ao.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_ao.erl)




This module is the root of the device call logic of the
AO-Core protocol in HyperBEAM.

<a name="description"></a>

## Description ##

At the implementation level, every message is simply a collection of keys,
dictated by its `Device`, that can be resolved in order to yield their
values. Each key may return another message or a raw value:

`ao(Message1, Message2) -> {Status, Message3}`

Under-the-hood, `AO-Core(Message1, Message2)` leads to the evaluation of
`DeviceMod:PathPart(Message1, Message2)`, which defines the user compute
to be performed. If `Message1` does not specify a device, `dev_message` is
assumed. The key to resolve is specified by the `Path` field of the message.

After each output, the `HashPath` is updated to include the `Message2`
that was executed upon it.

Because each message implies a device that can resolve its keys, as well
as generating a merkle tree of the computation that led to the result,
you can see AO-Core protocol as a system for cryptographically chaining
the execution of `combinators`. See `docs/ao-core-protocol.md` for more
information about AO-Core.

The `Fun(Message1, Message2)` pattern is repeated throughout the HyperBEAM
codebase, sometimes with `MessageX` replaced with `MX` or `MsgX` for brevity.

Message3 can be either a new message or a raw output value (a binary, integer,
float, atom, or list of such values).

Devices can be expressed as either modules or maps. They can also be
referenced by an Arweave ID, which can be used to load a device from
the network (depending on the value of the `load_remote_devices` and
`trusted_device_signers` environment settings).

HyperBEAM device implementations are defined as follows:

```

       DevMod:ExportedFunc : Key resolution functions. All are assumed to be
                             device keys (thus, present in every message that
                             uses it) unless specified by <code>DevMod:info()</code>.
                             Each function takes a set of parameters
                             of the form <code>DevMod:KeyHandler(Msg1, Msg2, Opts)</code>.
                             Each of these arguments can be ommitted if not
                             needed. Non-exported functions are not assumed
                             to be device keys.
       DevMod:info : Optional. Returns a map of options for the device. All
                     options are optional and assumed to be the defaults if
                     not specified. This function can accept a <code>Message1</code> as
                     an argument, allowing it to specify its functionality
                     based on a specific message if appropriate.
       info/exports : Overrides the export list of the Erlang module, such that
                     only the functions in this list are assumed to be device
                     keys. Defaults to all of the functions that DevMod
                     exports in the Erlang environment.
       info/excludes : A list of keys that should not be resolved by the device,
                       despite being present in the Erlang module exports list.
       info/handler : A function that should be used to handle _all_ keys for
                      messages using the device.
       info/default : A function that should be used to handle all keys that
                      are not explicitly implemented by the device. Defaults to
                      the <code>dev_message</code> device, which contains general keys for
                      interacting with messages.
       info/default_mod : A different device module that should be used to
                      handle all keys that are not explicitly implemented
                      by the device. Defaults to the <code>dev_message</code> device.
       info/grouper : A function that returns the concurrency 'group' name for
                      an execution. Executions with the same group name will
                      be executed by sending a message to the associated process
                      and waiting for a response. This allows you to control
                      concurrency of execution and to allow executions to share
                      in-memory state as applicable. Default: A derivation of
                      Msg1+Msg2. This means that concurrent calls for the same
                      output will lead to only a single execution.
       info/worker : A function that should be run as the 'server' loop of
                     the executor for interactions using the device.
   The HyperBEAM resolver also takes a number of runtime options that change
   the way that the environment operates:<code>update_hashpath</code>:  Whether to add the <code>Msg2</code> to <code>HashPath</code> for the <code>Msg3</code>.
   					Default: true.<code>add_key</code>:          Whether to add the key to the start of the arguments.
   					Default: <code><not set></code>.
```
<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#deep_set-4">deep_set/4</a></td><td>Recursively search a map, resolving keys, and set the value of the key
at the given path.</td></tr><tr><td valign="top"><a href="#default_module-0">default_module/0*</a></td><td>The default device is the identity device, which simply returns the
value associated with any key as it exists in its Erlang map.</td></tr><tr><td valign="top"><a href="#device_set-4">device_set/4*</a></td><td>Call the device's <code>set</code> function.</td></tr><tr><td valign="top"><a href="#do_resolve_many-2">do_resolve_many/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ensure_loaded-2">ensure_loaded/2*</a></td><td>Ensure that the message is loaded from the cache if it is an ID.</td></tr><tr><td valign="top"><a href="#error_execution-5">error_execution/5*</a></td><td>Handle an error in a device call.</td></tr><tr><td valign="top"><a href="#error_infinite-3">error_infinite/3*</a></td><td>Catch all return if we are in an infinite loop.</td></tr><tr><td valign="top"><a href="#error_invalid_intermediate_status-5">error_invalid_intermediate_status/5*</a></td><td></td></tr><tr><td valign="top"><a href="#error_invalid_message-3">error_invalid_message/3*</a></td><td>Catch all return if the message is invalid.</td></tr><tr><td valign="top"><a href="#find_exported_function-5">find_exported_function/5</a></td><td>Find the function with the highest arity that has the given name, if it
exists.</td></tr><tr><td valign="top"><a href="#force_message-2">force_message/2</a></td><td></td></tr><tr><td valign="top"><a href="#get-2">get/2</a></td><td>Shortcut for resolving a key in a message without its status if it is
<code>ok</code>.</td></tr><tr><td valign="top"><a href="#get-3">get/3</a></td><td></td></tr><tr><td valign="top"><a href="#get-4">get/4</a></td><td></td></tr><tr><td valign="top"><a href="#get_first-2">get_first/2</a></td><td>take a sequence of base messages and paths, then return the value of the
first message that can be resolved using a path.</td></tr><tr><td valign="top"><a href="#get_first-3">get_first/3</a></td><td></td></tr><tr><td valign="top"><a href="#info-2">info/2</a></td><td>Get the info map for a device, optionally giving it a message if the
device's info function is parameterized by one.</td></tr><tr><td valign="top"><a href="#info-3">info/3*</a></td><td></td></tr><tr><td valign="top"><a href="#info_handler_to_fun-4">info_handler_to_fun/4*</a></td><td>Parse a handler key given by a device's <code>info</code>.</td></tr><tr><td valign="top"><a href="#internal_opts-1">internal_opts/1*</a></td><td>The execution options that are used internally by this module
when calling itself.</td></tr><tr><td valign="top"><a href="#is_exported-2">is_exported/2*</a></td><td></td></tr><tr><td valign="top"><a href="#is_exported-4">is_exported/4</a></td><td>Check if a device is guarding a key via its <code>exports</code> list.</td></tr><tr><td valign="top"><a href="#keys-1">keys/1</a></td><td>Shortcut to get the list of keys from a message.</td></tr><tr><td valign="top"><a href="#keys-2">keys/2</a></td><td></td></tr><tr><td valign="top"><a href="#keys-3">keys/3</a></td><td></td></tr><tr><td valign="top"><a href="#load_device-2">load_device/2</a></td><td>Load a device module from its name or a message ID.</td></tr><tr><td valign="top"><a href="#maybe_force_message-2">maybe_force_message/2*</a></td><td>Force the result of a device call into a message if the result is not
requested by the <code>Opts</code>.</td></tr><tr><td valign="top"><a href="#message_to_device-2">message_to_device/2</a></td><td>Extract the device module from a message.</td></tr><tr><td valign="top"><a href="#message_to_fun-3">message_to_fun/3</a></td><td>Calculate the Erlang function that should be called to get a value for
a given key from a device.</td></tr><tr><td valign="top"><a href="#normalize_key-1">normalize_key/1</a></td><td>Convert a key to a binary in normalized form.</td></tr><tr><td valign="top"><a href="#normalize_key-2">normalize_key/2</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_keys-1">normalize_keys/1</a></td><td>Ensure that a message is processable by the AO-Core resolver: No lists.</td></tr><tr><td valign="top"><a href="#remove-2">remove/2</a></td><td>Remove a key from a message, using its underlying device.</td></tr><tr><td valign="top"><a href="#remove-3">remove/3</a></td><td></td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td>Get the value of a message's key by running its associated device
function.</td></tr><tr><td valign="top"><a href="#resolve-3">resolve/3</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_many-2">resolve_many/2</a></td><td>Resolve a list of messages in sequence.</td></tr><tr><td valign="top"><a href="#resolve_stage-4">resolve_stage/4*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_stage-5">resolve_stage/5*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_stage-6">resolve_stage/6*</a></td><td></td></tr><tr><td valign="top"><a href="#set-2">set/2</a></td><td>Shortcut for setting a key in the message using its underlying device.</td></tr><tr><td valign="top"><a href="#set-3">set/3</a></td><td></td></tr><tr><td valign="top"><a href="#set-4">set/4</a></td><td></td></tr><tr><td valign="top"><a href="#subresolve-4">subresolve/4*</a></td><td>Execute a sub-resolution.</td></tr><tr><td valign="top"><a href="#truncate_args-2">truncate_args/2</a></td><td>Truncate the arguments of a function to the number of arguments it
actually takes.</td></tr><tr><td valign="top"><a href="#verify_device_compatibility-2">verify_device_compatibility/2*</a></td><td>Verify that a device is compatible with the current machine.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="deep_set-4"></a>

### deep_set/4 ###

`deep_set(Msg, Rest, Value, Opts) -> any()`

Recursively search a map, resolving keys, and set the value of the key
at the given path.

<a name="default_module-0"></a>

### default_module/0 * ###

`default_module() -> any()`

The default device is the identity device, which simply returns the
value associated with any key as it exists in its Erlang map. It should also
implement the `set` key, which returns a `Message3` with the values changed
according to the `Message2` passed to it.

<a name="device_set-4"></a>

### device_set/4 * ###

`device_set(Msg, Key, Value, Opts) -> any()`

Call the device's `set` function.

<a name="do_resolve_many-2"></a>

### do_resolve_many/2 * ###

`do_resolve_many(MsgList, Opts) -> any()`

<a name="ensure_loaded-2"></a>

### ensure_loaded/2 * ###

`ensure_loaded(MsgID, Opts) -> any()`

Ensure that the message is loaded from the cache if it is an ID. If is
not loadable or already present, we raise an error.

<a name="error_execution-5"></a>

### error_execution/5 * ###

`error_execution(ExecGroup, Msg2, Whence, X4, Opts) -> any()`

Handle an error in a device call.

<a name="error_infinite-3"></a>

### error_infinite/3 * ###

`error_infinite(Msg1, Msg2, Opts) -> any()`

Catch all return if we are in an infinite loop.

<a name="error_invalid_intermediate_status-5"></a>

### error_invalid_intermediate_status/5 * ###

`error_invalid_intermediate_status(Msg1, Msg2, Msg3, RemainingPath, Opts) -> any()`

<a name="error_invalid_message-3"></a>

### error_invalid_message/3 * ###

`error_invalid_message(Msg1, Msg2, Opts) -> any()`

Catch all return if the message is invalid.

<a name="find_exported_function-5"></a>

### find_exported_function/5 ###

`find_exported_function(Msg, Dev, Key, MaxArity, Opts) -> any()`

Find the function with the highest arity that has the given name, if it
exists.

If the device is a module, we look for a function with the given name.

If the device is a map, we look for a key in the map. First we try to find
the key using its literal value. If that fails, we cast the key to an atom
and try again.

<a name="force_message-2"></a>

### force_message/2 ###

`force_message(X1, Opts) -> any()`

<a name="get-2"></a>

### get/2 ###

`get(Path, Msg) -> any()`

Shortcut for resolving a key in a message without its status if it is
`ok`. This makes it easier to write complex logic on top of messages while
maintaining a functional style.

Additionally, this function supports the `{as, Device, Msg}` syntax, which
allows the key to be resolved using another device to resolve the key,
while maintaining the tracability of the `HashPath` of the output message.

Returns the value of the key if it is found, otherwise returns the default
provided by the user, or `not_found` if no default is provided.

<a name="get-3"></a>

### get/3 ###

`get(Path, Msg, Opts) -> any()`

<a name="get-4"></a>

### get/4 ###

`get(Path, Msg, Default, Opts) -> any()`

<a name="get_first-2"></a>

### get_first/2 ###

`get_first(Paths, Opts) -> any()`

take a sequence of base messages and paths, then return the value of the
first message that can be resolved using a path.

<a name="get_first-3"></a>

### get_first/3 ###

`get_first(Msgs, Default, Opts) -> any()`

<a name="info-2"></a>

### info/2 ###

`info(Msg, Opts) -> any()`

Get the info map for a device, optionally giving it a message if the
device's info function is parameterized by one.

<a name="info-3"></a>

### info/3 * ###

`info(DevMod, Msg, Opts) -> any()`

<a name="info_handler_to_fun-4"></a>

### info_handler_to_fun/4 * ###

`info_handler_to_fun(Handler, Msg, Key, Opts) -> any()`

Parse a handler key given by a device's `info`.

<a name="internal_opts-1"></a>

### internal_opts/1 * ###

`internal_opts(Opts) -> any()`

The execution options that are used internally by this module
when calling itself.

<a name="is_exported-2"></a>

### is_exported/2 * ###

`is_exported(Info, Key) -> any()`

<a name="is_exported-4"></a>

### is_exported/4 ###

`is_exported(Msg, Dev, Key, Opts) -> any()`

Check if a device is guarding a key via its `exports` list. Defaults to
true if the device does not specify an `exports` list. The `info` function is
always exported, if it exists. Elements of the `exludes` list are not
exported. Note that we check for info _twice_ -- once when the device is
given but the info result is not, and once when the info result is given.
The reason for this is that `info/3` calls other functions that may need to
check if a key is exported, so we must avoid infinite loops. We must, however,
also return a consistent result in the case that only the info result is
given, so we check for it in both cases.

<a name="keys-1"></a>

### keys/1 ###

`keys(Msg) -> any()`

Shortcut to get the list of keys from a message.

<a name="keys-2"></a>

### keys/2 ###

`keys(Msg, Opts) -> any()`

<a name="keys-3"></a>

### keys/3 ###

`keys(Msg, Opts, X3) -> any()`

<a name="load_device-2"></a>

### load_device/2 ###

`load_device(Map, Opts) -> any()`

Load a device module from its name or a message ID.
Returns {ok, Executable} where Executable is the device module. On error,
a tuple of the form {error, Reason} is returned.

<a name="maybe_force_message-2"></a>

### maybe_force_message/2 * ###

`maybe_force_message(X1, Opts) -> any()`

Force the result of a device call into a message if the result is not
requested by the `Opts`. If the result is a literal, we wrap it in a message
and signal the location of the result inside. We also similarly handle ao-result
when the result is a single value and an explicit status code.

<a name="message_to_device-2"></a>

### message_to_device/2 ###

`message_to_device(Msg, Opts) -> any()`

Extract the device module from a message.

<a name="message_to_fun-3"></a>

### message_to_fun/3 ###

`message_to_fun(Msg, Key, Opts) -> any()`

Calculate the Erlang function that should be called to get a value for
a given key from a device.

This comes in 7 forms:
1. The message does not specify a device, so we use the default device.
2. The device has a `handler` key in its `Dev:info()` map, which is a
function that takes a key and returns a function to handle that key. We pass
the key as an additional argument to this function.
3. The device has a function of the name `Key`, which should be called
directly.
4. The device does not implement the key, but does have a default handler
for us to call. We pass it the key as an additional argument.
5. The device does not implement the key, and has no default handler. We use
the default device to handle the key.
Error: If the device is specified, but not loadable, we raise an error.

Returns {ok | add_key, Fun} where Fun is the function to call, and add_key
indicates that the key should be added to the start of the call's arguments.

<a name="normalize_key-1"></a>

### normalize_key/1 ###

`normalize_key(Key) -> any()`

Convert a key to a binary in normalized form.

<a name="normalize_key-2"></a>

### normalize_key/2 ###

`normalize_key(Key, Opts) -> any()`

<a name="normalize_keys-1"></a>

### normalize_keys/1 ###

`normalize_keys(Msg1) -> any()`

Ensure that a message is processable by the AO-Core resolver: No lists.

<a name="remove-2"></a>

### remove/2 ###

`remove(Msg, Key) -> any()`

Remove a key from a message, using its underlying device.

<a name="remove-3"></a>

### remove/3 ###

`remove(Msg, Key, Opts) -> any()`

<a name="resolve-2"></a>

### resolve/2 ###

`resolve(SingletonMsg, Opts) -> any()`

Get the value of a message's key by running its associated device
function. Optionally, takes options that control the runtime environment.
This function returns the raw result of the device function call:
`{ok | error, NewMessage}.`
The resolver is composed of a series of discrete phases:
1: Normalization.
2: Cache lookup.
3: Validation check.
4: Persistent-resolver lookup.
5: Device lookup.
6: Execution.
7: Cryptographic linking.
8: Result caching.
9: Notify waiters.
10: Fork worker.
11: Recurse or terminate.

<a name="resolve-3"></a>

### resolve/3 ###

`resolve(Msg1, Path, Opts) -> any()`

<a name="resolve_many-2"></a>

### resolve_many/2 ###

`resolve_many(ListMsg, Opts) -> any()`

Resolve a list of messages in sequence. Take the output of the first
message as the input for the next message. Once the last message is resolved,
return the result.
A `resolve_many` call with only a single ID will attempt to read the message
directly from the store. No execution is performed.

<a name="resolve_stage-4"></a>

### resolve_stage/4 * ###

`resolve_stage(X1, Raw, Msg2, Opts) -> any()`

<a name="resolve_stage-5"></a>

### resolve_stage/5 * ###

`resolve_stage(X1, Msg1, Msg2, ExecName, Opts) -> any()`

<a name="resolve_stage-6"></a>

### resolve_stage/6 * ###

`resolve_stage(X1, Func, Msg1, Msg2, ExecName, Opts) -> any()`

<a name="set-2"></a>

### set/2 ###

`set(Msg1, Msg2) -> any()`

Shortcut for setting a key in the message using its underlying device.
Like the `get/3` function, this function honors the `error_strategy` option.
`set` works with maps and recursive paths while maintaining the appropriate
`HashPath` for each step.

<a name="set-3"></a>

### set/3 ###

`set(RawMsg1, RawMsg2, Opts) -> any()`

<a name="set-4"></a>

### set/4 ###

`set(Msg1, Key, Value, Opts) -> any()`

<a name="subresolve-4"></a>

### subresolve/4 * ###

`subresolve(RawMsg1, DevID, ReqPath, Opts) -> any()`

Execute a sub-resolution.

<a name="truncate_args-2"></a>

### truncate_args/2 ###

`truncate_args(Fun, Args) -> any()`

Truncate the arguments of a function to the number of arguments it
actually takes.

<a name="verify_device_compatibility-2"></a>

### verify_device_compatibility/2 * ###

`verify_device_compatibility(Msg, Opts) -> any()`

Verify that a device is compatible with the current machine.


--- END OF FILE: docs/resources/source-code/hb_ao.md ---

--- START OF FILE: docs/resources/source-code/hb_app.md ---
# [Module hb_app.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_app.erl)




The main HyperBEAM application module.

__Behaviours:__ [`application`](application.md).

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#start-2">start/2</a></td><td></td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="start-2"></a>

### start/2 ###

`start(StartType, StartArgs) -> any()`

<a name="stop-1"></a>

### stop/1 ###

`stop(State) -> any()`


--- END OF FILE: docs/resources/source-code/hb_app.md ---

--- START OF FILE: docs/resources/source-code/hb_beamr_io.md ---
# [Module hb_beamr_io.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_beamr_io.erl)




Simple interface for memory management for Beamr instances.

<a name="description"></a>

## Description ##

It allows for reading and writing to memory, as well as allocating and
freeing memory by calling the WASM module's exported malloc and free
functions.

Unlike the majority of HyperBEAM modules, this module takes a defensive
approach to type checking, breaking from the conventional Erlang style,
such that failures are caught in the Erlang-side of functions rather than
in the C/WASM-side.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#do_read_string-3">do_read_string/3*</a></td><td></td></tr><tr><td valign="top"><a href="#free-2">free/2</a></td><td>Free space allocated in the Beamr instance's native memory via a
call to the exported free function from the WASM.</td></tr><tr><td valign="top"><a href="#malloc-2">malloc/2</a></td><td>Allocate space for (via an exported malloc function from the WASM) in
the Beamr instance's native memory.</td></tr><tr><td valign="top"><a href="#malloc_test-0">malloc_test/0*</a></td><td>Test allocating and freeing memory.</td></tr><tr><td valign="top"><a href="#read-3">read/3</a></td><td>Read a binary from the Beamr instance's native memory at a given offset
and of a given size.</td></tr><tr><td valign="top"><a href="#read_string-2">read_string/2</a></td><td>Simple helper function to read a string from the Beamr instance's native
memory at a given offset.</td></tr><tr><td valign="top"><a href="#read_string-3">read_string/3*</a></td><td></td></tr><tr><td valign="top"><a href="#read_test-0">read_test/0*</a></td><td>Test reading memory in and out of bounds.</td></tr><tr><td valign="top"><a href="#size-1">size/1</a></td><td>Get the size (in bytes) of the native memory allocated in the Beamr
instance.</td></tr><tr><td valign="top"><a href="#size_test-0">size_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#string_write_and_read_test-0">string_write_and_read_test/0*</a></td><td>Write and read strings to memory.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write a binary to the Beamr instance's native memory at a given offset.</td></tr><tr><td valign="top"><a href="#write_string-2">write_string/2</a></td><td>Simple helper function to allocate space for (via malloc) and write a
string to the Beamr instance's native memory.</td></tr><tr><td valign="top"><a href="#write_test-0">write_test/0*</a></td><td>Test writing memory in and out of bounds.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="do_read_string-3"></a>

### do_read_string/3 * ###

`do_read_string(WASM, Offset, ChunkSize) -> any()`

<a name="free-2"></a>

### free/2 ###

`free(WASM, Ptr) -> any()`

Free space allocated in the Beamr instance's native memory via a
call to the exported free function from the WASM.

<a name="malloc-2"></a>

### malloc/2 ###

`malloc(WASM, Size) -> any()`

Allocate space for (via an exported malloc function from the WASM) in
the Beamr instance's native memory.

<a name="malloc_test-0"></a>

### malloc_test/0 * ###

`malloc_test() -> any()`

Test allocating and freeing memory.

<a name="read-3"></a>

### read/3 ###

`read(WASM, Offset, Size) -> any()`

Read a binary from the Beamr instance's native memory at a given offset
and of a given size.

<a name="read_string-2"></a>

### read_string/2 ###

`read_string(Port, Offset) -> any()`

Simple helper function to read a string from the Beamr instance's native
memory at a given offset. Memory is read by default in chunks of 8 bytes,
but this can be overridden by passing a different chunk size. Strings are
assumed to be null-terminated.

<a name="read_string-3"></a>

### read_string/3 * ###

`read_string(WASM, Offset, ChunkSize) -> any()`

<a name="read_test-0"></a>

### read_test/0 * ###

`read_test() -> any()`

Test reading memory in and out of bounds.

<a name="size-1"></a>

### size/1 ###

`size(WASM) -> any()`

Get the size (in bytes) of the native memory allocated in the Beamr
instance. Note that WASM memory can never be reduced once granted to an
instance (although it can, of course, be reallocated _inside_ the
environment).

<a name="size_test-0"></a>

### size_test/0 * ###

`size_test() -> any()`

<a name="string_write_and_read_test-0"></a>

### string_write_and_read_test/0 * ###

`string_write_and_read_test() -> any()`

Write and read strings to memory.

<a name="write-3"></a>

### write/3 ###

`write(WASM, Offset, Data) -> any()`

Write a binary to the Beamr instance's native memory at a given offset.

<a name="write_string-2"></a>

### write_string/2 ###

`write_string(WASM, Data) -> any()`

Simple helper function to allocate space for (via malloc) and write a
string to the Beamr instance's native memory. This can be helpful for easily
pushing a string into the instance, such that the resulting pointer can be
passed to exported functions from the instance.
Assumes that the input is either an iolist or a binary, adding a null byte
to the end of the string.

<a name="write_test-0"></a>

### write_test/0 * ###

`write_test() -> any()`

Test writing memory in and out of bounds.


--- END OF FILE: docs/resources/source-code/hb_beamr_io.md ---

--- START OF FILE: docs/resources/source-code/hb_beamr.md ---
# [Module hb_beamr.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_beamr.erl)




BEAMR: A WAMR wrapper for BEAM.

<a name="description"></a>

## Description ##

Beamr is a library that allows you to run WASM modules in BEAM, using the
Webassembly Micro Runtime (WAMR) as its engine. Each WASM module is
executed using a Linked-In Driver (LID) that is loaded into BEAM. It is
designed with a focus on supporting long-running WASM executions that
interact with Erlang functions and processes easily.

Because each WASM module runs as an independent async worker, if you plan
to run many instances in parallel, you should be sure to configure the
BEAM to have enough async worker threads enabled (see `erl +A N` in the
Erlang manuals).

The core API is simple:

```

       start(WasmBinary) -> {ok, Port, Imports, Exports}
           Where:
               WasmBinary is the WASM binary to load.
               Port is the port to the LID.
               Imports is a list of tuples of the form {Module, Function,
                   Args, Signature}.
               Exports is a list of tuples of the form {Function, Args,
                   Signature}.
       stop(Port) -> ok
       call(Port, FunctionName, Args) -> {ok, Result}
           Where:
               FunctionName is the name of the function to call.
               Args is a list of Erlang terms (converted to WASM values by
                   BEAMR) that match the signature of the function.
               Result is a list of Erlang terms (converted from WASM values).
       call(Port, FunName, Args[, Import, State, Opts]) -> {ok, Res, NewState}
           Where:
               ImportFun is a function that will be called upon each import.
               ImportFun must have an arity of 2: Taking an arbitrary <code>state</code>
               term, and a map containing the <code>port</code>, <code>module</code>, <code>func</code>, <code>args</code>,<code>signature</code>, and the <code>options</code> map of the import.
               It must return a tuple of the form {ok, Response, NewState}.
       serialize(Port) -> {ok, Mem}
           Where:
               Port is the port to the LID.
               Mem is a binary representing the full WASM state.
       deserialize(Port, Mem) -> ok
           Where:
               Port is the port to the LID.
               Mem is a binary output of a previous <code>serialize/1</code> call.
```

BEAMR was designed for use in the HyperBEAM project, but is suitable for
deployment in other Erlang applications that need to run WASM modules. PRs
are welcome.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#benchmark_test-0">benchmark_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#call-3">call/3</a></td><td>Call a function in the WASM executor (see moduledoc for more details).</td></tr><tr><td valign="top"><a href="#call-4">call/4</a></td><td></td></tr><tr><td valign="top"><a href="#call-5">call/5</a></td><td></td></tr><tr><td valign="top"><a href="#call-6">call/6</a></td><td></td></tr><tr><td valign="top"><a href="#deserialize-2">deserialize/2</a></td><td>Deserialize a WASM state from a binary.</td></tr><tr><td valign="top"><a href="#dispatch_response-2">dispatch_response/2*</a></td><td>Check the type of an import response and dispatch it to a Beamr port.</td></tr><tr><td valign="top"><a href="#driver_loads_test-0">driver_loads_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#imported_function_test-0">imported_function_test/0*</a></td><td>Test that imported functions can be called from the WASM module.</td></tr><tr><td valign="top"><a href="#is_valid_arg_list-1">is_valid_arg_list/1*</a></td><td>Check that a list of arguments is valid for a WASM function call.</td></tr><tr><td valign="top"><a href="#load_driver-0">load_driver/0*</a></td><td>Load the driver for the WASM executor.</td></tr><tr><td valign="top"><a href="#monitor_call-4">monitor_call/4*</a></td><td>Synchonously monitor the WASM executor for a call result and any
imports that need to be handled.</td></tr><tr><td valign="top"><a href="#multiclient_test-0">multiclient_test/0*</a></td><td>Ensure that processes outside of the initial one can interact with
the WASM executor.</td></tr><tr><td valign="top"><a href="#serialize-1">serialize/1</a></td><td>Serialize the WASM state to a binary.</td></tr><tr><td valign="top"><a href="#simple_wasm_test-0">simple_wasm_test/0*</a></td><td>Test standalone <code>hb_beamr</code> correctly after loading a WASM module.</td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td>Start a WASM executor context.</td></tr><tr><td valign="top"><a href="#start-2">start/2</a></td><td></td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td>Stop a WASM executor context.</td></tr><tr><td valign="top"><a href="#stub-3">stub/3</a></td><td>Stub import function for the WASM executor.</td></tr><tr><td valign="top"><a href="#wasm64_test-0">wasm64_test/0*</a></td><td>Test that WASM Memory64 modules load and execute correctly.</td></tr><tr><td valign="top"><a href="#wasm_send-2">wasm_send/2</a></td><td></td></tr><tr><td valign="top"><a href="#worker-2">worker/2*</a></td><td>A worker process that is responsible for handling a WASM instance.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="benchmark_test-0"></a>

### benchmark_test/0 * ###

`benchmark_test() -> any()`

<a name="call-3"></a>

### call/3 ###

`call(PID, FuncRef, Args) -> any()`

Call a function in the WASM executor (see moduledoc for more details).

<a name="call-4"></a>

### call/4 ###

`call(PID, FuncRef, Args, ImportFun) -> any()`

<a name="call-5"></a>

### call/5 ###

`call(PID, FuncRef, Args, ImportFun, StateMsg) -> any()`

<a name="call-6"></a>

### call/6 ###

`call(PID, FuncRef, Args, ImportFun, StateMsg, Opts) -> any()`

<a name="deserialize-2"></a>

### deserialize/2 ###

`deserialize(WASM, Bin) -> any()`

Deserialize a WASM state from a binary.

<a name="dispatch_response-2"></a>

### dispatch_response/2 * ###

`dispatch_response(WASM, Term) -> any()`

Check the type of an import response and dispatch it to a Beamr port.

<a name="driver_loads_test-0"></a>

### driver_loads_test/0 * ###

`driver_loads_test() -> any()`

<a name="imported_function_test-0"></a>

### imported_function_test/0 * ###

`imported_function_test() -> any()`

Test that imported functions can be called from the WASM module.

<a name="is_valid_arg_list-1"></a>

### is_valid_arg_list/1 * ###

`is_valid_arg_list(Args) -> any()`

Check that a list of arguments is valid for a WASM function call.

<a name="load_driver-0"></a>

### load_driver/0 * ###

`load_driver() -> any()`

Load the driver for the WASM executor.

<a name="monitor_call-4"></a>

### monitor_call/4 * ###

`monitor_call(WASM, ImportFun, StateMsg, Opts) -> any()`

Synchonously monitor the WASM executor for a call result and any
imports that need to be handled.

<a name="multiclient_test-0"></a>

### multiclient_test/0 * ###

`multiclient_test() -> any()`

Ensure that processes outside of the initial one can interact with
the WASM executor.

<a name="serialize-1"></a>

### serialize/1 ###

`serialize(WASM) -> any()`

Serialize the WASM state to a binary.

<a name="simple_wasm_test-0"></a>

### simple_wasm_test/0 * ###

`simple_wasm_test() -> any()`

Test standalone `hb_beamr` correctly after loading a WASM module.

<a name="start-1"></a>

### start/1 ###

`start(WasmBinary) -> any()`

Start a WASM executor context. Yields a port to the LID, and the
imports and exports of the WASM module. Optionally, specify a mode
(wasm or aot) to indicate the type of WASM module being loaded.

<a name="start-2"></a>

### start/2 ###

`start(WasmBinary, Mode) -> any()`

<a name="stop-1"></a>

### stop/1 ###

`stop(WASM) -> any()`

Stop a WASM executor context.

<a name="stub-3"></a>

### stub/3 ###

`stub(Msg1, Msg2, Opts) -> any()`

Stub import function for the WASM executor.

<a name="wasm64_test-0"></a>

### wasm64_test/0 * ###

`wasm64_test() -> any()`

Test that WASM Memory64 modules load and execute correctly.

<a name="wasm_send-2"></a>

### wasm_send/2 ###

`wasm_send(WASM, Message) -> any()`

<a name="worker-2"></a>

### worker/2 * ###

`worker(Port, Listener) -> any()`

A worker process that is responsible for handling a WASM instance.
It wraps the WASM port, handling inputs and outputs from the WASM module.
The last sender to the port is always the recipient of its messages, so
be careful to ensure that there is only one active sender to the port at
any time.


--- END OF FILE: docs/resources/source-code/hb_beamr.md ---

--- START OF FILE: docs/resources/source-code/hb_cache_control.md ---
# [Module hb_cache_control.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_cache_control.erl)




Cache control logic for the AO-Core resolver.

<a name="description"></a>

## Description ##
It derives cache settings
from request, response, execution-local node Opts, as well as the global
node Opts. It applies these settings when asked to maybe store/lookup in
response to a request.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cache_binary_result_test-0">cache_binary_result_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#cache_message_result_test-0">cache_message_result_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#cache_source_to_cache_settings-1">cache_source_to_cache_settings/1*</a></td><td>Convert a cache source to a cache setting.</td></tr><tr><td valign="top"><a href="#derive_cache_settings-2">derive_cache_settings/2*</a></td><td>Derive cache settings from a series of option sources and the opts,
honoring precidence order.</td></tr><tr><td valign="top"><a href="#dispatch_cache_write-4">dispatch_cache_write/4*</a></td><td>Dispatch the cache write to a worker process if requested.</td></tr><tr><td valign="top"><a href="#empty_message_list_test-0">empty_message_list_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#exec_likely_faster_heuristic-3">exec_likely_faster_heuristic/3*</a></td><td>Determine whether we are likely to be faster looking up the result in
our cache (hoping we have it), or executing it directly.</td></tr><tr><td valign="top"><a href="#hashpath_ignore_prevents_storage_test-0">hashpath_ignore_prevents_storage_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#is_explicit_lookup-3">is_explicit_lookup/3*</a></td><td></td></tr><tr><td valign="top"><a href="#lookup-3">lookup/3*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_lookup-3">maybe_lookup/3</a></td><td>Handles cache lookup, modulated by the caching options requested by
the user.</td></tr><tr><td valign="top"><a href="#maybe_set-2">maybe_set/2*</a></td><td>Takes a key and two maps, returning the first map with the key set to
the value of the second map _if_ the value is not undefined.</td></tr><tr><td valign="top"><a href="#maybe_store-4">maybe_store/4</a></td><td>Write a resulting M3 message to the cache if requested.</td></tr><tr><td valign="top"><a href="#message_source_cache_control_test-0">message_source_cache_control_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#message_without_cache_control_test-0">message_without_cache_control_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#msg_precidence_overrides_test-0">msg_precidence_overrides_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#msg_with_cc-1">msg_with_cc/1*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_directives_test-0">multiple_directives_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#necessary_messages_not_found_error-3">necessary_messages_not_found_error/3*</a></td><td>Generate a message to return when the necessary messages to execute a
cache lookup are not found in the cache.</td></tr><tr><td valign="top"><a href="#no_cache_directive_test-0">no_cache_directive_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#no_store_directive_test-0">no_store_directive_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#only_if_cached_directive_test-0">only_if_cached_directive_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#only_if_cached_not_found_error-3">only_if_cached_not_found_error/3*</a></td><td>Generate a message to return when <code>only_if_cached</code> was specified, and
we don't have a cached result.</td></tr><tr><td valign="top"><a href="#opts_override_message_settings_test-0">opts_override_message_settings_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#opts_source_cache_control_test-0">opts_source_cache_control_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#opts_with_cc-1">opts_with_cc/1*</a></td><td></td></tr><tr><td valign="top"><a href="#specifiers_to_cache_settings-1">specifiers_to_cache_settings/1*</a></td><td>Convert a cache control list as received via HTTP headers into a
normalized map of simply whether we should store and/or lookup the result.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cache_binary_result_test-0"></a>

### cache_binary_result_test/0 * ###

`cache_binary_result_test() -> any()`

<a name="cache_message_result_test-0"></a>

### cache_message_result_test/0 * ###

`cache_message_result_test() -> any()`

<a name="cache_source_to_cache_settings-1"></a>

### cache_source_to_cache_settings/1 * ###

`cache_source_to_cache_settings(Msg) -> any()`

Convert a cache source to a cache setting. The setting _must_ always be
directly in the source, not an AO-Core-derivable value. The
`to_cache_control_map` function is used as the source of settings in all
cases, except where an `Opts` specifies that hashpaths should not be updated,
which leads to the result not being cached (as it may be stored with an
incorrect hashpath).

<a name="derive_cache_settings-2"></a>

### derive_cache_settings/2 * ###

`derive_cache_settings(SourceList, Opts) -> any()`

Derive cache settings from a series of option sources and the opts,
honoring precidence order. The Opts is used as the first source. Returns a
map with `store` and `lookup` keys, each of which is a boolean.

For example, if the last source has a `no_store`, the first expresses no
preference, but the Opts has `cache_control => [always]`, then the result
will contain a `store => true` entry.

<a name="dispatch_cache_write-4"></a>

### dispatch_cache_write/4 * ###

`dispatch_cache_write(Msg1, Msg2, Msg3, Opts) -> any()`

Dispatch the cache write to a worker process if requested.
Invoke the appropriate cache write function based on the type of the message.

<a name="empty_message_list_test-0"></a>

### empty_message_list_test/0 * ###

`empty_message_list_test() -> any()`

<a name="exec_likely_faster_heuristic-3"></a>

### exec_likely_faster_heuristic/3 * ###

`exec_likely_faster_heuristic(Msg1, Msg2, Opts) -> any()`

Determine whether we are likely to be faster looking up the result in
our cache (hoping we have it), or executing it directly.

<a name="hashpath_ignore_prevents_storage_test-0"></a>

### hashpath_ignore_prevents_storage_test/0 * ###

`hashpath_ignore_prevents_storage_test() -> any()`

<a name="is_explicit_lookup-3"></a>

### is_explicit_lookup/3 * ###

`is_explicit_lookup(Msg1, X2, Opts) -> any()`

<a name="lookup-3"></a>

### lookup/3 * ###

`lookup(Msg1, Msg2, Opts) -> any()`

<a name="maybe_lookup-3"></a>

### maybe_lookup/3 ###

`maybe_lookup(Msg1, Msg2, Opts) -> any()`

Handles cache lookup, modulated by the caching options requested by
the user. Honors the following `Opts` cache keys:
`only_if_cached`: If set and we do not find a result in the cache,
return an error with a `Cache-Status` of `miss` and
a 504 `Status`.
`no_cache`:       If set, the cached values are never used. Returns
`continue` to the caller.

<a name="maybe_set-2"></a>

### maybe_set/2 * ###

`maybe_set(Map1, Map2) -> any()`

Takes a key and two maps, returning the first map with the key set to
the value of the second map _if_ the value is not undefined.

<a name="maybe_store-4"></a>

### maybe_store/4 ###

`maybe_store(Msg1, Msg2, Msg3, Opts) -> any()`

Write a resulting M3 message to the cache if requested. The precedence
order of cache control sources is as follows:
1. The `Opts` map (letting the node operator have the final say).
2. The `Msg3` results message (granted by Msg1's device).
3. The `Msg2` message (the user's request).
Msg1 is not used, such that it can specify cache control information about
itself, without affecting its outputs.

<a name="message_source_cache_control_test-0"></a>

### message_source_cache_control_test/0 * ###

`message_source_cache_control_test() -> any()`

<a name="message_without_cache_control_test-0"></a>

### message_without_cache_control_test/0 * ###

`message_without_cache_control_test() -> any()`

<a name="msg_precidence_overrides_test-0"></a>

### msg_precidence_overrides_test/0 * ###

`msg_precidence_overrides_test() -> any()`

<a name="msg_with_cc-1"></a>

### msg_with_cc/1 * ###

`msg_with_cc(CC) -> any()`

<a name="multiple_directives_test-0"></a>

### multiple_directives_test/0 * ###

`multiple_directives_test() -> any()`

<a name="necessary_messages_not_found_error-3"></a>

### necessary_messages_not_found_error/3 * ###

`necessary_messages_not_found_error(Msg1, Msg2, Opts) -> any()`

Generate a message to return when the necessary messages to execute a
cache lookup are not found in the cache.

<a name="no_cache_directive_test-0"></a>

### no_cache_directive_test/0 * ###

`no_cache_directive_test() -> any()`

<a name="no_store_directive_test-0"></a>

### no_store_directive_test/0 * ###

`no_store_directive_test() -> any()`

<a name="only_if_cached_directive_test-0"></a>

### only_if_cached_directive_test/0 * ###

`only_if_cached_directive_test() -> any()`

<a name="only_if_cached_not_found_error-3"></a>

### only_if_cached_not_found_error/3 * ###

`only_if_cached_not_found_error(Msg1, Msg2, Opts) -> any()`

Generate a message to return when `only_if_cached` was specified, and
we don't have a cached result.

<a name="opts_override_message_settings_test-0"></a>

### opts_override_message_settings_test/0 * ###

`opts_override_message_settings_test() -> any()`

<a name="opts_source_cache_control_test-0"></a>

### opts_source_cache_control_test/0 * ###

`opts_source_cache_control_test() -> any()`

<a name="opts_with_cc-1"></a>

### opts_with_cc/1 * ###

`opts_with_cc(CC) -> any()`

<a name="specifiers_to_cache_settings-1"></a>

### specifiers_to_cache_settings/1 * ###

`specifiers_to_cache_settings(CCSpecifier) -> any()`

Convert a cache control list as received via HTTP headers into a
normalized map of simply whether we should store and/or lookup the result.


--- END OF FILE: docs/resources/source-code/hb_cache_control.md ---

--- START OF FILE: docs/resources/source-code/hb_cache_render.md ---
# [Module hb_cache_render.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_cache_render.erl)




A module that helps to render given Key graphs into the .dot files.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_arc-4">add_arc/4*</a></td><td>Add an arc to the graph.</td></tr><tr><td valign="top"><a href="#add_node-3">add_node/3*</a></td><td>Add a node to the graph.</td></tr><tr><td valign="top"><a href="#cache_path_to_dot-2">cache_path_to_dot/2</a></td><td>Generate a dot file from a cache path and options/store.</td></tr><tr><td valign="top"><a href="#cache_path_to_dot-3">cache_path_to_dot/3</a></td><td></td></tr><tr><td valign="top"><a href="#cache_path_to_graph-3">cache_path_to_graph/3*</a></td><td>Main function to collect graph elements.</td></tr><tr><td valign="top"><a href="#collect_output-2">collect_output/2*</a></td><td>Helper function to collect output from port.</td></tr><tr><td valign="top"><a href="#dot_to_svg-1">dot_to_svg/1</a></td><td>Convert a dot graph to SVG format.</td></tr><tr><td valign="top"><a href="#extract_label-1">extract_label/1*</a></td><td>Extract a label from a path.</td></tr><tr><td valign="top"><a href="#graph_to_dot-1">graph_to_dot/1*</a></td><td>Generate the DOT file from the graph.</td></tr><tr><td valign="top"><a href="#prepare_deeply_nested_complex_message-0">prepare_deeply_nested_complex_message/0</a></td><td></td></tr><tr><td valign="top"><a href="#prepare_signed_data-0">prepare_signed_data/0</a></td><td></td></tr><tr><td valign="top"><a href="#prepare_unsigned_data-0">prepare_unsigned_data/0</a></td><td></td></tr><tr><td valign="top"><a href="#process_composite_node-6">process_composite_node/6*</a></td><td>Process a composite (directory) node.</td></tr><tr><td valign="top"><a href="#process_simple_node-6">process_simple_node/6*</a></td><td>Process a simple (leaf) node.</td></tr><tr><td valign="top"><a href="#render-1">render/1</a></td><td>Render the given Key into svg.</td></tr><tr><td valign="top"><a href="#render-2">render/2</a></td><td></td></tr><tr><td valign="top"><a href="#test_signed-2">test_signed/2*</a></td><td></td></tr><tr><td valign="top"><a href="#test_unsigned-1">test_unsigned/1*</a></td><td></td></tr><tr><td valign="top"><a href="#traverse_store-4">traverse_store/4*</a></td><td>Traverse the store recursively to build the graph.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_arc-4"></a>

### add_arc/4 * ###

`add_arc(Graph, From, To, Label) -> any()`

Add an arc to the graph

<a name="add_node-3"></a>

### add_node/3 * ###

`add_node(Graph, ID, Color) -> any()`

Add a node to the graph

<a name="cache_path_to_dot-2"></a>

### cache_path_to_dot/2 ###

`cache_path_to_dot(ToRender, StoreOrOpts) -> any()`

Generate a dot file from a cache path and options/store

<a name="cache_path_to_dot-3"></a>

### cache_path_to_dot/3 ###

`cache_path_to_dot(ToRender, RenderOpts, StoreOrOpts) -> any()`

<a name="cache_path_to_graph-3"></a>

### cache_path_to_graph/3 * ###

`cache_path_to_graph(ToRender, GraphOpts, StoreOrOpts) -> any()`

Main function to collect graph elements

<a name="collect_output-2"></a>

### collect_output/2 * ###

`collect_output(Port, Acc) -> any()`

Helper function to collect output from port

<a name="dot_to_svg-1"></a>

### dot_to_svg/1 ###

`dot_to_svg(DotInput) -> any()`

Convert a dot graph to SVG format

<a name="extract_label-1"></a>

### extract_label/1 * ###

`extract_label(Path) -> any()`

Extract a label from a path

<a name="graph_to_dot-1"></a>

### graph_to_dot/1 * ###

`graph_to_dot(Graph) -> any()`

Generate the DOT file from the graph

<a name="prepare_deeply_nested_complex_message-0"></a>

### prepare_deeply_nested_complex_message/0 ###

`prepare_deeply_nested_complex_message() -> any()`

<a name="prepare_signed_data-0"></a>

### prepare_signed_data/0 ###

`prepare_signed_data() -> any()`

<a name="prepare_unsigned_data-0"></a>

### prepare_unsigned_data/0 ###

`prepare_unsigned_data() -> any()`

<a name="process_composite_node-6"></a>

### process_composite_node/6 * ###

`process_composite_node(Store, Key, Parent, ResolvedPath, JoinedPath, Graph) -> any()`

Process a composite (directory) node

<a name="process_simple_node-6"></a>

### process_simple_node/6 * ###

`process_simple_node(Store, Key, Parent, ResolvedPath, JoinedPath, Graph) -> any()`

Process a simple (leaf) node

<a name="render-1"></a>

### render/1 ###

`render(StoreOrOpts) -> any()`

Render the given Key into svg

<a name="render-2"></a>

### render/2 ###

`render(ToRender, StoreOrOpts) -> any()`

<a name="test_signed-2"></a>

### test_signed/2 * ###

`test_signed(Data, Wallet) -> any()`

<a name="test_unsigned-1"></a>

### test_unsigned/1 * ###

`test_unsigned(Data) -> any()`

<a name="traverse_store-4"></a>

### traverse_store/4 * ###

`traverse_store(Store, Key, Parent, Graph) -> any()`

Traverse the store recursively to build the graph


--- END OF FILE: docs/resources/source-code/hb_cache_render.md ---

--- START OF FILE: docs/resources/source-code/hb_cache.md ---
# [Module hb_cache.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_cache.erl)




A cache of AO-Core protocol messages and compute results.

<a name="description"></a>

## Description ##

HyperBEAM stores all paths in key value stores, abstracted by the `hb_store`
module. Each store has its own storage backend, but each works with simple
key-value pairs. Each store can write binary keys at paths, and link between
paths.

There are three layers to HyperBEAMs internal data representation on-disk:

1. The raw binary data, written to the store at the hash of the content.
Storing binary paths in this way effectively deduplicates the data.
2. The hashpath-graph of all content, stored as a set of links between
hashpaths, their keys, and the data that underlies them. This allows
all messages to share the same hashpath space, such that all requests
from users additively fill-in the hashpath space, minimizing duplicated
compute.
3. Messages, referrable by their IDs (committed or uncommitted). These are
stored as a set of links commitment IDs and the uncommitted message.

Before writing a message to the store, we convert it to Type-Annotated
Binary Messages (TABMs), such that each of the keys in the message is
either a map or a direct binary.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cache_suite_test_-0">cache_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#calculate_all_ids-2">calculate_all_ids/2*</a></td><td>Calculate the IDs for a message.</td></tr><tr><td valign="top"><a href="#do_read-4">do_read/4*</a></td><td>Read a path from the store.</td></tr><tr><td valign="top"><a href="#do_write_message-4">do_write_message/4*</a></td><td></td></tr><tr><td valign="top"><a href="#link-3">link/3</a></td><td>Make a link from one path to another in the store.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td>List all items under a given path.</td></tr><tr><td valign="top"><a href="#list_numbered-2">list_numbered/2</a></td><td>List all items in a directory, assuming they are numbered.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read the message at a path.</td></tr><tr><td valign="top"><a href="#read_resolved-3">read_resolved/3</a></td><td>Read the output of a prior computation, given Msg1, Msg2, and some
options.</td></tr><tr><td valign="top"><a href="#run_test-0">run_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#store_read-3">store_read/3*</a></td><td>List all of the subpaths of a given path, read each in turn, returning a
flat map.</td></tr><tr><td valign="top"><a href="#store_read-4">store_read/4*</a></td><td></td></tr><tr><td valign="top"><a href="#test_deeply_nested_complex_message-1">test_deeply_nested_complex_message/1*</a></td><td>Test deeply nested item storage and retrieval.</td></tr><tr><td valign="top"><a href="#test_device_map_cannot_be_written_test-0">test_device_map_cannot_be_written_test/0*</a></td><td>Test that message whose device is <code>#{}</code> cannot be written.</td></tr><tr><td valign="top"><a href="#test_message_with_message-1">test_message_with_message/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_signed-1">test_signed/1</a></td><td></td></tr><tr><td valign="top"><a href="#test_signed-2">test_signed/2*</a></td><td></td></tr><tr><td valign="top"><a href="#test_store_ans104_message-1">test_store_ans104_message/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_store_binary-1">test_store_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_store_simple_signed_message-1">test_store_simple_signed_message/1*</a></td><td>Test storing and retrieving a simple unsigned item.</td></tr><tr><td valign="top"><a href="#test_store_simple_unsigned_message-1">test_store_simple_unsigned_message/1*</a></td><td>Test storing and retrieving a simple unsigned item.</td></tr><tr><td valign="top"><a href="#test_store_unsigned_empty_message-1">test_store_unsigned_empty_message/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_unsigned-1">test_unsigned/1</a></td><td></td></tr><tr><td valign="top"><a href="#to_integer-1">to_integer/1*</a></td><td></td></tr><tr><td valign="top"><a href="#write-2">write/2</a></td><td>Write a message to the cache.</td></tr><tr><td valign="top"><a href="#write_binary-3">write_binary/3</a></td><td>Write a raw binary keys into the store and link it at a given hashpath.</td></tr><tr><td valign="top"><a href="#write_binary-4">write_binary/4*</a></td><td></td></tr><tr><td valign="top"><a href="#write_hashpath-2">write_hashpath/2</a></td><td>Write a hashpath and its message to the store and link it.</td></tr><tr><td valign="top"><a href="#write_hashpath-3">write_hashpath/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cache_suite_test_-0"></a>

### cache_suite_test_/0 * ###

`cache_suite_test_() -> any()`

<a name="calculate_all_ids-2"></a>

### calculate_all_ids/2 * ###

`calculate_all_ids(Bin, Opts) -> any()`

Calculate the IDs for a message.

<a name="do_read-4"></a>

### do_read/4 * ###

`do_read(Path, Store, Opts, AlreadyRead) -> any()`

Read a path from the store. Unsafe: May recurse indefinitely if circular
links are present.

<a name="do_write_message-4"></a>

### do_write_message/4 * ###

`do_write_message(Bin, AllIDs, Store, Opts) -> any()`

<a name="link-3"></a>

### link/3 ###

`link(Existing, New, Opts) -> any()`

Make a link from one path to another in the store.
Note: Argument order is `link(Src, Dst, Opts)`.

<a name="list-2"></a>

### list/2 ###

`list(Path, Opts) -> any()`

List all items under a given path.

<a name="list_numbered-2"></a>

### list_numbered/2 ###

`list_numbered(Path, Opts) -> any()`

List all items in a directory, assuming they are numbered.

<a name="read-2"></a>

### read/2 ###

`read(Path, Opts) -> any()`

Read the message at a path. Returns in `structured@1.0` format: Either a
richly typed map or a direct binary.

<a name="read_resolved-3"></a>

### read_resolved/3 ###

`read_resolved(MsgID1, MsgID2, Opts) -> any()`

Read the output of a prior computation, given Msg1, Msg2, and some
options.

<a name="run_test-0"></a>

### run_test/0 * ###

`run_test() -> any()`

<a name="store_read-3"></a>

### store_read/3 * ###

`store_read(Path, Store, Opts) -> any()`

List all of the subpaths of a given path, read each in turn, returning a
flat map. We track the paths that we have already read to avoid circular
links.

<a name="store_read-4"></a>

### store_read/4 * ###

`store_read(Path, Store, Opts, AlreadyRead) -> any()`

<a name="test_deeply_nested_complex_message-1"></a>

### test_deeply_nested_complex_message/1 * ###

`test_deeply_nested_complex_message(Opts) -> any()`

Test deeply nested item storage and retrieval

<a name="test_device_map_cannot_be_written_test-0"></a>

### test_device_map_cannot_be_written_test/0 * ###

`test_device_map_cannot_be_written_test() -> any()`

Test that message whose device is `#{}` cannot be written. If it were to
be written, it would cause an infinite loop.

<a name="test_message_with_message-1"></a>

### test_message_with_message/1 * ###

`test_message_with_message(Opts) -> any()`

<a name="test_signed-1"></a>

### test_signed/1 ###

`test_signed(Data) -> any()`

<a name="test_signed-2"></a>

### test_signed/2 * ###

`test_signed(Data, Wallet) -> any()`

<a name="test_store_ans104_message-1"></a>

### test_store_ans104_message/1 * ###

`test_store_ans104_message(Opts) -> any()`

<a name="test_store_binary-1"></a>

### test_store_binary/1 * ###

`test_store_binary(Opts) -> any()`

<a name="test_store_simple_signed_message-1"></a>

### test_store_simple_signed_message/1 * ###

`test_store_simple_signed_message(Opts) -> any()`

Test storing and retrieving a simple unsigned item

<a name="test_store_simple_unsigned_message-1"></a>

### test_store_simple_unsigned_message/1 * ###

`test_store_simple_unsigned_message(Opts) -> any()`

Test storing and retrieving a simple unsigned item

<a name="test_store_unsigned_empty_message-1"></a>

### test_store_unsigned_empty_message/1 * ###

`test_store_unsigned_empty_message(Opts) -> any()`

<a name="test_unsigned-1"></a>

### test_unsigned/1 ###

`test_unsigned(Data) -> any()`

<a name="to_integer-1"></a>

### to_integer/1 * ###

`to_integer(Value) -> any()`

<a name="write-2"></a>

### write/2 ###

`write(RawMsg, Opts) -> any()`

Write a message to the cache. For raw binaries, we write the data at
the hashpath of the data (by default the SHA2-256 hash of the data). We link
the unattended ID's hashpath for the keys (including `/commitments`) on the
message to the underlying data and recurse. We then link each commitment ID
to the uncommitted message, such that any of the committed or uncommitted IDs
can be read, and once in memory all of the commitments are available. For
deep messages, the commitments will also be read, such that the ID of the
outer message (which does not include its commitments) will be built upon
the commitments of the inner messages. We do not, however, store the IDs from
commitments on signed _inner_ messages. We may wish to revisit this.

<a name="write_binary-3"></a>

### write_binary/3 ###

`write_binary(Hashpath, Bin, Opts) -> any()`

Write a raw binary keys into the store and link it at a given hashpath.

<a name="write_binary-4"></a>

### write_binary/4 * ###

`write_binary(Hashpath, Bin, Store, Opts) -> any()`

<a name="write_hashpath-2"></a>

### write_hashpath/2 ###

`write_hashpath(Msg, Opts) -> any()`

Write a hashpath and its message to the store and link it.

<a name="write_hashpath-3"></a>

### write_hashpath/3 * ###

`write_hashpath(HP, Msg, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/hb_cache.md ---

--- START OF FILE: docs/resources/source-code/hb_client.md ---
# [Module hb_client.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_client.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_route-3">add_route/3</a></td><td></td></tr><tr><td valign="top"><a href="#arweave_timestamp-0">arweave_timestamp/0</a></td><td>Grab the latest block information from the Arweave gateway node.</td></tr><tr><td valign="top"><a href="#prefix_keys-3">prefix_keys/3*</a></td><td></td></tr><tr><td valign="top"><a href="#resolve-4">resolve/4</a></td><td>Resolve a message pair on a remote node.</td></tr><tr><td valign="top"><a href="#routes-2">routes/2</a></td><td></td></tr><tr><td valign="top"><a href="#upload-2">upload/2</a></td><td>Upload a data item to the bundler node.</td></tr><tr><td valign="top"><a href="#upload-3">upload/3*</a></td><td></td></tr><tr><td valign="top"><a href="#upload_empty_message_test-0">upload_empty_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#upload_empty_raw_ans104_test-0">upload_empty_raw_ans104_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#upload_raw_ans104_test-0">upload_raw_ans104_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#upload_raw_ans104_with_anchor_test-0">upload_raw_ans104_with_anchor_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#upload_single_layer_message_test-0">upload_single_layer_message_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_route-3"></a>

### add_route/3 ###

`add_route(Node, Route, Opts) -> any()`

<a name="arweave_timestamp-0"></a>

### arweave_timestamp/0 ###

`arweave_timestamp() -> any()`

Grab the latest block information from the Arweave gateway node.

<a name="prefix_keys-3"></a>

### prefix_keys/3 * ###

`prefix_keys(Prefix, Message, Opts) -> any()`

<a name="resolve-4"></a>

### resolve/4 ###

`resolve(Node, Msg1, Msg2, Opts) -> any()`

Resolve a message pair on a remote node.
The message pair is first transformed into a singleton request, by
prefixing the keys in both messages for the path segment that they relate to,
and then adjusting the "Path" field from the second message.

<a name="routes-2"></a>

### routes/2 ###

`routes(Node, Opts) -> any()`

<a name="upload-2"></a>

### upload/2 ###

`upload(Msg, Opts) -> any()`

Upload a data item to the bundler node.

<a name="upload-3"></a>

### upload/3 * ###

`upload(Msg, Opts, X3) -> any()`

<a name="upload_empty_message_test-0"></a>

### upload_empty_message_test/0 * ###

`upload_empty_message_test() -> any()`

<a name="upload_empty_raw_ans104_test-0"></a>

### upload_empty_raw_ans104_test/0 * ###

`upload_empty_raw_ans104_test() -> any()`

<a name="upload_raw_ans104_test-0"></a>

### upload_raw_ans104_test/0 * ###

`upload_raw_ans104_test() -> any()`

<a name="upload_raw_ans104_with_anchor_test-0"></a>

### upload_raw_ans104_with_anchor_test/0 * ###

`upload_raw_ans104_with_anchor_test() -> any()`

<a name="upload_single_layer_message_test-0"></a>

### upload_single_layer_message_test/0 * ###

`upload_single_layer_message_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_client.md ---

--- START OF FILE: docs/resources/source-code/hb_crypto.md ---
# [Module hb_crypto.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_crypto.erl)




Implements the cryptographic functions and wraps the primitives
used in HyperBEAM.

<a name="description"></a>

## Description ##

Abstracted such that this (extremely!) dangerous code
can be carefully managed.

HyperBEAM currently implements two hashpath algorithms:

* `sha-256-chain`: A simple chained SHA-256 hash.

* `accumulate-256`: A SHA-256 hash that chains the given IDs and accumulates
their values into a single commitment.

The accumulate algorithm is experimental and at this point only exists to
allow us to test multiple HashPath algorithms in HyperBEAM.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#accumulate-2">accumulate/2</a></td><td>Accumulate two IDs into a single commitment.</td></tr><tr><td valign="top"><a href="#count_zeroes-1">count_zeroes/1*</a></td><td>Count the number of leading zeroes in a bitstring.</td></tr><tr><td valign="top"><a href="#sha256-1">sha256/1</a></td><td>Wrap Erlang's <code>crypto:hash/2</code> to provide a standard interface.</td></tr><tr><td valign="top"><a href="#sha256_chain-2">sha256_chain/2</a></td><td>Add a new ID to the end of a SHA-256 hash chain.</td></tr><tr><td valign="top"><a href="#sha256_chain_test-0">sha256_chain_test/0*</a></td><td>Check that <code>sha-256-chain</code> correctly produces a hash matching
the machine's OpenSSL lib's output.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="accumulate-2"></a>

### accumulate/2 ###

`accumulate(ID1, ID2) -> any()`

Accumulate two IDs into a single commitment.
Experimental! This is not necessarily a cryptographically-secure operation.

<a name="count_zeroes-1"></a>

### count_zeroes/1 * ###

`count_zeroes(X1) -> any()`

Count the number of leading zeroes in a bitstring.

<a name="sha256-1"></a>

### sha256/1 ###

`sha256(Data) -> any()`

Wrap Erlang's `crypto:hash/2` to provide a standard interface.
Under-the-hood, this uses OpenSSL.

<a name="sha256_chain-2"></a>

### sha256_chain/2 ###

`sha256_chain(ID1, ID2) -> any()`

Add a new ID to the end of a SHA-256 hash chain.

<a name="sha256_chain_test-0"></a>

### sha256_chain_test/0 * ###

`sha256_chain_test() -> any()`

Check that `sha-256-chain` correctly produces a hash matching
the machine's OpenSSL lib's output. Further (in case of a bug in our
or Erlang's usage of OpenSSL), check that the output has at least has
a high level of entropy.


--- END OF FILE: docs/resources/source-code/hb_crypto.md ---

--- START OF FILE: docs/resources/source-code/hb_debugger.md ---
# [Module hb_debugger.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_debugger.erl)




A module that provides bootstrapping interfaces for external debuggers
to connect to HyperBEAM.

<a name="description"></a>

## Description ##

The simplest way to utilize an external graphical debugger is to use the
`erlang-ls` extension for VS Code, Emacs, or other Language Server Protocol
(LSP) compatible editors. This repository contains a `launch.json`
configuration file for VS Code that can be used to spawn a new HyperBEAM,
attach the debugger to it, and execute the specified `Module:Function(Args)`.
Additionally, the node can be started with `rebar3 debugging` in order to
allow access to the console while also allowing the debugger to attach.

Boot time is approximately 10 seconds.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#await_breakpoint-0">await_breakpoint/0</a></td><td>Await a new breakpoint being set by the debugger.</td></tr><tr><td valign="top"><a href="#await_breakpoint-1">await_breakpoint/1*</a></td><td></td></tr><tr><td valign="top"><a href="#await_debugger-0">await_debugger/0*</a></td><td>Await a debugger to be attached to the node.</td></tr><tr><td valign="top"><a href="#await_debugger-1">await_debugger/1*</a></td><td></td></tr><tr><td valign="top"><a href="#interpret-1">interpret/1*</a></td><td>Attempt to interpret a specified module to load it into the debugger.</td></tr><tr><td valign="top"><a href="#is_debugging_node_connected-0">is_debugging_node_connected/0*</a></td><td>Is another Distributed Erlang node connected to us?.</td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td></td></tr><tr><td valign="top"><a href="#start_and_break-2">start_and_break/2</a></td><td>A bootstrapping function to wait for an external debugger to be attached,
then add a breakpoint on the specified <code>Module:Function(Args)</code>, then call it.</td></tr><tr><td valign="top"><a href="#start_and_break-3">start_and_break/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="await_breakpoint-0"></a>

### await_breakpoint/0 ###

`await_breakpoint() -> any()`

Await a new breakpoint being set by the debugger.

<a name="await_breakpoint-1"></a>

### await_breakpoint/1 * ###

`await_breakpoint(N) -> any()`

<a name="await_debugger-0"></a>

### await_debugger/0 * ###

`await_debugger() -> any()`

Await a debugger to be attached to the node.

<a name="await_debugger-1"></a>

### await_debugger/1 * ###

`await_debugger(N) -> any()`

<a name="interpret-1"></a>

### interpret/1 * ###

`interpret(Module) -> any()`

Attempt to interpret a specified module to load it into the debugger.
`int:i/1` seems to have an issue that will cause it to fail sporadically
with `error:undef` on some modules. This error appears not to be catchable
through the normal means. Subsequently, we attempt the load in a separate
process and wait for it to complete. If we do not receive a response in a
reasonable amount of time, we assume that the module failed to load and
return `false`.

<a name="is_debugging_node_connected-0"></a>

### is_debugging_node_connected/0 * ###

`is_debugging_node_connected() -> any()`

Is another Distributed Erlang node connected to us?

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

<a name="start_and_break-2"></a>

### start_and_break/2 ###

`start_and_break(Module, Function) -> any()`

A bootstrapping function to wait for an external debugger to be attached,
then add a breakpoint on the specified `Module:Function(Args)`, then call it.

<a name="start_and_break-3"></a>

### start_and_break/3 ###

`start_and_break(Module, Function, Args) -> any()`


--- END OF FILE: docs/resources/source-code/hb_debugger.md ---

--- START OF FILE: docs/resources/source-code/hb_escape.md ---
# [Module hb_escape.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_escape.erl)




Escape and unescape mixed case values for use in HTTP headers.

<a name="description"></a>

## Description ##
This is necessary for encodings of AO-Core messages for transmission in
HTTP/2 and HTTP/3, because uppercase header keys are explicitly disallowed.
While most map keys in HyperBEAM are normalized to lowercase, IDs are not.
Subsequently, we encode all header keys to lowercase %-encoded URI-style
strings because transmission.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decode a URI-encoded string back to a binary.</td></tr><tr><td valign="top"><a href="#decode_keys-1">decode_keys/1</a></td><td>Return a message with all of its keys decoded.</td></tr><tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Encode a binary as a URI-encoded string.</td></tr><tr><td valign="top"><a href="#encode_keys-1">encode_keys/1</a></td><td>URI encode keys in the base layer of a message.</td></tr><tr><td valign="top"><a href="#escape_byte-1">escape_byte/1*</a></td><td>Escape a single byte as a URI-encoded string.</td></tr><tr><td valign="top"><a href="#escape_unescape_identity_test-0">escape_unescape_identity_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#escape_unescape_special_chars_test-0">escape_unescape_special_chars_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#hex_digit-1">hex_digit/1*</a></td><td></td></tr><tr><td valign="top"><a href="#hex_value-1">hex_value/1*</a></td><td></td></tr><tr><td valign="top"><a href="#percent_escape-1">percent_escape/1*</a></td><td>Escape a list of characters as a URI-encoded string.</td></tr><tr><td valign="top"><a href="#percent_unescape-1">percent_unescape/1*</a></td><td>Unescape a URI-encoded string.</td></tr><tr><td valign="top"><a href="#unescape_specific_test-0">unescape_specific_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#uppercase_test-0">uppercase_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="decode-1"></a>

### decode/1 ###

`decode(Bin) -> any()`

Decode a URI-encoded string back to a binary.

<a name="decode_keys-1"></a>

### decode_keys/1 ###

`decode_keys(Msg) -> any()`

Return a message with all of its keys decoded.

<a name="encode-1"></a>

### encode/1 ###

`encode(Bin) -> any()`

Encode a binary as a URI-encoded string.

<a name="encode_keys-1"></a>

### encode_keys/1 ###

`encode_keys(Msg) -> any()`

URI encode keys in the base layer of a message. Does not recurse.

<a name="escape_byte-1"></a>

### escape_byte/1 * ###

`escape_byte(C) -> any()`

Escape a single byte as a URI-encoded string.

<a name="escape_unescape_identity_test-0"></a>

### escape_unescape_identity_test/0 * ###

`escape_unescape_identity_test() -> any()`

<a name="escape_unescape_special_chars_test-0"></a>

### escape_unescape_special_chars_test/0 * ###

`escape_unescape_special_chars_test() -> any()`

<a name="hex_digit-1"></a>

### hex_digit/1 * ###

`hex_digit(N) -> any()`

<a name="hex_value-1"></a>

### hex_value/1 * ###

`hex_value(C) -> any()`

<a name="percent_escape-1"></a>

### percent_escape/1 * ###

`percent_escape(Cs) -> any()`

Escape a list of characters as a URI-encoded string.

<a name="percent_unescape-1"></a>

### percent_unescape/1 * ###

`percent_unescape(Cs) -> any()`

Unescape a URI-encoded string.

<a name="unescape_specific_test-0"></a>

### unescape_specific_test/0 * ###

`unescape_specific_test() -> any()`

<a name="uppercase_test-0"></a>

### uppercase_test/0 * ###

`uppercase_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_escape.md ---

--- START OF FILE: docs/resources/source-code/hb_event.md ---
# [Module hb_event.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_event.erl)




Wrapper for incrementing prometheus counters.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#await_prometheus_started-0">await_prometheus_started/0*</a></td><td>Delay the event server until prometheus is started.</td></tr><tr><td valign="top"><a href="#handle_events-0">handle_events/0*</a></td><td></td></tr><tr><td valign="top"><a href="#handle_tracer-3">handle_tracer/3*</a></td><td></td></tr><tr><td valign="top"><a href="#increment-3">increment/3</a></td><td>Increment the counter for the given topic and message.</td></tr><tr><td valign="top"><a href="#log-1">log/1</a></td><td>Debugging log logging function.</td></tr><tr><td valign="top"><a href="#log-2">log/2</a></td><td></td></tr><tr><td valign="top"><a href="#log-3">log/3</a></td><td></td></tr><tr><td valign="top"><a href="#log-4">log/4</a></td><td></td></tr><tr><td valign="top"><a href="#log-5">log/5</a></td><td></td></tr><tr><td valign="top"><a href="#log-6">log/6</a></td><td></td></tr><tr><td valign="top"><a href="#parse_name-1">parse_name/1*</a></td><td></td></tr><tr><td valign="top"><a href="#server-0">server/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="await_prometheus_started-0"></a>

### await_prometheus_started/0 * ###

`await_prometheus_started() -> any()`

Delay the event server until prometheus is started.

<a name="handle_events-0"></a>

### handle_events/0 * ###

`handle_events() -> any()`

<a name="handle_tracer-3"></a>

### handle_tracer/3 * ###

`handle_tracer(Topic, X, Opts) -> any()`

<a name="increment-3"></a>

### increment/3 ###

`increment(Topic, Message, Opts) -> any()`

Increment the counter for the given topic and message. Registers the
counter if it doesn't exist. If the topic is `global`, the message is ignored.
This means that events must specify a topic if they want to be counted,
filtering debug messages. Similarly, events with a topic that begins with
`debug` are ignored.

<a name="log-1"></a>

### log/1 ###

`log(X) -> any()`

Debugging log logging function. For now, it just prints to standard
error.

<a name="log-2"></a>

### log/2 ###

`log(Topic, X) -> any()`

<a name="log-3"></a>

### log/3 ###

`log(Topic, X, Mod) -> any()`

<a name="log-4"></a>

### log/4 ###

`log(Topic, X, Mod, Func) -> any()`

<a name="log-5"></a>

### log/5 ###

`log(Topic, X, Mod, Func, Line) -> any()`

<a name="log-6"></a>

### log/6 ###

`log(Topic, X, Mod, Func, Line, Opts) -> any()`

<a name="parse_name-1"></a>

### parse_name/1 * ###

`parse_name(Name) -> any()`

<a name="server-0"></a>

### server/0 * ###

`server() -> any()`


--- END OF FILE: docs/resources/source-code/hb_event.md ---

--- START OF FILE: docs/resources/source-code/hb_examples.md ---
# [Module hb_examples.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_examples.erl)




This module contains end-to-end tests for Hyperbeam, accessing through
the HTTP interface.

<a name="description"></a>

## Description ##
As well as testing the system, you can use these tests
as examples of how to interact with HyperBEAM nodes.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#create_schedule_aos2_test_disabled-0">create_schedule_aos2_test_disabled/0*</a></td><td></td></tr><tr><td valign="top"><a href="#paid_wasm_test-0">paid_wasm_test/0*</a></td><td>Gain signed WASM responses from a node and verify them.</td></tr><tr><td valign="top"><a href="#relay_with_payments_test-0">relay_with_payments_test/0*</a></td><td>Start a node running the simple pay meta device, and use it to relay
a message for a client.</td></tr><tr><td valign="top"><a href="#schedule-2">schedule/2*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule-3">schedule/3*</a></td><td></td></tr><tr><td valign="top"><a href="#schedule-4">schedule/4*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="create_schedule_aos2_test_disabled-0"></a>

### create_schedule_aos2_test_disabled/0 * ###

`create_schedule_aos2_test_disabled() -> any()`

<a name="paid_wasm_test-0"></a>

### paid_wasm_test/0 * ###

`paid_wasm_test() -> any()`

Gain signed WASM responses from a node and verify them.
1. Start the client with a small balance.
2. Execute a simple WASM function on the host node.
3. Verify the response is correct and signed by the host node.
4. Get the balance of the client and verify it has been deducted.

<a name="relay_with_payments_test-0"></a>

### relay_with_payments_test/0 * ###

`relay_with_payments_test() -> any()`

Start a node running the simple pay meta device, and use it to relay
a message for a client. We must ensure:
1. When the client has no balance, the relay fails.
2. The operator is able to topup for the client.
3. The client has the correct balance after the topup.
4. The relay succeeds when the client has enough balance.
5. The received message is signed by the host using http-sig and validates
correctly.

<a name="schedule-2"></a>

### schedule/2 * ###

`schedule(ProcMsg, Target) -> any()`

<a name="schedule-3"></a>

### schedule/3 * ###

`schedule(ProcMsg, Target, Wallet) -> any()`

<a name="schedule-4"></a>

### schedule/4 * ###

`schedule(ProcMsg, Target, Wallet, Node) -> any()`


--- END OF FILE: docs/resources/source-code/hb_examples.md ---

--- START OF FILE: docs/resources/source-code/hb_features.md ---
# [Module hb_features.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_features.erl)




A module that exports a list of feature flags that the node supports
using the `-ifdef` macro.

<a name="description"></a>

## Description ##
As a consequence, this module acts as a proxy of information between the
build system and the runtime execution environment.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#all-0">all/0</a></td><td>Returns a list of all feature flags that the node supports.</td></tr><tr><td valign="top"><a href="#enabled-1">enabled/1</a></td><td>Returns true if the feature flag is enabled.</td></tr><tr><td valign="top"><a href="#genesis_wasm-0">genesis_wasm/0</a></td><td></td></tr><tr><td valign="top"><a href="#http3-0">http3/0</a></td><td></td></tr><tr><td valign="top"><a href="#rocksdb-0">rocksdb/0</a></td><td></td></tr><tr><td valign="top"><a href="#test-0">test/0</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="all-0"></a>

### all/0 ###

`all() -> any()`

Returns a list of all feature flags that the node supports.

<a name="enabled-1"></a>

### enabled/1 ###

`enabled(Feature) -> any()`

Returns true if the feature flag is enabled.

<a name="genesis_wasm-0"></a>

### genesis_wasm/0 ###

`genesis_wasm() -> any()`

<a name="http3-0"></a>

### http3/0 ###

`http3() -> any()`

<a name="rocksdb-0"></a>

### rocksdb/0 ###

`rocksdb() -> any()`

<a name="test-0"></a>

### test/0 ###

`test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_features.md ---

--- START OF FILE: docs/resources/source-code/hb_gateway_client.md ---
# [Module hb_gateway_client.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_gateway_client.erl)




Implementation of Arweave's GraphQL API to gain access to specific
items of data stored on the network.

<a name="description"></a>

## Description ##
This module must be used to get full HyperBEAM `structured@1.0` form messages
from data items stored on the network, as Arweave gateways do not presently
expose all necessary fields to retrieve this information outside of the
GraphQL API. When gateways integrate serving in `httpsig@1.0` form, this
module will be deprecated.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#ans104_no_data_item_test-0">ans104_no_data_item_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#ao_dataitem_test-0">ao_dataitem_test/0*</a></td><td>Test optimistic index.</td></tr><tr><td valign="top"><a href="#data-2">data/2</a></td><td>Get the data associated with a transaction by its ID, using the node's
Arweave <code>gateway</code> peers.</td></tr><tr><td valign="top"><a href="#decode_id_or_null-1">decode_id_or_null/1*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_or_null-1">decode_or_null/1*</a></td><td></td></tr><tr><td valign="top"><a href="#item_spec-0">item_spec/0*</a></td><td>Gives the fields of a transaction that are needed to construct an
ANS-104 message.</td></tr><tr><td valign="top"><a href="#l1_transaction_test-0">l1_transaction_test/0*</a></td><td>Test l1 message from graphql.</td></tr><tr><td valign="top"><a href="#l2_dataitem_test-0">l2_dataitem_test/0*</a></td><td>Test l2 message from graphql.</td></tr><tr><td valign="top"><a href="#normalize_null-1">normalize_null/1*</a></td><td></td></tr><tr><td valign="top"><a href="#query-2">query/2*</a></td><td>Run a GraphQL request encoded as a binary.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Get a data item (including data and tags) by its ID, using the node's
GraphQL peers.</td></tr><tr><td valign="top"><a href="#result_to_message-2">result_to_message/2</a></td><td>Takes a GraphQL item node, matches it with the appropriate data from a
gateway, then returns <code>{ok, ParsedMsg}</code>.</td></tr><tr><td valign="top"><a href="#result_to_message-3">result_to_message/3*</a></td><td></td></tr><tr><td valign="top"><a href="#scheduler_location-2">scheduler_location/2</a></td><td>Find the location of the scheduler based on its ID, through GraphQL.</td></tr><tr><td valign="top"><a href="#scheduler_location_test-0">scheduler_location_test/0*</a></td><td>Test that we can get the scheduler location.</td></tr><tr><td valign="top"><a href="#subindex_to_tags-1">subindex_to_tags/1*</a></td><td>Takes a list of messages with <code>name</code> and <code>value</code> fields, and formats
them as a GraphQL <code>tags</code> argument.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="ans104_no_data_item_test-0"></a>

### ans104_no_data_item_test/0 * ###

`ans104_no_data_item_test() -> any()`

<a name="ao_dataitem_test-0"></a>

### ao_dataitem_test/0 * ###

`ao_dataitem_test() -> any()`

Test optimistic index

<a name="data-2"></a>

### data/2 ###

`data(ID, Opts) -> any()`

Get the data associated with a transaction by its ID, using the node's
Arweave `gateway` peers. The item is expected to be available in its
unmodified (by caches or other proxies) form at the following location:
https://<gateway>/raw/<id>
where `&lt;id&gt;` is the base64-url-encoded transaction ID.

<a name="decode_id_or_null-1"></a>

### decode_id_or_null/1 * ###

`decode_id_or_null(Bin) -> any()`

<a name="decode_or_null-1"></a>

### decode_or_null/1 * ###

`decode_or_null(Bin) -> any()`

<a name="item_spec-0"></a>

### item_spec/0 * ###

`item_spec() -> any()`

Gives the fields of a transaction that are needed to construct an
ANS-104 message.

<a name="l1_transaction_test-0"></a>

### l1_transaction_test/0 * ###

`l1_transaction_test() -> any()`

Test l1 message from graphql

<a name="l2_dataitem_test-0"></a>

### l2_dataitem_test/0 * ###

`l2_dataitem_test() -> any()`

Test l2 message from graphql

<a name="normalize_null-1"></a>

### normalize_null/1 * ###

`normalize_null(Bin) -> any()`

<a name="query-2"></a>

### query/2 * ###

`query(Query, Opts) -> any()`

Run a GraphQL request encoded as a binary. The node message may contain
a list of URLs to use, optionally as a tuple with an additional map of options
to use for the request.

<a name="read-2"></a>

### read/2 ###

`read(ID, Opts) -> any()`

Get a data item (including data and tags) by its ID, using the node's
GraphQL peers.
It uses the following GraphQL schema:
type Transaction {
id: ID!
anchor: String!
signature: String!
recipient: String!
owner: Owner { address: String! key: String! }!
fee: Amount!
quantity: Amount!
data: MetaData!
tags: [Tag { name: String! value: String! }!]!
}
type Amount {
winston: String!
ar: String!
}

<a name="result_to_message-2"></a>

### result_to_message/2 ###

`result_to_message(Item, Opts) -> any()`

Takes a GraphQL item node, matches it with the appropriate data from a
gateway, then returns `{ok, ParsedMsg}`.

<a name="result_to_message-3"></a>

### result_to_message/3 * ###

`result_to_message(ExpectedID, Item, Opts) -> any()`

<a name="scheduler_location-2"></a>

### scheduler_location/2 ###

`scheduler_location(Address, Opts) -> any()`

Find the location of the scheduler based on its ID, through GraphQL.

<a name="scheduler_location_test-0"></a>

### scheduler_location_test/0 * ###

`scheduler_location_test() -> any()`

Test that we can get the scheduler location.

<a name="subindex_to_tags-1"></a>

### subindex_to_tags/1 * ###

`subindex_to_tags(Subindex) -> any()`

Takes a list of messages with `name` and `value` fields, and formats
them as a GraphQL `tags` argument.


--- END OF FILE: docs/resources/source-code/hb_gateway_client.md ---

--- START OF FILE: docs/resources/source-code/hb_http_benchmark_tests.md ---
# [Module hb_http_benchmark_tests.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_http_benchmark_tests.erl)





--- END OF FILE: docs/resources/source-code/hb_http_benchmark_tests.md ---

--- START OF FILE: docs/resources/source-code/hb_http_client_sup.md ---
# [Module hb_http_client_sup.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_http_client_sup.erl)




The supervisor for the gun HTTP client wrapper.

__Behaviours:__ [`supervisor`](supervisor.md).

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="init-1"></a>

### init/1 ###

`init(Opts) -> any()`

<a name="start_link-1"></a>

### start_link/1 ###

`start_link(Opts) -> any()`


--- END OF FILE: docs/resources/source-code/hb_http_client_sup.md ---

--- START OF FILE: docs/resources/source-code/hb_http_client.md ---
# [Module hb_http_client.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_http_client.erl)




A wrapper library for gun.

__Behaviours:__ [`gen_server`](gen_server.md).

<a name="description"></a>

## Description ##
This module originates from the Arweave
project, and has been modified for use in HyperBEAM.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#await_response-2">await_response/2*</a></td><td></td></tr><tr><td valign="top"><a href="#dec_prometheus_gauge-1">dec_prometheus_gauge/1*</a></td><td>Safe wrapper for prometheus_gauge:dec/2.</td></tr><tr><td valign="top"><a href="#download_metric-2">download_metric/2*</a></td><td></td></tr><tr><td valign="top"><a href="#get_status_class-1">get_status_class/1*</a></td><td>Return the HTTP status class label for cowboy_requests_total and
gun_requests_total metrics.</td></tr><tr><td valign="top"><a href="#gun_req-3">gun_req/3*</a></td><td></td></tr><tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td></td></tr><tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td></td></tr><tr><td valign="top"><a href="#handle_info-2">handle_info/2</a></td><td></td></tr><tr><td valign="top"><a href="#httpc_req-3">httpc_req/3*</a></td><td></td></tr><tr><td valign="top"><a href="#inc_prometheus_counter-3">inc_prometheus_counter/3*</a></td><td></td></tr><tr><td valign="top"><a href="#inc_prometheus_gauge-1">inc_prometheus_gauge/1*</a></td><td>Safe wrapper for prometheus_gauge:inc/2.</td></tr><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#init_prometheus-1">init_prometheus/1*</a></td><td></td></tr><tr><td valign="top"><a href="#log-5">log/5*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_invoke_monitor-2">maybe_invoke_monitor/2*</a></td><td>Invoke the HTTP monitor message with AO-Core, if it is set in the
node message key.</td></tr><tr><td valign="top"><a href="#method_to_bin-1">method_to_bin/1*</a></td><td></td></tr><tr><td valign="top"><a href="#open_connection-2">open_connection/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_peer-2">parse_peer/2*</a></td><td></td></tr><tr><td valign="top"><a href="#record_duration-2">record_duration/2*</a></td><td>Record the duration of the request in an async process.</td></tr><tr><td valign="top"><a href="#record_response_status-3">record_response_status/3*</a></td><td></td></tr><tr><td valign="top"><a href="#reply_error-2">reply_error/2*</a></td><td></td></tr><tr><td valign="top"><a href="#req-2">req/2</a></td><td></td></tr><tr><td valign="top"><a href="#req-3">req/3*</a></td><td></td></tr><tr><td valign="top"><a href="#request-3">request/3*</a></td><td></td></tr><tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td></td></tr><tr><td valign="top"><a href="#terminate-2">terminate/2</a></td><td></td></tr><tr><td valign="top"><a href="#upload_metric-1">upload_metric/1*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="await_response-2"></a>

### await_response/2 * ###

`await_response(Args, Opts) -> any()`

<a name="dec_prometheus_gauge-1"></a>

### dec_prometheus_gauge/1 * ###

`dec_prometheus_gauge(Name) -> any()`

Safe wrapper for prometheus_gauge:dec/2.

<a name="download_metric-2"></a>

### download_metric/2 * ###

`download_metric(Data, X2) -> any()`

<a name="get_status_class-1"></a>

### get_status_class/1 * ###

`get_status_class(Data) -> any()`

Return the HTTP status class label for cowboy_requests_total and
gun_requests_total metrics.

<a name="gun_req-3"></a>

### gun_req/3 * ###

`gun_req(Args, ReestablishedConnection, Opts) -> any()`

<a name="handle_call-3"></a>

### handle_call/3 ###

`handle_call(Request, From, State) -> any()`

<a name="handle_cast-2"></a>

### handle_cast/2 ###

`handle_cast(Cast, State) -> any()`

<a name="handle_info-2"></a>

### handle_info/2 ###

`handle_info(Message, State) -> any()`

<a name="httpc_req-3"></a>

### httpc_req/3 * ###

`httpc_req(Args, X2, Opts) -> any()`

<a name="inc_prometheus_counter-3"></a>

### inc_prometheus_counter/3 * ###

`inc_prometheus_counter(Name, Labels, Value) -> any()`

<a name="inc_prometheus_gauge-1"></a>

### inc_prometheus_gauge/1 * ###

`inc_prometheus_gauge(Name) -> any()`

Safe wrapper for prometheus_gauge:inc/2.

<a name="init-1"></a>

### init/1 ###

`init(Opts) -> any()`

<a name="init_prometheus-1"></a>

### init_prometheus/1 * ###

`init_prometheus(Opts) -> any()`

<a name="log-5"></a>

### log/5 * ###

`log(Type, Event, X3, Reason, Opts) -> any()`

<a name="maybe_invoke_monitor-2"></a>

### maybe_invoke_monitor/2 * ###

`maybe_invoke_monitor(Details, Opts) -> any()`

Invoke the HTTP monitor message with AO-Core, if it is set in the
node message key. We invoke the given message with the `body` set to a signed
version of the details. This allows node operators to configure their machine
to record duration statistics into customized data stores, computations, or
processes etc. Additionally, we include the `http_reference` value, if set in
the given `opts`.

We use `hb_ao:get` rather than `hb_opts:get`, as settings configured
by the `~router@1.0` route `opts` key are unable to generate atoms.

<a name="method_to_bin-1"></a>

### method_to_bin/1 * ###

`method_to_bin(X1) -> any()`

<a name="open_connection-2"></a>

### open_connection/2 * ###

`open_connection(X1, Opts) -> any()`

<a name="parse_peer-2"></a>

### parse_peer/2 * ###

`parse_peer(Peer, Opts) -> any()`

<a name="record_duration-2"></a>

### record_duration/2 * ###

`record_duration(Details, Opts) -> any()`

Record the duration of the request in an async process. We write the
data to prometheus if the application is enabled, as well as invoking the
`http_monitor` if appropriate.

<a name="record_response_status-3"></a>

### record_response_status/3 * ###

`record_response_status(Method, Path, Response) -> any()`

<a name="reply_error-2"></a>

### reply_error/2 * ###

`reply_error(PendingRequests, Reason) -> any()`

<a name="req-2"></a>

### req/2 ###

`req(Args, Opts) -> any()`

<a name="req-3"></a>

### req/3 * ###

`req(Args, ReestablishedConnection, Opts) -> any()`

<a name="request-3"></a>

### request/3 * ###

`request(PID, Args, Opts) -> any()`

<a name="start_link-1"></a>

### start_link/1 ###

`start_link(Opts) -> any()`

<a name="terminate-2"></a>

### terminate/2 ###

`terminate(Reason, State) -> any()`

<a name="upload_metric-1"></a>

### upload_metric/1 * ###

`upload_metric(X1) -> any()`


--- END OF FILE: docs/resources/source-code/hb_http_client.md ---

--- START OF FILE: docs/resources/source-code/hb_http_server.md ---
# [Module hb_http_server.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_http_server.erl)




A router that attaches a HTTP server to the AO-Core resolver.

<a name="description"></a>

## Description ##

Because AO-Core is built to speak in HTTP semantics, this module
only has to marshal the HTTP request into a message, and then
pass it to the AO-Core resolver.

`hb_http:reply/4` is used to respond to the client, handling the
process of converting a message back into an HTTP response.

The router uses an `Opts` message as its Cowboy initial state,
such that changing it on start of the router server allows for
the execution parameters of all downstream requests to be controlled.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#allowed_methods-2">allowed_methods/2</a></td><td>Return the list of allowed methods for the HTTP server.</td></tr><tr><td valign="top"><a href="#cors_reply-2">cors_reply/2*</a></td><td>Reply to CORS preflight requests.</td></tr><tr><td valign="top"><a href="#get_opts-1">get_opts/1</a></td><td></td></tr><tr><td valign="top"><a href="#handle_request-3">handle_request/3*</a></td><td>Handle all non-CORS preflight requests as AO-Core requests.</td></tr><tr><td valign="top"><a href="#http3_conn_sup_loop-0">http3_conn_sup_loop/0*</a></td><td></td></tr><tr><td valign="top"><a href="#init-2">init/2</a></td><td>Entrypoint for all HTTP requests.</td></tr><tr><td valign="top"><a href="#new_server-1">new_server/1*</a></td><td></td></tr><tr><td valign="top"><a href="#read_body-1">read_body/1*</a></td><td>Helper to grab the full body of a HTTP request, even if it's chunked.</td></tr><tr><td valign="top"><a href="#read_body-2">read_body/2*</a></td><td></td></tr><tr><td valign="top"><a href="#set_default_opts-1">set_default_opts/1</a></td><td></td></tr><tr><td valign="top"><a href="#set_opts-1">set_opts/1</a></td><td>Update the <code>Opts</code> map that the HTTP server uses for all future
requests.</td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the HTTP server.</td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_http2-3">start_http2/3*</a></td><td></td></tr><tr><td valign="top"><a href="#start_http3-3">start_http3/3*</a></td><td></td></tr><tr><td valign="top"><a href="#start_node-0">start_node/0</a></td><td>Test that we can start the server, send a message, and get a response.</td></tr><tr><td valign="top"><a href="#start_node-1">start_node/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="allowed_methods-2"></a>

### allowed_methods/2 ###

`allowed_methods(Req, State) -> any()`

Return the list of allowed methods for the HTTP server.

<a name="cors_reply-2"></a>

### cors_reply/2 * ###

`cors_reply(Req, ServerID) -> any()`

Reply to CORS preflight requests.

<a name="get_opts-1"></a>

### get_opts/1 ###

`get_opts(NodeMsg) -> any()`

<a name="handle_request-3"></a>

### handle_request/3 * ###

`handle_request(RawReq, Body, ServerID) -> any()`

Handle all non-CORS preflight requests as AO-Core requests. Execution
starts by parsing the HTTP request into HyerBEAM's message format, then
passing the message directly to `meta@1.0` which handles calling AO-Core in
the appropriate way.

<a name="http3_conn_sup_loop-0"></a>

### http3_conn_sup_loop/0 * ###

`http3_conn_sup_loop() -> any()`

<a name="init-2"></a>

### init/2 ###

`init(Req, ServerID) -> any()`

Entrypoint for all HTTP requests. Receives the Cowboy request option and
the server ID, which can be used to lookup the node message.

<a name="new_server-1"></a>

### new_server/1 * ###

`new_server(RawNodeMsg) -> any()`

<a name="read_body-1"></a>

### read_body/1 * ###

`read_body(Req) -> any()`

Helper to grab the full body of a HTTP request, even if it's chunked.

<a name="read_body-2"></a>

### read_body/2 * ###

`read_body(Req0, Acc) -> any()`

<a name="set_default_opts-1"></a>

### set_default_opts/1 ###

`set_default_opts(Opts) -> any()`

<a name="set_opts-1"></a>

### set_opts/1 ###

`set_opts(Opts) -> any()`

Update the `Opts` map that the HTTP server uses for all future
requests.

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

Starts the HTTP server. Optionally accepts an `Opts` message, which
is used as the source for server configuration settings, as well as the
`Opts` argument to use for all AO-Core resolution requests downstream.

<a name="start-1"></a>

### start/1 ###

`start(Opts) -> any()`

<a name="start_http2-3"></a>

### start_http2/3 * ###

`start_http2(ServerID, ProtoOpts, NodeMsg) -> any()`

<a name="start_http3-3"></a>

### start_http3/3 * ###

`start_http3(ServerID, ProtoOpts, NodeMsg) -> any()`

<a name="start_node-0"></a>

### start_node/0 ###

`start_node() -> any()`

Test that we can start the server, send a message, and get a response.

<a name="start_node-1"></a>

### start_node/1 ###

`start_node(Opts) -> any()`


--- END OF FILE: docs/resources/source-code/hb_http_server.md ---

--- START OF FILE: docs/resources/source-code/hb_http.md ---
# [Module hb_http.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_http.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#accept_to_codec-2">accept_to_codec/2</a></td><td>Calculate the codec name to use for a reply given its initiating Cowboy
request, the parsed TABM request, and the response message.</td></tr><tr><td valign="top"><a href="#add_cors_headers-2">add_cors_headers/2*</a></td><td>Add permissive CORS headers to a message, if the message has not already
specified CORS headers.</td></tr><tr><td valign="top"><a href="#allowed_status-2">allowed_status/2*</a></td><td>Check if a status is allowed, according to the configuration.</td></tr><tr><td valign="top"><a href="#ans104_wasm_test-0">ans104_wasm_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#codec_to_content_type-2">codec_to_content_type/2*</a></td><td>Call the <code>content-type</code> key on a message with the given codec, using
a fast-path for options that are not needed for this one-time lookup.</td></tr><tr><td valign="top"><a href="#cors_get_test-0">cors_get_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#default_codec-1">default_codec/1*</a></td><td>Return the default codec for the given options.</td></tr><tr><td valign="top"><a href="#empty_inbox-1">empty_inbox/1*</a></td><td>Empty the inbox of the current process for all messages with the given
reference.</td></tr><tr><td valign="top"><a href="#encode_reply-3">encode_reply/3*</a></td><td>Generate the headers and body for a HTTP response message.</td></tr><tr><td valign="top"><a href="#get-2">get/2</a></td><td>Gets a URL via HTTP and returns the resulting message in deserialized
form.</td></tr><tr><td valign="top"><a href="#get-3">get/3</a></td><td></td></tr><tr><td valign="top"><a href="#get_deep_signed_wasm_state_test-0">get_deep_signed_wasm_state_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#get_deep_unsigned_wasm_state_test-0">get_deep_unsigned_wasm_state_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#http_response_to_httpsig-4">http_response_to_httpsig/4*</a></td><td>Convert a HTTP response to a httpsig message.</td></tr><tr><td valign="top"><a href="#httpsig_to_tabm_singleton-3">httpsig_to_tabm_singleton/3*</a></td><td>HTTPSig messages are inherently mixed into the transport layer, so they
require special handling in order to be converted to a normalized message.</td></tr><tr><td valign="top"><a href="#maybe_add_unsigned-3">maybe_add_unsigned/3*</a></td><td>Add the method and path to a message, if they are not already present.</td></tr><tr><td valign="top"><a href="#message_to_request-2">message_to_request/2*</a></td><td>Given a message, return the information needed to make the request.</td></tr><tr><td valign="top"><a href="#mime_to_codec-2">mime_to_codec/2*</a></td><td>Find a codec name from a mime-type.</td></tr><tr><td valign="top"><a href="#multirequest-5">multirequest/5*</a></td><td>Dispatch the same HTTP request to many nodes.</td></tr><tr><td valign="top"><a href="#multirequest_opt-5">multirequest_opt/5*</a></td><td>Get a value for a multirequest option from the config or message.</td></tr><tr><td valign="top"><a href="#multirequest_opts-3">multirequest_opts/3*</a></td><td>Get the multirequest options from the config or message.</td></tr><tr><td valign="top"><a href="#nested_ao_resolve_test-0">nested_ao_resolve_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#parallel_multirequest-8">parallel_multirequest/8*</a></td><td>Dispatch the same HTTP request to many nodes in parallel.</td></tr><tr><td valign="top"><a href="#parallel_responses-7">parallel_responses/7*</a></td><td>Collect the necessary number of responses, and stop workers if
configured to do so.</td></tr><tr><td valign="top"><a href="#post-3">post/3</a></td><td>Posts a message to a URL on a remote peer via HTTP.</td></tr><tr><td valign="top"><a href="#post-4">post/4</a></td><td></td></tr><tr><td valign="top"><a href="#prepare_request-6">prepare_request/6*</a></td><td>Turn a set of request arguments into a request message, formatted in the
preferred format.</td></tr><tr><td valign="top"><a href="#remove_unsigned_fields-2">remove_unsigned_fields/2*</a></td><td></td></tr><tr><td valign="top"><a href="#reply-4">reply/4</a></td><td>Reply to the client's HTTP request with a message.</td></tr><tr><td valign="top"><a href="#reply-5">reply/5*</a></td><td></td></tr><tr><td valign="top"><a href="#req_to_tabm_singleton-3">req_to_tabm_singleton/3</a></td><td>Convert a cowboy request to a normalized message.</td></tr><tr><td valign="top"><a href="#request-2">request/2</a></td><td>Posts a binary to a URL on a remote peer via HTTP, returning the raw
binary body.</td></tr><tr><td valign="top"><a href="#request-4">request/4</a></td><td></td></tr><tr><td valign="top"><a href="#request-5">request/5</a></td><td></td></tr><tr><td valign="top"><a href="#route_to_request-3">route_to_request/3*</a></td><td>Parse a <code>dev_router:route</code> response and return a tuple of request
parameters.</td></tr><tr><td valign="top"><a href="#run_wasm_signed_test-0">run_wasm_signed_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#run_wasm_unsigned_test-0">run_wasm_unsigned_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#send_encoded_node_message_test-2">send_encoded_node_message_test/2*</a></td><td></td></tr><tr><td valign="top"><a href="#send_flat_encoded_node_message_test-0">send_flat_encoded_node_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#send_json_encoded_node_message_test-0">send_json_encoded_node_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#send_large_signed_request_test-0">send_large_signed_request_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#serial_multirequest-7">serial_multirequest/7*</a></td><td>Serially request a message, collecting responses until the required
number of responses have been gathered.</td></tr><tr><td valign="top"><a href="#simple_ao_resolve_signed_test-0">simple_ao_resolve_signed_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_ao_resolve_unsigned_test-0">simple_ao_resolve_unsigned_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td></td></tr><tr><td valign="top"><a href="#wasm_compute_request-3">wasm_compute_request/3*</a></td><td></td></tr><tr><td valign="top"><a href="#wasm_compute_request-4">wasm_compute_request/4*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="accept_to_codec-2"></a>

### accept_to_codec/2 ###

`accept_to_codec(TABMReq, Opts) -> any()`

Calculate the codec name to use for a reply given its initiating Cowboy
request, the parsed TABM request, and the response message. The precidence
order for finding the codec is:
1. The `accept-codec` field in the message
2. The `accept` field in the request headers
3. The default codec
Options can be specified in mime-type format (`application/*`) or in
AO device format (`device@1.0`).

<a name="add_cors_headers-2"></a>

### add_cors_headers/2 * ###

`add_cors_headers(Msg, ReqHdr) -> any()`

Add permissive CORS headers to a message, if the message has not already
specified CORS headers.

<a name="allowed_status-2"></a>

### allowed_status/2 * ###

`allowed_status(ResponseMsg, Statuses) -> any()`

Check if a status is allowed, according to the configuration.

<a name="ans104_wasm_test-0"></a>

### ans104_wasm_test/0 * ###

`ans104_wasm_test() -> any()`

<a name="codec_to_content_type-2"></a>

### codec_to_content_type/2 * ###

`codec_to_content_type(Codec, Opts) -> any()`

Call the `content-type` key on a message with the given codec, using
a fast-path for options that are not needed for this one-time lookup.

<a name="cors_get_test-0"></a>

### cors_get_test/0 * ###

`cors_get_test() -> any()`

<a name="default_codec-1"></a>

### default_codec/1 * ###

`default_codec(Opts) -> any()`

Return the default codec for the given options.

<a name="empty_inbox-1"></a>

### empty_inbox/1 * ###

`empty_inbox(Ref) -> any()`

Empty the inbox of the current process for all messages with the given
reference.

<a name="encode_reply-3"></a>

### encode_reply/3 * ###

`encode_reply(TABMReq, Message, Opts) -> any()`

Generate the headers and body for a HTTP response message.

<a name="get-2"></a>

### get/2 ###

`get(Node, Opts) -> any()`

Gets a URL via HTTP and returns the resulting message in deserialized
form.

<a name="get-3"></a>

### get/3 ###

`get(Node, PathBin, Opts) -> any()`

<a name="get_deep_signed_wasm_state_test-0"></a>

### get_deep_signed_wasm_state_test/0 * ###

`get_deep_signed_wasm_state_test() -> any()`

<a name="get_deep_unsigned_wasm_state_test-0"></a>

### get_deep_unsigned_wasm_state_test/0 * ###

`get_deep_unsigned_wasm_state_test() -> any()`

<a name="http_response_to_httpsig-4"></a>

### http_response_to_httpsig/4 * ###

`http_response_to_httpsig(Status, HeaderMap, Body, Opts) -> any()`

Convert a HTTP response to a httpsig message.

<a name="httpsig_to_tabm_singleton-3"></a>

### httpsig_to_tabm_singleton/3 * ###

`httpsig_to_tabm_singleton(Req, Body, Opts) -> any()`

HTTPSig messages are inherently mixed into the transport layer, so they
require special handling in order to be converted to a normalized message.
In particular, the signatures are verified if present and required by the
node configuration. Additionally, non-committed fields are removed from the
message if it is signed, with the exception of the `path` and `method` fields.

<a name="maybe_add_unsigned-3"></a>

### maybe_add_unsigned/3 * ###

`maybe_add_unsigned(Req, Msg, Opts) -> any()`

Add the method and path to a message, if they are not already present.
The precidence order for finding the path is:
1. The path in the message
2. The path in the request URI

<a name="message_to_request-2"></a>

### message_to_request/2 * ###

`message_to_request(M, Opts) -> any()`

Given a message, return the information needed to make the request.

<a name="mime_to_codec-2"></a>

### mime_to_codec/2 * ###

`mime_to_codec(X1, Opts) -> any()`

Find a codec name from a mime-type.

<a name="multirequest-5"></a>

### multirequest/5 * ###

`multirequest(Config, Method, Path, Message, Opts) -> any()`

Dispatch the same HTTP request to many nodes. Can be configured to
await responses from all nodes or just one, and to halt all requests after
after it has received the required number of responses, or to leave all
requests running until they have all completed. Default: Race for first
response.

Expects a config message of the following form:
/Nodes/1..n: Hostname | #{ hostname => Hostname, address => Address }
/Responses: Number of responses to gather
/Stop-After: Should we stop after the required number of responses?
/Parallel: Should we run the requests in parallel?

<a name="multirequest_opt-5"></a>

### multirequest_opt/5 * ###

`multirequest_opt(Key, Config, Message, Default, Opts) -> any()`

Get a value for a multirequest option from the config or message.

<a name="multirequest_opts-3"></a>

### multirequest_opts/3 * ###

`multirequest_opts(Config, Message, Opts) -> any()`

Get the multirequest options from the config or message. The options in
the message take precidence over the options in the config.

<a name="nested_ao_resolve_test-0"></a>

### nested_ao_resolve_test/0 * ###

`nested_ao_resolve_test() -> any()`

<a name="parallel_multirequest-8"></a>

### parallel_multirequest/8 * ###

`parallel_multirequest(Nodes, Responses, StopAfter, Method, Path, Message, Statuses, Opts) -> any()`

Dispatch the same HTTP request to many nodes in parallel.

<a name="parallel_responses-7"></a>

### parallel_responses/7 * ###

`parallel_responses(Res, Procs, Ref, Awaiting, StopAfter, Statuses, Opts) -> any()`

Collect the necessary number of responses, and stop workers if
configured to do so.

<a name="post-3"></a>

### post/3 ###

`post(Node, Message, Opts) -> any()`

Posts a message to a URL on a remote peer via HTTP. Returns the
resulting message in deserialized form.

<a name="post-4"></a>

### post/4 ###

`post(Node, Path, Message, Opts) -> any()`

<a name="prepare_request-6"></a>

### prepare_request/6 * ###

`prepare_request(Format, Method, Peer, Path, RawMessage, Opts) -> any()`

Turn a set of request arguments into a request message, formatted in the
preferred format.

<a name="remove_unsigned_fields-2"></a>

### remove_unsigned_fields/2 * ###

`remove_unsigned_fields(Msg, Opts) -> any()`

<a name="reply-4"></a>

### reply/4 ###

`reply(Req, TABMReq, Message, Opts) -> any()`

Reply to the client's HTTP request with a message.

<a name="reply-5"></a>

### reply/5 * ###

`reply(Req, TABMReq, BinStatus, RawMessage, Opts) -> any()`

<a name="req_to_tabm_singleton-3"></a>

### req_to_tabm_singleton/3 ###

`req_to_tabm_singleton(Req, Body, Opts) -> any()`

Convert a cowboy request to a normalized message.

<a name="request-2"></a>

### request/2 ###

`request(Message, Opts) -> any()`

Posts a binary to a URL on a remote peer via HTTP, returning the raw
binary body.

<a name="request-4"></a>

### request/4 ###

`request(Method, Peer, Path, Opts) -> any()`

<a name="request-5"></a>

### request/5 ###

`request(Method, Config, Path, Message, Opts) -> any()`

<a name="route_to_request-3"></a>

### route_to_request/3 * ###

`route_to_request(M, X2, Opts) -> any()`

Parse a `dev_router:route` response and return a tuple of request
parameters.

<a name="run_wasm_signed_test-0"></a>

### run_wasm_signed_test/0 * ###

`run_wasm_signed_test() -> any()`

<a name="run_wasm_unsigned_test-0"></a>

### run_wasm_unsigned_test/0 * ###

`run_wasm_unsigned_test() -> any()`

<a name="send_encoded_node_message_test-2"></a>

### send_encoded_node_message_test/2 * ###

`send_encoded_node_message_test(Config, Codec) -> any()`

<a name="send_flat_encoded_node_message_test-0"></a>

### send_flat_encoded_node_message_test/0 * ###

`send_flat_encoded_node_message_test() -> any()`

<a name="send_json_encoded_node_message_test-0"></a>

### send_json_encoded_node_message_test/0 * ###

`send_json_encoded_node_message_test() -> any()`

<a name="send_large_signed_request_test-0"></a>

### send_large_signed_request_test/0 * ###

`send_large_signed_request_test() -> any()`

<a name="serial_multirequest-7"></a>

### serial_multirequest/7 * ###

`serial_multirequest(Nodes, Remaining, Method, Path, Message, Statuses, Opts) -> any()`

Serially request a message, collecting responses until the required
number of responses have been gathered. Ensure that the statuses are
allowed, according to the configuration.

<a name="simple_ao_resolve_signed_test-0"></a>

### simple_ao_resolve_signed_test/0 * ###

`simple_ao_resolve_signed_test() -> any()`

<a name="simple_ao_resolve_unsigned_test-0"></a>

### simple_ao_resolve_unsigned_test/0 * ###

`simple_ao_resolve_unsigned_test() -> any()`

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

<a name="wasm_compute_request-3"></a>

### wasm_compute_request/3 * ###

`wasm_compute_request(ImageFile, Func, Params) -> any()`

<a name="wasm_compute_request-4"></a>

### wasm_compute_request/4 * ###

`wasm_compute_request(ImageFile, Func, Params, ResultPath) -> any()`


--- END OF FILE: docs/resources/source-code/hb_http.md ---

--- START OF FILE: docs/resources/source-code/hb_json.md ---
# [Module hb_json.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_json.erl)




Wrapper for encoding and decoding JSON.

<a name="description"></a>

## Description ##
Supports maps and Jiffy's old
`ejson` format. This module abstracts the underlying JSON library, allowing
us to switch between libraries as needed in the future.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Takes a JSON string and decodes it into an Erlang term.</td></tr><tr><td valign="top"><a href="#decode-2">decode/2</a></td><td></td></tr><tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Takes a term in Erlang's native form and encodes it as a JSON string.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="decode-1"></a>

### decode/1 ###

`decode(Bin) -> any()`

Takes a JSON string and decodes it into an Erlang term.

<a name="decode-2"></a>

### decode/2 ###

`decode(Bin, Opts) -> any()`

<a name="encode-1"></a>

### encode/1 ###

`encode(Term) -> any()`

Takes a term in Erlang's native form and encodes it as a JSON string.


--- END OF FILE: docs/resources/source-code/hb_json.md ---

--- START OF FILE: docs/resources/source-code/hb_logger.md ---
# [Module hb_logger.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_logger.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#console-2">console/2*</a></td><td></td></tr><tr><td valign="top"><a href="#log-2">log/2</a></td><td></td></tr><tr><td valign="top"><a href="#loop-1">loop/1*</a></td><td></td></tr><tr><td valign="top"><a href="#register-1">register/1</a></td><td></td></tr><tr><td valign="top"><a href="#report-1">report/1</a></td><td></td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td></td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="console-2"></a>

### console/2 * ###

`console(State, Act) -> any()`

<a name="log-2"></a>

### log/2 ###

`log(Monitor, Data) -> any()`

<a name="loop-1"></a>

### loop/1 * ###

`loop(State) -> any()`

<a name="register-1"></a>

### register/1 ###

`register(Monitor) -> any()`

<a name="report-1"></a>

### report/1 ###

`report(Monitor) -> any()`

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

<a name="start-1"></a>

### start/1 ###

`start(Client) -> any()`


--- END OF FILE: docs/resources/source-code/hb_logger.md ---

--- START OF FILE: docs/resources/source-code/hb_message.md ---
# [Module hb_message.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_message.erl)




This module acts an adapter between messages, as modeled in the
AO-Core protocol, and their uderlying binary representations and formats.

<a name="description"></a>

## Description ##

Unless you are implementing a new message serialization codec, you should
not need to interact with this module directly. Instead, use the
`hb_ao` interfaces to interact with all messages. The `dev_message`
module implements a device interface for abstracting over the different
message formats.

`hb_message` and the HyperBEAM caches can interact with multiple different
types of message formats:

- Richly typed AO-Core structured messages.
- Arweave transations.
- ANS-104 data items.
- HTTP Signed Messages.
- Flat Maps.

This module is responsible for converting between these formats. It does so
by normalizing messages to a common format: `Type Annotated Binary Messages`
(TABM). TABMs are deep Erlang maps with keys than only contain either other
TABMs or binary values. By marshalling all messages into this format, they
can easily be coerced into other output formats. For example, generating a
`HTTP Signed Message` format output from an Arweave transaction. TABM is
also a simple format from a computational perspective (only binary literals
and O(1) access maps), such that operations upon them are efficient.

The structure of the conversions is as follows:

<pre>
Arweave TX/ANS-104 ==> dev_codec_ans104:from/1 ==> TABM
HTTP Signed Message ==> dev_codec_httpsig_conv:from/1 ==> TABM
Flat Maps ==> dev_codec_flat:from/1 ==> TABM

TABM ==> dev_codec_structured:to/1 ==> AO-Core Message
AO-Core Message ==> dev_codec_structured:from/1 ==> TABM

TABM ==> dev_codec_ans104:to/1 ==> Arweave TX/ANS-104
TABM ==> dev_codec_httpsig_conv:to/1 ==> HTTP Signed Message
TABM ==> dev_codec_flat:to/1 ==> Flat Maps
...
</pre>

Additionally, this module provides a number of utility functions for
manipulating messages. For example, `hb_message:sign/2` to sign a message of
arbitrary type, or `hb_message:format/1` to print an AO-Core/TABM message in
a human-readable format.

The `hb_cache` module is responsible for storing and retrieving messages in
the HyperBEAM stores configured on the node. Each store has its own storage
backend, but each works with simple key-value pairs. Subsequently, the
`hb_cache` module uses TABMs as the internal format for storing and
retrieving messages.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#basic_map_codec_test-1">basic_map_codec_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#binary_to_binary_test-1">binary_to_binary_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#commit-2">commit/2</a></td><td>Sign a message with the given wallet.</td></tr><tr><td valign="top"><a href="#commit-3">commit/3</a></td><td></td></tr><tr><td valign="top"><a href="#commitment-2">commitment/2</a></td><td>Extract a commitment from a message given a <code>committer</code> ID, or a spec
message to match against.</td></tr><tr><td valign="top"><a href="#commitment-3">commitment/3</a></td><td></td></tr><tr><td valign="top"><a href="#committed-1">committed/1</a></td><td>Return the list of committed keys from a message.</td></tr><tr><td valign="top"><a href="#committed-2">committed/2</a></td><td></td></tr><tr><td valign="top"><a href="#committed-3">committed/3</a></td><td></td></tr><tr><td valign="top"><a href="#committed_empty_keys_test-1">committed_empty_keys_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#committed_keys_test-1">committed_keys_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#complex_signed_message_test-1">complex_signed_message_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#convert-3">convert/3</a></td><td>Convert a message from one format to another.</td></tr><tr><td valign="top"><a href="#convert-4">convert/4</a></td><td></td></tr><tr><td valign="top"><a href="#deep_multisignature_test-0">deep_multisignature_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#deeply_nested_committed_keys_test-0">deeply_nested_committed_keys_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#deeply_nested_message_with_content_test-1">deeply_nested_message_with_content_test/1*</a></td><td>Test that we can convert a 3 layer nested message into a tx record and back.</td></tr><tr><td valign="top"><a href="#deeply_nested_message_with_only_content-1">deeply_nested_message_with_only_content/1*</a></td><td></td></tr><tr><td valign="top"><a href="#default_keys_removed_test-0">default_keys_removed_test/0*</a></td><td>Test that the filter_default_keys/1 function removes TX fields
that have the default values found in the tx record, but not those that
have been set by the user.</td></tr><tr><td valign="top"><a href="#default_tx_list-0">default_tx_list/0</a></td><td>Get the ordered list of fields as AO-Core keys and default values of
the tx record.</td></tr><tr><td valign="top"><a href="#default_tx_message-0">default_tx_message/0*</a></td><td>Get the normalized fields and default values of the tx record.</td></tr><tr><td valign="top"><a href="#empty_string_in_tag_test-1">empty_string_in_tag_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_balance_table-2">encode_balance_table/2*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_large_balance_table_test-1">encode_large_balance_table_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#encode_small_balance_table_test-1">encode_small_balance_table_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#filter_default_keys-1">filter_default_keys/1</a></td><td>Remove keys from a map that have the default values found in the tx
record.</td></tr><tr><td valign="top"><a href="#find_target-3">find_target/3</a></td><td>Implements a standard pattern in which the target for an operation is
found by looking for a <code>target</code> key in the request.</td></tr><tr><td valign="top"><a href="#format-1">format/1</a></td><td>Format a message for printing, optionally taking an indentation level
to start from.</td></tr><tr><td valign="top"><a href="#format-2">format/2</a></td><td></td></tr><tr><td valign="top"><a href="#from_tabm-4">from_tabm/4*</a></td><td></td></tr><tr><td valign="top"><a href="#generate_test_suite-1">generate_test_suite/1*</a></td><td></td></tr><tr><td valign="top"><a href="#get_codec-2">get_codec/2*</a></td><td>Get a codec from the options.</td></tr><tr><td valign="top"><a href="#hashpath_sign_verify_test-1">hashpath_sign_verify_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#id-1">id/1</a></td><td>Return the ID of a message.</td></tr><tr><td valign="top"><a href="#id-2">id/2</a></td><td></td></tr><tr><td valign="top"><a href="#id-3">id/3</a></td><td></td></tr><tr><td valign="top"><a href="#large_body_committed_keys_test-1">large_body_committed_keys_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#match-2">match/2</a></td><td>Check if two maps match, including recursively checking nested maps.</td></tr><tr><td valign="top"><a href="#match-3">match/3</a></td><td></td></tr><tr><td valign="top"><a href="#match_modes_test-0">match_modes_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#match_test-1">match_test/1*</a></td><td>Test that the message matching function works.</td></tr><tr><td valign="top"><a href="#matchable_keys-1">matchable_keys/1*</a></td><td></td></tr><tr><td valign="top"><a href="#message_suite_test_-0">message_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#message_with_large_keys_test-1">message_with_large_keys_test/1*</a></td><td>Test that the data field is correctly managed when we have multiple
uses for it (the 'data' key itself, as well as keys that cannot fit in
tags).</td></tr><tr><td valign="top"><a href="#message_with_simple_embedded_list_test-1">message_with_simple_embedded_list_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#minimization_test-0">minimization_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#minimize-1">minimize/1</a></td><td>Remove keys from the map that can be regenerated.</td></tr><tr><td valign="top"><a href="#minimize-2">minimize/2*</a></td><td></td></tr><tr><td valign="top"><a href="#nested_body_list_test-1">nested_body_list_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#nested_empty_map_test-1">nested_empty_map_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#nested_message_with_large_content_test-1">nested_message_with_large_content_test/1*</a></td><td>Test that the data field is correctly managed when we have multiple
uses for it (the 'data' key itself, as well as keys that cannot fit in
tags).</td></tr><tr><td valign="top"><a href="#nested_message_with_large_keys_and_content_test-1">nested_message_with_large_keys_and_content_test/1*</a></td><td>Check that large keys and data fields are correctly handled together.</td></tr><tr><td valign="top"><a href="#nested_message_with_large_keys_test-1">nested_message_with_large_keys_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#nested_structured_fields_test-1">nested_structured_fields_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize-1">normalize/1*</a></td><td>Return a map with only the keys that necessary, without those that can
be regenerated.</td></tr><tr><td valign="top"><a href="#print-1">print/1</a></td><td>Pretty-print a message.</td></tr><tr><td valign="top"><a href="#print-2">print/2*</a></td><td></td></tr><tr><td valign="top"><a href="#priv_survives_conversion_test-1">priv_survives_conversion_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#recursive_nested_list_test-1">recursive_nested_list_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#restore_priv-2">restore_priv/2*</a></td><td>Add the existing <code>priv</code> sub-map back to a converted message, honoring
any existing <code>priv</code> sub-map that may already be present.</td></tr><tr><td valign="top"><a href="#run_test-0">run_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#set_body_codec_test-1">set_body_codec_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#sign_node_message_test-1">sign_node_message_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_deep_message_test-1">signed_deep_message_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_list_test-1">signed_list_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_message_encode_decode_verify_test-1">signed_message_encode_decode_verify_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_message_with_derived_components_test-1">signed_message_with_derived_components_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_nested_data_key_test-1">signed_nested_data_key_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_only_committed_data_field_test-1">signed_only_committed_data_field_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signed_with_inner_signed_message_test-1">signed_with_inner_signed_message_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#signers-1">signers/1</a></td><td>Return all of the committers on a message that have 'normal', 256 bit,
addresses.</td></tr><tr><td valign="top"><a href="#simple_nested_message_test-1">simple_nested_message_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#single_layer_message_to_encoding_test-1">single_layer_message_to_encoding_test/1*</a></td><td>Test that we can convert a message into a tx record and back.</td></tr><tr><td valign="top"><a href="#structured_field_atom_parsing_test-1">structured_field_atom_parsing_test/1*</a></td><td>Structured field parsing tests.</td></tr><tr><td valign="top"><a href="#structured_field_decimal_parsing_test-1">structured_field_decimal_parsing_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#tabm_ao_ids_equal_test-1">tabm_ao_ids_equal_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#test_codecs-0">test_codecs/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_tabm-3">to_tabm/3*</a></td><td></td></tr><tr><td valign="top"><a href="#type-1">type/1</a></td><td>Return the type of an encoded message.</td></tr><tr><td valign="top"><a href="#uncommitted-1">uncommitted/1</a></td><td>Return the unsigned version of a message in AO-Core format.</td></tr><tr><td valign="top"><a href="#unsigned_id_test-1">unsigned_id_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#verify-1">verify/1</a></td><td>wrapper function to verify a message.</td></tr><tr><td valign="top"><a href="#verify-2">verify/2</a></td><td></td></tr><tr><td valign="top"><a href="#with_commitments-2">with_commitments/2</a></td><td>Filter messages that do not match the 'spec' given.</td></tr><tr><td valign="top"><a href="#with_commitments-3">with_commitments/3*</a></td><td></td></tr><tr><td valign="top"><a href="#with_only_committed-1">with_only_committed/1</a></td><td>Return a message with only the committed keys.</td></tr><tr><td valign="top"><a href="#with_only_committed-2">with_only_committed/2</a></td><td></td></tr><tr><td valign="top"><a href="#with_only_committers-2">with_only_committers/2</a></td><td>Return the message with only the specified committers attached.</td></tr><tr><td valign="top"><a href="#without_commitments-2">without_commitments/2</a></td><td>Filter messages that match the 'spec' given.</td></tr><tr><td valign="top"><a href="#without_commitments-3">without_commitments/3*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="basic_map_codec_test-1"></a>

### basic_map_codec_test/1 * ###

`basic_map_codec_test(Codec) -> any()`

<a name="binary_to_binary_test-1"></a>

### binary_to_binary_test/1 * ###

`binary_to_binary_test(Codec) -> any()`

<a name="commit-2"></a>

### commit/2 ###

`commit(Msg, WalletOrOpts) -> any()`

Sign a message with the given wallet.

<a name="commit-3"></a>

### commit/3 ###

`commit(Msg, Wallet, Format) -> any()`

<a name="commitment-2"></a>

### commitment/2 ###

`commitment(Committer, Msg) -> any()`

Extract a commitment from a message given a `committer` ID, or a spec
message to match against. Returns only the first matching commitment, or
`not_found`.

<a name="commitment-3"></a>

### commitment/3 ###

`commitment(CommitterID, Msg, Opts) -> any()`

<a name="committed-1"></a>

### committed/1 ###

`committed(Msg) -> any()`

Return the list of committed keys from a message.

<a name="committed-2"></a>

### committed/2 ###

`committed(Msg, Committers) -> any()`

<a name="committed-3"></a>

### committed/3 ###

`committed(Msg, List, Opts) -> any()`

<a name="committed_empty_keys_test-1"></a>

### committed_empty_keys_test/1 * ###

`committed_empty_keys_test(Codec) -> any()`

<a name="committed_keys_test-1"></a>

### committed_keys_test/1 * ###

`committed_keys_test(Codec) -> any()`

<a name="complex_signed_message_test-1"></a>

### complex_signed_message_test/1 * ###

`complex_signed_message_test(Codec) -> any()`

<a name="convert-3"></a>

### convert/3 ###

`convert(Msg, TargetFormat, Opts) -> any()`

Convert a message from one format to another. Taking a message in the
source format, a target format, and a set of opts. If not given, the source
is assumed to be `structured@1.0`. Additional codecs can be added by ensuring they
are part of the `Opts` map -- either globally, or locally for a computation.

The encoding happens in two phases:
1. Convert the message to a TABM.
2. Convert the TABM to the target format.

The conversion to a TABM is done by the `structured@1.0` codec, which is always
available. The conversion from a TABM is done by the target codec.

<a name="convert-4"></a>

### convert/4 ###

`convert(Msg, TargetFormat, SourceFormat, Opts) -> any()`

<a name="deep_multisignature_test-0"></a>

### deep_multisignature_test/0 * ###

`deep_multisignature_test() -> any()`

<a name="deeply_nested_committed_keys_test-0"></a>

### deeply_nested_committed_keys_test/0 * ###

`deeply_nested_committed_keys_test() -> any()`

<a name="deeply_nested_message_with_content_test-1"></a>

### deeply_nested_message_with_content_test/1 * ###

`deeply_nested_message_with_content_test(Codec) -> any()`

Test that we can convert a 3 layer nested message into a tx record and back.

<a name="deeply_nested_message_with_only_content-1"></a>

### deeply_nested_message_with_only_content/1 * ###

`deeply_nested_message_with_only_content(Codec) -> any()`

<a name="default_keys_removed_test-0"></a>

### default_keys_removed_test/0 * ###

`default_keys_removed_test() -> any()`

Test that the filter_default_keys/1 function removes TX fields
that have the default values found in the tx record, but not those that
have been set by the user.

<a name="default_tx_list-0"></a>

### default_tx_list/0 ###

`default_tx_list() -> any()`

Get the ordered list of fields as AO-Core keys and default values of
the tx record.

<a name="default_tx_message-0"></a>

### default_tx_message/0 * ###

`default_tx_message() -> any()`

Get the normalized fields and default values of the tx record.

<a name="empty_string_in_tag_test-1"></a>

### empty_string_in_tag_test/1 * ###

`empty_string_in_tag_test(Codec) -> any()`

<a name="encode_balance_table-2"></a>

### encode_balance_table/2 * ###

`encode_balance_table(Size, Codec) -> any()`

<a name="encode_large_balance_table_test-1"></a>

### encode_large_balance_table_test/1 * ###

`encode_large_balance_table_test(Codec) -> any()`

<a name="encode_small_balance_table_test-1"></a>

### encode_small_balance_table_test/1 * ###

`encode_small_balance_table_test(Codec) -> any()`

<a name="filter_default_keys-1"></a>

### filter_default_keys/1 ###

`filter_default_keys(Map) -> any()`

Remove keys from a map that have the default values found in the tx
record.

<a name="find_target-3"></a>

### find_target/3 ###

`find_target(Self, Req, Opts) -> any()`

Implements a standard pattern in which the target for an operation is
found by looking for a `target` key in the request. If the target is `self`,
or not present, the operation is performed on the original message. Otherwise,
the target is expected to be a key in the message, and the operation is
performed on the value of that key.

<a name="format-1"></a>

### format/1 ###

`format(Item) -> any()`

Format a message for printing, optionally taking an indentation level
to start from.

<a name="format-2"></a>

### format/2 ###

`format(Bin, Indent) -> any()`

<a name="from_tabm-4"></a>

### from_tabm/4 * ###

`from_tabm(Msg, TargetFormat, OldPriv, Opts) -> any()`

<a name="generate_test_suite-1"></a>

### generate_test_suite/1 * ###

`generate_test_suite(Suite) -> any()`

<a name="get_codec-2"></a>

### get_codec/2 * ###

`get_codec(TargetFormat, Opts) -> any()`

Get a codec from the options.

<a name="hashpath_sign_verify_test-1"></a>

### hashpath_sign_verify_test/1 * ###

`hashpath_sign_verify_test(Codec) -> any()`

<a name="id-1"></a>

### id/1 ###

`id(Msg) -> any()`

Return the ID of a message.

<a name="id-2"></a>

### id/2 ###

`id(Msg, Committers) -> any()`

<a name="id-3"></a>

### id/3 ###

`id(Msg, RawCommitters, Opts) -> any()`

<a name="large_body_committed_keys_test-1"></a>

### large_body_committed_keys_test/1 * ###

`large_body_committed_keys_test(Codec) -> any()`

<a name="match-2"></a>

### match/2 ###

`match(Map1, Map2) -> any()`

Check if two maps match, including recursively checking nested maps.
Takes an optional mode argument to control the matching behavior:
`strict`: All keys in both maps be present and match.
`only_present`: Only present keys in both maps must match.
`primary`: Only the primary map's keys must be present.

<a name="match-3"></a>

### match/3 ###

`match(Map1, Map2, Mode) -> any()`

<a name="match_modes_test-0"></a>

### match_modes_test/0 * ###

`match_modes_test() -> any()`

<a name="match_test-1"></a>

### match_test/1 * ###

`match_test(Codec) -> any()`

Test that the message matching function works.

<a name="matchable_keys-1"></a>

### matchable_keys/1 * ###

`matchable_keys(Map) -> any()`

<a name="message_suite_test_-0"></a>

### message_suite_test_/0 * ###

`message_suite_test_() -> any()`

<a name="message_with_large_keys_test-1"></a>

### message_with_large_keys_test/1 * ###

`message_with_large_keys_test(Codec) -> any()`

Test that the data field is correctly managed when we have multiple
uses for it (the 'data' key itself, as well as keys that cannot fit in
tags).

<a name="message_with_simple_embedded_list_test-1"></a>

### message_with_simple_embedded_list_test/1 * ###

`message_with_simple_embedded_list_test(Codec) -> any()`

<a name="minimization_test-0"></a>

### minimization_test/0 * ###

`minimization_test() -> any()`

<a name="minimize-1"></a>

### minimize/1 ###

`minimize(Msg) -> any()`

Remove keys from the map that can be regenerated. Optionally takes an
additional list of keys to include in the minimization.

<a name="minimize-2"></a>

### minimize/2 * ###

`minimize(RawVal, ExtraKeys) -> any()`

<a name="nested_body_list_test-1"></a>

### nested_body_list_test/1 * ###

`nested_body_list_test(Codec) -> any()`

<a name="nested_empty_map_test-1"></a>

### nested_empty_map_test/1 * ###

`nested_empty_map_test(Codec) -> any()`

<a name="nested_message_with_large_content_test-1"></a>

### nested_message_with_large_content_test/1 * ###

`nested_message_with_large_content_test(Codec) -> any()`

Test that the data field is correctly managed when we have multiple
uses for it (the 'data' key itself, as well as keys that cannot fit in
tags).

<a name="nested_message_with_large_keys_and_content_test-1"></a>

### nested_message_with_large_keys_and_content_test/1 * ###

`nested_message_with_large_keys_and_content_test(Codec) -> any()`

Check that large keys and data fields are correctly handled together.

<a name="nested_message_with_large_keys_test-1"></a>

### nested_message_with_large_keys_test/1 * ###

`nested_message_with_large_keys_test(Codec) -> any()`

<a name="nested_structured_fields_test-1"></a>

### nested_structured_fields_test/1 * ###

`nested_structured_fields_test(Codec) -> any()`

<a name="normalize-1"></a>

### normalize/1 * ###

`normalize(Map) -> any()`

Return a map with only the keys that necessary, without those that can
be regenerated.

<a name="print-1"></a>

### print/1 ###

`print(Msg) -> any()`

Pretty-print a message.

<a name="print-2"></a>

### print/2 * ###

`print(Msg, Indent) -> any()`

<a name="priv_survives_conversion_test-1"></a>

### priv_survives_conversion_test/1 * ###

`priv_survives_conversion_test(Codec) -> any()`

<a name="recursive_nested_list_test-1"></a>

### recursive_nested_list_test/1 * ###

`recursive_nested_list_test(Codec) -> any()`

<a name="restore_priv-2"></a>

### restore_priv/2 * ###

`restore_priv(Msg, EmptyPriv) -> any()`

Add the existing `priv` sub-map back to a converted message, honoring
any existing `priv` sub-map that may already be present.

<a name="run_test-0"></a>

### run_test/0 * ###

`run_test() -> any()`

<a name="set_body_codec_test-1"></a>

### set_body_codec_test/1 * ###

`set_body_codec_test(Codec) -> any()`

<a name="sign_node_message_test-1"></a>

### sign_node_message_test/1 * ###

`sign_node_message_test(Codec) -> any()`

<a name="signed_deep_message_test-1"></a>

### signed_deep_message_test/1 * ###

`signed_deep_message_test(Codec) -> any()`

<a name="signed_list_test-1"></a>

### signed_list_test/1 * ###

`signed_list_test(Codec) -> any()`

<a name="signed_message_encode_decode_verify_test-1"></a>

### signed_message_encode_decode_verify_test/1 * ###

`signed_message_encode_decode_verify_test(Codec) -> any()`

<a name="signed_message_with_derived_components_test-1"></a>

### signed_message_with_derived_components_test/1 * ###

`signed_message_with_derived_components_test(Codec) -> any()`

<a name="signed_nested_data_key_test-1"></a>

### signed_nested_data_key_test/1 * ###

`signed_nested_data_key_test(Codec) -> any()`

<a name="signed_only_committed_data_field_test-1"></a>

### signed_only_committed_data_field_test/1 * ###

`signed_only_committed_data_field_test(Codec) -> any()`

<a name="signed_with_inner_signed_message_test-1"></a>

### signed_with_inner_signed_message_test/1 * ###

`signed_with_inner_signed_message_test(Codec) -> any()`

<a name="signers-1"></a>

### signers/1 ###

`signers(Msg) -> any()`

Return all of the committers on a message that have 'normal', 256 bit,
addresses.

<a name="simple_nested_message_test-1"></a>

### simple_nested_message_test/1 * ###

`simple_nested_message_test(Codec) -> any()`

<a name="single_layer_message_to_encoding_test-1"></a>

### single_layer_message_to_encoding_test/1 * ###

`single_layer_message_to_encoding_test(Codec) -> any()`

Test that we can convert a message into a tx record and back.

<a name="structured_field_atom_parsing_test-1"></a>

### structured_field_atom_parsing_test/1 * ###

`structured_field_atom_parsing_test(Codec) -> any()`

Structured field parsing tests.

<a name="structured_field_decimal_parsing_test-1"></a>

### structured_field_decimal_parsing_test/1 * ###

`structured_field_decimal_parsing_test(Codec) -> any()`

<a name="tabm_ao_ids_equal_test-1"></a>

### tabm_ao_ids_equal_test/1 * ###

`tabm_ao_ids_equal_test(Codec) -> any()`

<a name="test_codecs-0"></a>

### test_codecs/0 * ###

`test_codecs() -> any()`

<a name="to_tabm-3"></a>

### to_tabm/3 * ###

`to_tabm(Msg, SourceFormat, Opts) -> any()`

<a name="type-1"></a>

### type/1 ###

`type(TX) -> any()`

Return the type of an encoded message.

<a name="uncommitted-1"></a>

### uncommitted/1 ###

`uncommitted(Bin) -> any()`

Return the unsigned version of a message in AO-Core format.

<a name="unsigned_id_test-1"></a>

### unsigned_id_test/1 * ###

`unsigned_id_test(Codec) -> any()`

<a name="verify-1"></a>

### verify/1 ###

`verify(Msg) -> any()`

wrapper function to verify a message.

<a name="verify-2"></a>

### verify/2 ###

`verify(Msg, Committers) -> any()`

<a name="with_commitments-2"></a>

### with_commitments/2 ###

`with_commitments(Spec, Msg) -> any()`

Filter messages that do not match the 'spec' given. The underlying match
is performed in the `only_present` mode, such that match specifications only
need to specify the keys that must be present.

<a name="with_commitments-3"></a>

### with_commitments/3 * ###

`with_commitments(Spec, Msg, Opts) -> any()`

<a name="with_only_committed-1"></a>

### with_only_committed/1 ###

`with_only_committed(Msg) -> any()`

Return a message with only the committed keys. If no commitments are
present, the message is returned unchanged. This means that you need to
check if the message is:
- Committed
- Verifies
...before using the output of this function as the 'canonical' message. This
is such that expensive operations like signature verification are not
performed unless necessary.

<a name="with_only_committed-2"></a>

### with_only_committed/2 ###

`with_only_committed(Msg, Opts) -> any()`

<a name="with_only_committers-2"></a>

### with_only_committers/2 ###

`with_only_committers(Msg, Committers) -> any()`

Return the message with only the specified committers attached.

<a name="without_commitments-2"></a>

### without_commitments/2 ###

`without_commitments(Spec, Msg) -> any()`

Filter messages that match the 'spec' given. Inverts the `with_commitments/2`
function, such that only messages that do _not_ match the spec are returned.

<a name="without_commitments-3"></a>

### without_commitments/3 * ###

`without_commitments(Spec, Msg, Opts) -> any()`


--- END OF FILE: docs/resources/source-code/hb_message.md ---

--- START OF FILE: docs/resources/source-code/hb_metrics_collector.md ---
# [Module hb_metrics_collector.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_metrics_collector.erl)




__Behaviours:__ [`prometheus_collector`](prometheus_collector.md).

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#collect_metrics-2">collect_metrics/2</a></td><td></td></tr><tr><td valign="top"><a href="#collect_mf-2">collect_mf/2</a></td><td></td></tr><tr><td valign="top"><a href="#create_gauge-3">create_gauge/3*</a></td><td></td></tr><tr><td valign="top"><a href="#deregister_cleanup-1">deregister_cleanup/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="collect_metrics-2"></a>

### collect_metrics/2 ###

`collect_metrics(X1, SystemLoad) -> any()`

<a name="collect_mf-2"></a>

### collect_mf/2 ###

`collect_mf(Registry, Callback) -> any()`

<a name="create_gauge-3"></a>

### create_gauge/3 * ###

`create_gauge(Name, Help, Data) -> any()`

<a name="deregister_cleanup-1"></a>

### deregister_cleanup/1 ###

`deregister_cleanup(X1) -> any()`


--- END OF FILE: docs/resources/source-code/hb_metrics_collector.md ---

--- START OF FILE: docs/resources/source-code/hb_name.md ---
# [Module hb_name.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_name.erl)




An abstraction for name registration/deregistration in Hyperbeam.

<a name="description"></a>

## Description ##
Its motivation is to provide a way to register names that are not necessarily
atoms, but can be any term (for example: hashpaths or `process@1.0` IDs).
An important characteristic of these functions is that they are atomic:
There can only ever be one registrant for a given name at a time.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#all-0">all/0</a></td><td>List the names in the registry.</td></tr><tr><td valign="top"><a href="#all_test-0">all_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#atom_test-0">atom_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_test-1">basic_test/1*</a></td><td></td></tr><tr><td valign="top"><a href="#cleanup_test-0">cleanup_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#concurrency_test-0">concurrency_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#dead_process_test-0">dead_process_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#ets_lookup-1">ets_lookup/1*</a></td><td></td></tr><tr><td valign="top"><a href="#lookup-1">lookup/1</a></td><td>Lookup a name -> PID.</td></tr><tr><td valign="top"><a href="#register-1">register/1</a></td><td>Register a name.</td></tr><tr><td valign="top"><a href="#register-2">register/2</a></td><td></td></tr><tr><td valign="top"><a href="#spawn_test_workers-1">spawn_test_workers/1*</a></td><td></td></tr><tr><td valign="top"><a href="#start-0">start/0</a></td><td></td></tr><tr><td valign="top"><a href="#start_ets-0">start_ets/0*</a></td><td></td></tr><tr><td valign="top"><a href="#term_test-0">term_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#unregister-1">unregister/1</a></td><td>Unregister a name.</td></tr><tr><td valign="top"><a href="#wait_for_cleanup-2">wait_for_cleanup/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="all-0"></a>

### all/0 ###

`all() -> any()`

List the names in the registry.

<a name="all_test-0"></a>

### all_test/0 * ###

`all_test() -> any()`

<a name="atom_test-0"></a>

### atom_test/0 * ###

`atom_test() -> any()`

<a name="basic_test-1"></a>

### basic_test/1 * ###

`basic_test(Term) -> any()`

<a name="cleanup_test-0"></a>

### cleanup_test/0 * ###

`cleanup_test() -> any()`

<a name="concurrency_test-0"></a>

### concurrency_test/0 * ###

`concurrency_test() -> any()`

<a name="dead_process_test-0"></a>

### dead_process_test/0 * ###

`dead_process_test() -> any()`

<a name="ets_lookup-1"></a>

### ets_lookup/1 * ###

`ets_lookup(Name) -> any()`

<a name="lookup-1"></a>

### lookup/1 ###

`lookup(Name) -> any()`

Lookup a name -> PID.

<a name="register-1"></a>

### register/1 ###

`register(Name) -> any()`

Register a name. If the name is already registered, the registration
will fail. The name can be any Erlang term.

<a name="register-2"></a>

### register/2 ###

`register(Name, Pid) -> any()`

<a name="spawn_test_workers-1"></a>

### spawn_test_workers/1 * ###

`spawn_test_workers(Name) -> any()`

<a name="start-0"></a>

### start/0 ###

`start() -> any()`

<a name="start_ets-0"></a>

### start_ets/0 * ###

`start_ets() -> any()`

<a name="term_test-0"></a>

### term_test/0 * ###

`term_test() -> any()`

<a name="unregister-1"></a>

### unregister/1 ###

`unregister(Name) -> any()`

Unregister a name.

<a name="wait_for_cleanup-2"></a>

### wait_for_cleanup/2 * ###

`wait_for_cleanup(Name, Retries) -> any()`


--- END OF FILE: docs/resources/source-code/hb_name.md ---

--- START OF FILE: docs/resources/source-code/hb_opts.md ---
# [Module hb_opts.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_opts.erl)




A module for interacting with local and global options inside
HyperBEAM.

<a name="description"></a>

## Description ##

Options are set globally, but can also be overridden using an
an optional local `Opts` map argument. Many functions across the HyperBEAM
environment accept an `Opts` argument, which can be used to customize
behavior.

Options set in an `Opts` map must _never_ change the behavior of a function
that should otherwise be deterministic. Doing so may lead to loss of funds
by the HyperBEAM node operator, as the results of their executions will be
different than those of other node operators. If they are economically
staked on the correctness of these results, they may experience punishments
for non-verifiable behavior. Instead, if a local node setting makes
deterministic behavior impossible, the caller should fail the execution
with a refusal to execute.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cached_os_env-2">cached_os_env/2*</a></td><td>Cache the result of os:getenv/1 in the process dictionary, as it never
changes during the lifetime of a node.</td></tr><tr><td valign="top"><a href="#config_lookup-2">config_lookup/2*</a></td><td>An abstraction for looking up configuration variables.</td></tr><tr><td valign="top"><a href="#default_message-0">default_message/0</a></td><td>The default configuration options of the hyperbeam node.</td></tr><tr><td valign="top"><a href="#get-1">get/1</a></td><td>Get an option from the global options, optionally overriding with a
local <code>Opts</code> map if <code>prefer</code> or <code>only</code> is set to <code>local</code>.</td></tr><tr><td valign="top"><a href="#get-2">get/2</a></td><td></td></tr><tr><td valign="top"><a href="#get-3">get/3</a></td><td></td></tr><tr><td valign="top"><a href="#global_get-2">global_get/2*</a></td><td>Get an environment variable or configuration key.</td></tr><tr><td valign="top"><a href="#load-1">load/1</a></td><td>Parse a <code>flat@1.0</code> encoded file into a map, matching the types of the
keys to those in the default message.</td></tr><tr><td valign="top"><a href="#load_bin-1">load_bin/1</a></td><td></td></tr><tr><td valign="top"><a href="#mimic_default_types-2">mimic_default_types/2</a></td><td>Mimic the types of the default message for a given map.</td></tr><tr><td valign="top"><a href="#normalize_default-1">normalize_default/1*</a></td><td>Get an option from environment variables, optionally consulting the
<code>hb_features</code> of the node if a conditional default tuple is provided.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cached_os_env-2"></a>

### cached_os_env/2 * ###

`cached_os_env(Key, DefaultValue) -> any()`

Cache the result of os:getenv/1 in the process dictionary, as it never
changes during the lifetime of a node.

<a name="config_lookup-2"></a>

### config_lookup/2 * ###

`config_lookup(Key, Default) -> any()`

An abstraction for looking up configuration variables. In the future,
this is the function that we will want to change to support a more dynamic
configuration system.

<a name="default_message-0"></a>

### default_message/0 ###

`default_message() -> any()`

The default configuration options of the hyperbeam node.

<a name="get-1"></a>

### get/1 ###

`get(Key) -> any()`

Get an option from the global options, optionally overriding with a
local `Opts` map if `prefer` or `only` is set to `local`. If the `only`
option is provided in the `local` map, only keys found in the corresponding
(`local` or `global`) map will be returned. This function also offers users
a way to specify a default value to return if the option is not set.

`prefer` defaults to `local`.

<a name="get-2"></a>

### get/2 ###

`get(Key, Default) -> any()`

<a name="get-3"></a>

### get/3 ###

`get(Key, Default, Opts) -> any()`

<a name="global_get-2"></a>

### global_get/2 * ###

`global_get(Key, Default) -> any()`

Get an environment variable or configuration key.

<a name="load-1"></a>

### load/1 ###

`load(Path) -> any()`

Parse a `flat@1.0` encoded file into a map, matching the types of the
keys to those in the default message.

<a name="load_bin-1"></a>

### load_bin/1 ###

`load_bin(Bin) -> any()`

<a name="mimic_default_types-2"></a>

### mimic_default_types/2 ###

`mimic_default_types(Map, Mode) -> any()`

Mimic the types of the default message for a given map.

<a name="normalize_default-1"></a>

### normalize_default/1 * ###

`normalize_default(Default) -> any()`

Get an option from environment variables, optionally consulting the
`hb_features` of the node if a conditional default tuple is provided.


--- END OF FILE: docs/resources/source-code/hb_opts.md ---

--- START OF FILE: docs/resources/source-code/hb_path.md ---
# [Module hb_path.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_path.erl)




This module provides utilities for manipulating the paths of a
message: Its request path (referred to in messages as just the `Path`), and
its HashPath.

<a name="description"></a>

## Description ##

A HashPath is a rolling Merkle list of the messages that have been applied
in order to generate a given message. Because applied messages can
themselves be the result of message applications with the AO-Core protocol,
the HashPath can be thought of as the tree of messages that represent the
history of a given message. The initial message on a HashPath is referred to
by its ID and serves as its user-generated 'root'.

Specifically, the HashPath can be generated by hashing the previous HashPath
and the current message. This means that each message in the HashPath is
dependent on all previous messages.

```

       Msg1.HashPath = Msg1.ID
       Msg3.HashPath = Msg1.Hash(Msg1.HashPath, Msg2.ID)
       Msg3.{...} = AO-Core.apply(Msg1, Msg2)
       ...
```

A message's ID itself includes its HashPath, leading to the mixing of
a Msg2's merkle list into the resulting Msg3's HashPath. This allows a single
message to represent a history _tree_ of all of the messages that were
applied to generate it -- rather than just a linear history.

A message may also specify its own algorithm for generating its HashPath,
which allows for custom logic to be used for representing the history of a
message. When Msg2's are applied to a Msg1, the resulting Msg3's HashPath
will be generated according to Msg1's algorithm choice.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#do_to_binary-1">do_to_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#from_message-2">from_message/2</a></td><td>Extract the request path or hashpath from a message.</td></tr><tr><td valign="top"><a href="#hashpath-2">hashpath/2</a></td><td>Add an ID of a Msg2 to the HashPath of another message.</td></tr><tr><td valign="top"><a href="#hashpath-3">hashpath/3</a></td><td></td></tr><tr><td valign="top"><a href="#hashpath-4">hashpath/4</a></td><td></td></tr><tr><td valign="top"><a href="#hashpath_alg-1">hashpath_alg/1</a></td><td>Get the hashpath function for a message from its HashPath-Alg.</td></tr><tr><td valign="top"><a href="#hashpath_direct_msg2_test-0">hashpath_direct_msg2_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#hashpath_test-0">hashpath_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#hd-2">hd/2</a></td><td>Extract the first key from a <code>Message2</code>'s <code>Path</code> field.</td></tr><tr><td valign="top"><a href="#hd_test-0">hd_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#matches-2">matches/2</a></td><td>Check if two keys match.</td></tr><tr><td valign="top"><a href="#multiple_hashpaths_test-0">multiple_hashpaths_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize-1">normalize/1</a></td><td>Normalize a path to a binary, removing the leading slash if present.</td></tr><tr><td valign="top"><a href="#pop_from_message_test-0">pop_from_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#pop_from_path_list_test-0">pop_from_path_list_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#pop_request-2">pop_request/2</a></td><td>Pop the next element from a request path or path list.</td></tr><tr><td valign="top"><a href="#priv_remaining-2">priv_remaining/2</a></td><td>Return the <code>Remaining-Path</code> of a message, from its hidden <code>AO-Core</code>
key.</td></tr><tr><td valign="top"><a href="#priv_store_remaining-2">priv_store_remaining/2</a></td><td>Store the remaining path of a message in its hidden <code>AO-Core</code> key.</td></tr><tr><td valign="top"><a href="#push_request-2">push_request/2</a></td><td>Add a message to the head (next to execute) of a request path.</td></tr><tr><td valign="top"><a href="#queue_request-2">queue_request/2</a></td><td>Queue a message at the back of a request path.</td></tr><tr><td valign="top"><a href="#regex_matches-2">regex_matches/2</a></td><td>Check if two keys match using regex.</td></tr><tr><td valign="top"><a href="#regex_matches_test-0">regex_matches_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#term_to_path_parts-1">term_to_path_parts/1</a></td><td>Convert a term into an executable path.</td></tr><tr><td valign="top"><a href="#term_to_path_parts-2">term_to_path_parts/2</a></td><td></td></tr><tr><td valign="top"><a href="#term_to_path_parts_test-0">term_to_path_parts_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#tl-2">tl/2</a></td><td>Return the message without its first path element.</td></tr><tr><td valign="top"><a href="#tl_test-0">tl_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_binary-1">to_binary/1</a></td><td>Convert a path of any form to a binary.</td></tr><tr><td valign="top"><a href="#to_binary_test-0">to_binary_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#validate_path_transitions-2">validate_path_transitions/2*</a></td><td></td></tr><tr><td valign="top"><a href="#verify_hashpath-2">verify_hashpath/2</a></td><td>Verify the HashPath of a message, given a list of messages that
represent its history.</td></tr><tr><td valign="top"><a href="#verify_hashpath_test-0">verify_hashpath_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="do_to_binary-1"></a>

### do_to_binary/1 * ###

`do_to_binary(Path) -> any()`

<a name="from_message-2"></a>

### from_message/2 ###

`from_message(X1, Msg) -> any()`

Extract the request path or hashpath from a message. We do not use
AO-Core for this resolution because this function is called from inside AO-Core
itself. This imparts a requirement: the message's device must store a
viable hashpath and path in its Erlang map at all times, unless the message
is directly from a user (in which case paths and hashpaths will not have
been assigned yet).

<a name="hashpath-2"></a>

### hashpath/2 ###

`hashpath(Bin, Opts) -> any()`

Add an ID of a Msg2 to the HashPath of another message.

<a name="hashpath-3"></a>

### hashpath/3 ###

`hashpath(Msg1, Msg2, Opts) -> any()`

<a name="hashpath-4"></a>

### hashpath/4 ###

`hashpath(Msg1, Msg2, HashpathAlg, Opts) -> any()`

<a name="hashpath_alg-1"></a>

### hashpath_alg/1 ###

`hashpath_alg(Msg) -> any()`

Get the hashpath function for a message from its HashPath-Alg.
If no hashpath algorithm is specified, the protocol defaults to
`sha-256-chain`.

<a name="hashpath_direct_msg2_test-0"></a>

### hashpath_direct_msg2_test/0 * ###

`hashpath_direct_msg2_test() -> any()`

<a name="hashpath_test-0"></a>

### hashpath_test/0 * ###

`hashpath_test() -> any()`

<a name="hd-2"></a>

### hd/2 ###

`hd(Msg2, Opts) -> any()`

Extract the first key from a `Message2`'s `Path` field.
Note: This function uses the `dev_message:get/2` function, rather than
a generic call as the path should always be an explicit key in the message.

<a name="hd_test-0"></a>

### hd_test/0 * ###

`hd_test() -> any()`

<a name="matches-2"></a>

### matches/2 ###

`matches(Key1, Key2) -> any()`

Check if two keys match.

<a name="multiple_hashpaths_test-0"></a>

### multiple_hashpaths_test/0 * ###

`multiple_hashpaths_test() -> any()`

<a name="normalize-1"></a>

### normalize/1 ###

`normalize(Path) -> any()`

Normalize a path to a binary, removing the leading slash if present.

<a name="pop_from_message_test-0"></a>

### pop_from_message_test/0 * ###

`pop_from_message_test() -> any()`

<a name="pop_from_path_list_test-0"></a>

### pop_from_path_list_test/0 * ###

`pop_from_path_list_test() -> any()`

<a name="pop_request-2"></a>

### pop_request/2 ###

`pop_request(Msg, Opts) -> any()`

Pop the next element from a request path or path list.

<a name="priv_remaining-2"></a>

### priv_remaining/2 ###

`priv_remaining(Msg, Opts) -> any()`

Return the `Remaining-Path` of a message, from its hidden `AO-Core`
key. Does not use the `get` or set `hb_private` functions, such that it
can be safely used inside the main AO-Core resolve function.

<a name="priv_store_remaining-2"></a>

### priv_store_remaining/2 ###

`priv_store_remaining(Msg, RemainingPath) -> any()`

Store the remaining path of a message in its hidden `AO-Core` key.

<a name="push_request-2"></a>

### push_request/2 ###

`push_request(Msg, Path) -> any()`

Add a message to the head (next to execute) of a request path.

<a name="queue_request-2"></a>

### queue_request/2 ###

`queue_request(Msg, Path) -> any()`

Queue a message at the back of a request path. `path` is the only
key that we cannot use dev_message's `set/3` function for (as it expects
the compute path to be there), so we use `maps:put/3` instead.

<a name="regex_matches-2"></a>

### regex_matches/2 ###

`regex_matches(Path1, Path2) -> any()`

Check if two keys match using regex.

<a name="regex_matches_test-0"></a>

### regex_matches_test/0 * ###

`regex_matches_test() -> any()`

<a name="term_to_path_parts-1"></a>

### term_to_path_parts/1 ###

`term_to_path_parts(Path) -> any()`

Convert a term into an executable path. Supports binaries, lists, and
atoms. Notably, it does not support strings as lists of characters.

<a name="term_to_path_parts-2"></a>

### term_to_path_parts/2 ###

`term_to_path_parts(Binary, Opts) -> any()`

<a name="term_to_path_parts_test-0"></a>

### term_to_path_parts_test/0 * ###

`term_to_path_parts_test() -> any()`

<a name="tl-2"></a>

### tl/2 ###

`tl(Msg2, Opts) -> any()`

Return the message without its first path element. Note that this
is the only transformation in AO-Core that does _not_ make a log of its
transformation. Subsequently, the message's IDs will not be verifiable
after executing this transformation.
This may or may not be the mainnet behavior we want.

<a name="tl_test-0"></a>

### tl_test/0 * ###

`tl_test() -> any()`

<a name="to_binary-1"></a>

### to_binary/1 ###

`to_binary(Path) -> any()`

Convert a path of any form to a binary.

<a name="to_binary_test-0"></a>

### to_binary_test/0 * ###

`to_binary_test() -> any()`

<a name="validate_path_transitions-2"></a>

### validate_path_transitions/2 * ###

`validate_path_transitions(X, Opts) -> any()`

<a name="verify_hashpath-2"></a>

### verify_hashpath/2 ###

`verify_hashpath(Rest, Opts) -> any()`

Verify the HashPath of a message, given a list of messages that
represent its history.

<a name="verify_hashpath_test-0"></a>

### verify_hashpath_test/0 * ###

`verify_hashpath_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_path.md ---

--- START OF FILE: docs/resources/source-code/hb_persistent.md ---
# [Module hb_persistent.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_persistent.erl)




Creates and manages long-lived AO-Core resolution processes.

<a name="description"></a>

## Description ##

These can be useful for situations where a message is large and expensive
to serialize and deserialize, or when executions should be deliberately
serialized to avoid parallel executions of the same computation. This
module is called during the core `hb_ao` execution process, so care
must be taken to avoid recursive spawns/loops.

Built using the `pg` module, which is a distributed Erlang process group
manager.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#await-4">await/4</a></td><td>If there was already an Erlang process handling this execution,
we should register with them and wait for them to notify us of
completion.</td></tr><tr><td valign="top"><a href="#deduplicated_execution_test-0">deduplicated_execution_test/0*</a></td><td>Test merging and returning a value with a persistent worker.</td></tr><tr><td valign="top"><a href="#default_await-5">default_await/5</a></td><td>Default await function that waits for a resolution from a worker.</td></tr><tr><td valign="top"><a href="#default_grouper-3">default_grouper/3</a></td><td>Create a group name from a Msg1 and Msg2 pair as a tuple.</td></tr><tr><td valign="top"><a href="#default_worker-3">default_worker/3</a></td><td>A server function for handling persistent executions.</td></tr><tr><td valign="top"><a href="#do_monitor-1">do_monitor/1*</a></td><td></td></tr><tr><td valign="top"><a href="#do_monitor-2">do_monitor/2*</a></td><td></td></tr><tr><td valign="top"><a href="#find_execution-2">find_execution/2*</a></td><td>Find a group with the given name.</td></tr><tr><td valign="top"><a href="#find_or_register-3">find_or_register/3</a></td><td>Register the process to lead an execution if none is found, otherwise
signal that we should await resolution.</td></tr><tr><td valign="top"><a href="#find_or_register-4">find_or_register/4*</a></td><td></td></tr><tr><td valign="top"><a href="#forward_work-2">forward_work/2</a></td><td>Forward requests to a newly delegated execution process.</td></tr><tr><td valign="top"><a href="#group-3">group/3</a></td><td>Calculate the group name for a Msg1 and Msg2 pair.</td></tr><tr><td valign="top"><a href="#notify-4">notify/4</a></td><td>Check our inbox for processes that are waiting for the resolution
of this execution.</td></tr><tr><td valign="top"><a href="#persistent_worker_test-0">persistent_worker_test/0*</a></td><td>Test spawning a default persistent worker.</td></tr><tr><td valign="top"><a href="#register_groupname-2">register_groupname/2*</a></td><td>Register for performing an AO-Core resolution.</td></tr><tr><td valign="top"><a href="#send_response-4">send_response/4*</a></td><td>Helper function that wraps responding with a new Msg3.</td></tr><tr><td valign="top"><a href="#spawn_after_execution_test-0">spawn_after_execution_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#spawn_test_client-2">spawn_test_client/2*</a></td><td></td></tr><tr><td valign="top"><a href="#spawn_test_client-3">spawn_test_client/3*</a></td><td></td></tr><tr><td valign="top"><a href="#start-0">start/0*</a></td><td>Ensure that the <code>pg</code> module is started.</td></tr><tr><td valign="top"><a href="#start_monitor-0">start_monitor/0</a></td><td>Start a monitor that prints the current members of the group every
n seconds.</td></tr><tr><td valign="top"><a href="#start_monitor-1">start_monitor/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_worker-2">start_worker/2</a></td><td>Start a worker process that will hold a message in memory for
future executions.</td></tr><tr><td valign="top"><a href="#start_worker-3">start_worker/3</a></td><td></td></tr><tr><td valign="top"><a href="#stop_monitor-1">stop_monitor/1</a></td><td></td></tr><tr><td valign="top"><a href="#test_device-0">test_device/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_device-1">test_device/1*</a></td><td></td></tr><tr><td valign="top"><a href="#unregister-3">unregister/3*</a></td><td>Unregister for being the leader on an AO-Core resolution.</td></tr><tr><td valign="top"><a href="#unregister_groupname-2">unregister_groupname/2*</a></td><td></td></tr><tr><td valign="top"><a href="#unregister_notify-4">unregister_notify/4</a></td><td>Unregister as the leader for an execution and notify waiting processes.</td></tr><tr><td valign="top"><a href="#wait_for_test_result-1">wait_for_test_result/1*</a></td><td></td></tr><tr><td valign="top"><a href="#worker_event-5">worker_event/5*</a></td><td>Log an event with the worker process.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="await-4"></a>

### await/4 ###

`await(Worker, Msg1, Msg2, Opts) -> any()`

If there was already an Erlang process handling this execution,
we should register with them and wait for them to notify us of
completion.

<a name="deduplicated_execution_test-0"></a>

### deduplicated_execution_test/0 * ###

`deduplicated_execution_test() -> any()`

Test merging and returning a value with a persistent worker.

<a name="default_await-5"></a>

### default_await/5 ###

`default_await(Worker, GroupName, Msg1, Msg2, Opts) -> any()`

Default await function that waits for a resolution from a worker.

<a name="default_grouper-3"></a>

### default_grouper/3 ###

`default_grouper(Msg1, Msg2, Opts) -> any()`

Create a group name from a Msg1 and Msg2 pair as a tuple.

<a name="default_worker-3"></a>

### default_worker/3 ###

`default_worker(GroupName, Msg1, Opts) -> any()`

A server function for handling persistent executions.

<a name="do_monitor-1"></a>

### do_monitor/1 * ###

`do_monitor(Group) -> any()`

<a name="do_monitor-2"></a>

### do_monitor/2 * ###

`do_monitor(Group, Last) -> any()`

<a name="find_execution-2"></a>

### find_execution/2 * ###

`find_execution(Groupname, Opts) -> any()`

Find a group with the given name.

<a name="find_or_register-3"></a>

### find_or_register/3 ###

`find_or_register(Msg1, Msg2, Opts) -> any()`

Register the process to lead an execution if none is found, otherwise
signal that we should await resolution.

<a name="find_or_register-4"></a>

### find_or_register/4 * ###

`find_or_register(GroupName, Msg1, Msg2, Opts) -> any()`

<a name="forward_work-2"></a>

### forward_work/2 ###

`forward_work(NewPID, Opts) -> any()`

Forward requests to a newly delegated execution process.

<a name="group-3"></a>

### group/3 ###

`group(Msg1, Msg2, Opts) -> any()`

Calculate the group name for a Msg1 and Msg2 pair. Uses the Msg1's
`group` function if it is found in the `info`, otherwise uses the default.

<a name="notify-4"></a>

### notify/4 ###

`notify(GroupName, Msg2, Msg3, Opts) -> any()`

Check our inbox for processes that are waiting for the resolution
of this execution. Comes in two forms:
1. Notify on group name alone.
2. Notify on group name and Msg2.

<a name="persistent_worker_test-0"></a>

### persistent_worker_test/0 * ###

`persistent_worker_test() -> any()`

Test spawning a default persistent worker.

<a name="register_groupname-2"></a>

### register_groupname/2 * ###

`register_groupname(Groupname, Opts) -> any()`

Register for performing an AO-Core resolution.

<a name="send_response-4"></a>

### send_response/4 * ###

`send_response(Listener, GroupName, Msg2, Msg3) -> any()`

Helper function that wraps responding with a new Msg3.

<a name="spawn_after_execution_test-0"></a>

### spawn_after_execution_test/0 * ###

`spawn_after_execution_test() -> any()`

<a name="spawn_test_client-2"></a>

### spawn_test_client/2 * ###

`spawn_test_client(Msg1, Msg2) -> any()`

<a name="spawn_test_client-3"></a>

### spawn_test_client/3 * ###

`spawn_test_client(Msg1, Msg2, Opts) -> any()`

<a name="start-0"></a>

### start/0 * ###

`start() -> any()`

Ensure that the `pg` module is started.

<a name="start_monitor-0"></a>

### start_monitor/0 ###

`start_monitor() -> any()`

Start a monitor that prints the current members of the group every
n seconds.

<a name="start_monitor-1"></a>

### start_monitor/1 ###

`start_monitor(Group) -> any()`

<a name="start_worker-2"></a>

### start_worker/2 ###

`start_worker(Msg, Opts) -> any()`

Start a worker process that will hold a message in memory for
future executions.

<a name="start_worker-3"></a>

### start_worker/3 ###

`start_worker(GroupName, NotMsg, Opts) -> any()`

<a name="stop_monitor-1"></a>

### stop_monitor/1 ###

`stop_monitor(PID) -> any()`

<a name="test_device-0"></a>

### test_device/0 * ###

`test_device() -> any()`

<a name="test_device-1"></a>

### test_device/1 * ###

`test_device(Base) -> any()`

<a name="unregister-3"></a>

### unregister/3 * ###

`unregister(Msg1, Msg2, Opts) -> any()`

Unregister for being the leader on an AO-Core resolution.

<a name="unregister_groupname-2"></a>

### unregister_groupname/2 * ###

`unregister_groupname(Groupname, Opts) -> any()`

<a name="unregister_notify-4"></a>

### unregister_notify/4 ###

`unregister_notify(GroupName, Msg2, Msg3, Opts) -> any()`

Unregister as the leader for an execution and notify waiting processes.

<a name="wait_for_test_result-1"></a>

### wait_for_test_result/1 * ###

`wait_for_test_result(Ref) -> any()`

<a name="worker_event-5"></a>

### worker_event/5 * ###

`worker_event(Group, Data, Msg1, Msg2, Opts) -> any()`

Log an event with the worker process. If we used the default grouper
function, we should also include the Msg1 and Msg2 in the event. If we did not,
we assume that the group name expresses enough information to identify the
request.


--- END OF FILE: docs/resources/source-code/hb_persistent.md ---

--- START OF FILE: docs/resources/source-code/hb_private.md ---
# [Module hb_private.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_private.erl)




This module provides basic helper utilities for managing the
private element of a message, which can be used to store state that is
not included in serialized messages, or those granted to users via the
APIs.

<a name="description"></a>

## Description ##

Private elements of a message can be useful for storing state that
is only relevant temporarily. For example, a device might use the private
element to store a cache of values that are expensive to recompute. They
should _not_ be used for encoding state that makes the execution of a
device non-deterministic (unless you are sure you know what you are doing).

The `set` and `get` functions of this module allow you to run those keys
as AO-Core paths if you would like to have private `devices` in the
messages non-public zone.

See `hb_ao` for more information about the AO-Core protocol
and private elements of messages.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#from_message-1">from_message/1</a></td><td>Return the <code>private</code> key from a message.</td></tr><tr><td valign="top"><a href="#get-3">get/3</a></td><td>Helper for getting a value from the private element of a message.</td></tr><tr><td valign="top"><a href="#get-4">get/4</a></td><td></td></tr><tr><td valign="top"><a href="#get_private_key_test-0">get_private_key_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#is_private-1">is_private/1</a></td><td>Check if a key is private.</td></tr><tr><td valign="top"><a href="#priv_ao_opts-1">priv_ao_opts/1*</a></td><td>The opts map that should be used when resolving paths against the
private element of a message.</td></tr><tr><td valign="top"><a href="#remove_private_specifier-1">remove_private_specifier/1*</a></td><td>Remove the first key from the path if it is a private specifier.</td></tr><tr><td valign="top"><a href="#reset-1">reset/1</a></td><td>Unset all of the private keys in a message.</td></tr><tr><td valign="top"><a href="#set-3">set/3</a></td><td></td></tr><tr><td valign="top"><a href="#set-4">set/4</a></td><td>Helper function for setting a key in the private element of a message.</td></tr><tr><td valign="top"><a href="#set_priv-2">set_priv/2</a></td><td>Helper function for setting the complete private element of a message.</td></tr><tr><td valign="top"><a href="#set_private_test-0">set_private_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="from_message-1"></a>

### from_message/1 ###

`from_message(Msg) -> any()`

Return the `private` key from a message. If the key does not exist, an
empty map is returned.

<a name="get-3"></a>

### get/3 ###

`get(Key, Msg, Opts) -> any()`

Helper for getting a value from the private element of a message. Uses
AO-Core resolve under-the-hood, removing the private specifier from the
path if it exists.

<a name="get-4"></a>

### get/4 ###

`get(InputPath, Msg, Default, Opts) -> any()`

<a name="get_private_key_test-0"></a>

### get_private_key_test/0 * ###

`get_private_key_test() -> any()`

<a name="is_private-1"></a>

### is_private/1 ###

`is_private(Key) -> any()`

Check if a key is private.

<a name="priv_ao_opts-1"></a>

### priv_ao_opts/1 * ###

`priv_ao_opts(Opts) -> any()`

The opts map that should be used when resolving paths against the
private element of a message.

<a name="remove_private_specifier-1"></a>

### remove_private_specifier/1 * ###

`remove_private_specifier(InputPath) -> any()`

Remove the first key from the path if it is a private specifier.

<a name="reset-1"></a>

### reset/1 ###

`reset(Msg) -> any()`

Unset all of the private keys in a message.

<a name="set-3"></a>

### set/3 ###

`set(Msg, PrivMap, Opts) -> any()`

<a name="set-4"></a>

### set/4 ###

`set(Msg, InputPath, Value, Opts) -> any()`

Helper function for setting a key in the private element of a message.

<a name="set_priv-2"></a>

### set_priv/2 ###

`set_priv(Msg, PrivMap) -> any()`

Helper function for setting the complete private element of a message.

<a name="set_private_test-0"></a>

### set_private_test/0 * ###

`set_private_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_private.md ---

--- START OF FILE: docs/resources/source-code/hb_process_monitor.md ---
# [Module hb_process_monitor.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_process_monitor.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#handle_crons-1">handle_crons/1*</a></td><td></td></tr><tr><td valign="top"><a href="#server-1">server/1*</a></td><td></td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td></td></tr><tr><td valign="top"><a href="#start-2">start/2</a></td><td></td></tr><tr><td valign="top"><a href="#start-3">start/3</a></td><td></td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr><tr><td valign="top"><a href="#ticker-2">ticker/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="handle_crons-1"></a>

### handle_crons/1 * ###

`handle_crons(State) -> any()`

<a name="server-1"></a>

### server/1 * ###

`server(State) -> any()`

<a name="start-1"></a>

### start/1 ###

`start(ProcID) -> any()`

<a name="start-2"></a>

### start/2 ###

`start(ProcID, Rate) -> any()`

<a name="start-3"></a>

### start/3 ###

`start(ProcID, Rate, Cursor) -> any()`

<a name="stop-1"></a>

### stop/1 ###

`stop(PID) -> any()`

<a name="ticker-2"></a>

### ticker/2 * ###

`ticker(Monitor, Rate) -> any()`


--- END OF FILE: docs/resources/source-code/hb_process_monitor.md ---

--- START OF FILE: docs/resources/source-code/hb_router.md ---
# [Module hb_router.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_router.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#find-2">find/2</a></td><td></td></tr><tr><td valign="top"><a href="#find-3">find/3</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="find-2"></a>

### find/2 ###

`find(Type, ID) -> any()`

<a name="find-3"></a>

### find/3 ###

`find(Type, ID, Address) -> any()`


--- END OF FILE: docs/resources/source-code/hb_router.md ---

--- START OF FILE: docs/resources/source-code/hb_singleton.md ---
# [Module hb_singleton.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_singleton.erl)



* [Data Types](#types)

A parser that translates AO-Core HTTP API requests in TABM format
into an ordered list of messages to evaluate.

<a name="description"></a>

## Description ##

The details of this format
are described in `docs/ao-core-http-api.md`.

Syntax overview:

```

       Singleton: Message containing keys and a <code>path</code> field,
                  which may also contain a query string of key-value pairs.
       Path:
           - /Part1/Part2/.../PartN/ => [Part1, Part2, ..., PartN]
           - /ID/Part2/.../PartN => [ID, Part2, ..., PartN]
       Part: (Key + Resolution), Device?, #{ K => V}?
           - Part => #{ path => Part }
           - <code>Part&Key=Value => #{ path => Part, Key => Value }</code>
           - <code>Part&Key => #{ path => Part, Key => true }</code>
           - <code>Part&k1=v1&k2=v2 => #{ path => Part, k1 => `<<"v1">></code>, k2 => <code><<"v2">></code> }'
           - <code>Part~Device => {as, Device, #{ path => Part }}</code>
           - <code>Part~D&K1=V1 => {as, D, #{ path => Part, K1 => `<<"v1">></code> }}'
           - <code>pt&k1+int=1 => #{ path => pt, k1 => 1 }</code>
           - <code>pt~d&k1+int=1 => {as, d, #{ path => pt, k1 => 1 }}</code>
           - <code>(/nested/path) => Resolution of the path /nested/path</code>
           - <code>(/nested/path&k1=v1) => (resolve /nested/path)#{k1 => v1}</code>
           - <code>(/nested/path~D&K1=V1) => (resolve /nested/path)#{K1 => V1}</code>
           - <code>pt&k1+res=(/a/b/c) => #{ path => pt, k1 => (resolve /a/b/c) }</code>
       Key:
           - key: <code><<"value">></code> => #{ key => <code><<"value">></code>, ... } for all messages
           - n.key: <code><<"value">></code> => #{ key => <code><<"value">></code>, ... } for Nth message
           - key+Int: 1 => #{ key => 1, ... }
           - key+Res: /nested/path => #{ key => (resolve /nested/path), ... }
           - N.Key+Res=(/a/b/c) => #{ Key => (resolve /a/b/c), ... }
```

<a name="types"></a>

## Data Types ##




### <a name="type-ao_message">ao_message()</a> ###


<pre><code>
ao_message() = map() | binary()
</code></pre>




### <a name="type-tabm_message">tabm_message()</a> ###


<pre><code>
tabm_message() = map()
</code></pre>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#all_path_parts-2">all_path_parts/2*</a></td><td>Extract all of the parts from the binary, given (a list of) separators.</td></tr><tr><td valign="top"><a href="#append_path-2">append_path/2*</a></td><td></td></tr><tr><td valign="top"><a href="#apply_types-1">apply_types/1*</a></td><td>Step 3: Apply types to values and remove specifiers.</td></tr><tr><td valign="top"><a href="#basic_hashpath_test-0">basic_hashpath_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#basic_hashpath_to_test-0">basic_hashpath_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#build_messages-2">build_messages/2*</a></td><td>Step 5: Merge the base message with the scoped messages.</td></tr><tr><td valign="top"><a href="#decode_string-1">decode_string/1*</a></td><td>Attempt Cowboy URL decode, then sanitize the result.</td></tr><tr><td valign="top"><a href="#do_build-3">do_build/3*</a></td><td></td></tr><tr><td valign="top"><a href="#from-1">from/1</a></td><td>Normalize a singleton TABM message into a list of executable AO-Core
messages.</td></tr><tr><td valign="top"><a href="#group_scoped-2">group_scoped/2*</a></td><td>Step 4: Group headers/query by N-scope.</td></tr><tr><td valign="top"><a href="#inlined_keys_test-0">inlined_keys_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#inlined_keys_to_test-0">inlined_keys_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_join-2">maybe_join/2*</a></td><td>Join a list of items with a separator, or return the first item if there
is only one item.</td></tr><tr><td valign="top"><a href="#maybe_subpath-1">maybe_subpath/1*</a></td><td>Check if the string is a subpath, returning it in parsed form,
or the original string with a specifier.</td></tr><tr><td valign="top"><a href="#maybe_typed-2">maybe_typed/2*</a></td><td>Parse a key's type (applying it to the value) and device name if present.</td></tr><tr><td valign="top"><a href="#multiple_inlined_keys_test-0">multiple_inlined_keys_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_inlined_keys_to_test-0">multiple_inlined_keys_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_messages_test-0">multiple_messages_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#multiple_messages_to_test-0">multiple_messages_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_base-1">normalize_base/1*</a></td><td>Normalize the base path.</td></tr><tr><td valign="top"><a href="#parse_explicit_message_test-0">parse_explicit_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_full_path-1">parse_full_path/1*</a></td><td>Parse the relative reference into path, query, and fragment.</td></tr><tr><td valign="top"><a href="#parse_inlined_key_val-1">parse_inlined_key_val/1*</a></td><td>Extrapolate the inlined key-value pair from a path segment.</td></tr><tr><td valign="top"><a href="#parse_part-1">parse_part/1*</a></td><td>Parse a path part into a message or an ID.</td></tr><tr><td valign="top"><a href="#parse_part_mods-2">parse_part_mods/2*</a></td><td>Parse part modifiers:
1.</td></tr><tr><td valign="top"><a href="#parse_scope-1">parse_scope/1*</a></td><td>Get the scope of a key.</td></tr><tr><td valign="top"><a href="#part-2">part/2*</a></td><td>Extract the characters from the binary until a separator is found.</td></tr><tr><td valign="top"><a href="#part-4">part/4*</a></td><td></td></tr><tr><td valign="top"><a href="#path_messages-1">path_messages/1*</a></td><td>Step 2: Decode, split and sanitize the path.</td></tr><tr><td valign="top"><a href="#path_parts-2">path_parts/2*</a></td><td>Split the path into segments, filtering out empty segments and
segments that are too long.</td></tr><tr><td valign="top"><a href="#path_parts_test-0">path_parts_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#scoped_key_test-0">scoped_key_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#scoped_key_to_test-0">scoped_key_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#simple_to_test-0">simple_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#single_message_test-0">single_message_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_inlined_test-0">subpath_in_inlined_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_inlined_to_test-0">subpath_in_inlined_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_key_test-0">subpath_in_key_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_key_to_test-0">subpath_in_key_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_path_test-0">subpath_in_path_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#subpath_in_path_to_test-0">subpath_in_path_to_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to-1">to/1</a></td><td>Convert a list of AO-Core message into TABM message.</td></tr><tr><td valign="top"><a href="#to_suite_test_-0">to_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#type-1">type/1*</a></td><td></td></tr><tr><td valign="top"><a href="#typed_key_test-0">typed_key_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#typed_key_to_test-0">typed_key_to_test/0*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="all_path_parts-2"></a>

### all_path_parts/2 * ###

`all_path_parts(Sep, Bin) -> any()`

Extract all of the parts from the binary, given (a list of) separators.

<a name="append_path-2"></a>

### append_path/2 * ###

`append_path(PathPart, Message) -> any()`

<a name="apply_types-1"></a>

### apply_types/1 * ###

`apply_types(Msg) -> any()`

Step 3: Apply types to values and remove specifiers.

<a name="basic_hashpath_test-0"></a>

### basic_hashpath_test/0 * ###

`basic_hashpath_test() -> any()`

<a name="basic_hashpath_to_test-0"></a>

### basic_hashpath_to_test/0 * ###

`basic_hashpath_to_test() -> any()`

<a name="build_messages-2"></a>

### build_messages/2 * ###

`build_messages(Msgs, ScopedModifications) -> any()`

Step 5: Merge the base message with the scoped messages.

<a name="decode_string-1"></a>

### decode_string/1 * ###

`decode_string(B) -> any()`

Attempt Cowboy URL decode, then sanitize the result.

<a name="do_build-3"></a>

### do_build/3 * ###

`do_build(I, Rest, ScopedKeys) -> any()`

<a name="from-1"></a>

### from/1 ###

`from(RawMsg) -> any()`

Normalize a singleton TABM message into a list of executable AO-Core
messages.

<a name="group_scoped-2"></a>

### group_scoped/2 * ###

`group_scoped(Map, Msgs) -> any()`

Step 4: Group headers/query by N-scope.
`N.Key` => applies to Nth step. Otherwise => `global`

<a name="inlined_keys_test-0"></a>

### inlined_keys_test/0 * ###

`inlined_keys_test() -> any()`

<a name="inlined_keys_to_test-0"></a>

### inlined_keys_to_test/0 * ###

`inlined_keys_to_test() -> any()`

<a name="maybe_join-2"></a>

### maybe_join/2 * ###

`maybe_join(Items, Sep) -> any()`

Join a list of items with a separator, or return the first item if there
is only one item. If there are no items, return an empty binary.

<a name="maybe_subpath-1"></a>

### maybe_subpath/1 * ###

`maybe_subpath(Str) -> any()`

Check if the string is a subpath, returning it in parsed form,
or the original string with a specifier.

<a name="maybe_typed-2"></a>

### maybe_typed/2 * ###

`maybe_typed(Key, Value) -> any()`

Parse a key's type (applying it to the value) and device name if present.

<a name="multiple_inlined_keys_test-0"></a>

### multiple_inlined_keys_test/0 * ###

`multiple_inlined_keys_test() -> any()`

<a name="multiple_inlined_keys_to_test-0"></a>

### multiple_inlined_keys_to_test/0 * ###

`multiple_inlined_keys_to_test() -> any()`

<a name="multiple_messages_test-0"></a>

### multiple_messages_test/0 * ###

`multiple_messages_test() -> any()`

<a name="multiple_messages_to_test-0"></a>

### multiple_messages_to_test/0 * ###

`multiple_messages_to_test() -> any()`

<a name="normalize_base-1"></a>

### normalize_base/1 * ###

`normalize_base(Rest) -> any()`

Normalize the base path.

<a name="parse_explicit_message_test-0"></a>

### parse_explicit_message_test/0 * ###

`parse_explicit_message_test() -> any()`

<a name="parse_full_path-1"></a>

### parse_full_path/1 * ###

`parse_full_path(RelativeRef) -> any()`

Parse the relative reference into path, query, and fragment.

<a name="parse_inlined_key_val-1"></a>

### parse_inlined_key_val/1 * ###

`parse_inlined_key_val(Bin) -> any()`

Extrapolate the inlined key-value pair from a path segment. If the
key has a value, it may provide a type (as with typical keys), but if a
value is not provided, it is assumed to be a boolean `true`.

<a name="parse_part-1"></a>

### parse_part/1 * ###

`parse_part(ID) -> any()`

Parse a path part into a message or an ID.
Applies the syntax rules outlined in the module doc, in the following order:
1. ID
2. Part subpath resolutions
3. Inlined key-value pairs
4. Device specifier

<a name="parse_part_mods-2"></a>

### parse_part_mods/2 * ###

`parse_part_mods(X1, Msg) -> any()`

Parse part modifiers:
1. `~Device` => `{as, Device, Msg}`
2. `&K=V` => `Msg#{ K => V }`

<a name="parse_scope-1"></a>

### parse_scope/1 * ###

`parse_scope(KeyBin) -> any()`

Get the scope of a key. Adds 1 to account for the base message.

<a name="part-2"></a>

### part/2 * ###

`part(Sep, Bin) -> any()`

Extract the characters from the binary until a separator is found.
The first argument of the function is an explicit separator character, or
a list of separator characters. Returns a tuple with the separator, the
accumulated characters, and the rest of the binary.

<a name="part-4"></a>

### part/4 * ###

`part(Seps, X2, Depth, CurrAcc) -> any()`

<a name="path_messages-1"></a>

### path_messages/1 * ###

`path_messages(RawBin) -> any()`

Step 2: Decode, split and sanitize the path. Split by `/` but avoid
subpath components, such that their own path parts are not dissociated from
their parent path.

<a name="path_parts-2"></a>

### path_parts/2 * ###

`path_parts(Sep, PathBin) -> any()`

Split the path into segments, filtering out empty segments and
segments that are too long.

<a name="path_parts_test-0"></a>

### path_parts_test/0 * ###

`path_parts_test() -> any()`

<a name="scoped_key_test-0"></a>

### scoped_key_test/0 * ###

`scoped_key_test() -> any()`

<a name="scoped_key_to_test-0"></a>

### scoped_key_to_test/0 * ###

`scoped_key_to_test() -> any()`

<a name="simple_to_test-0"></a>

### simple_to_test/0 * ###

`simple_to_test() -> any()`

<a name="single_message_test-0"></a>

### single_message_test/0 * ###

`single_message_test() -> any()`

<a name="subpath_in_inlined_test-0"></a>

### subpath_in_inlined_test/0 * ###

`subpath_in_inlined_test() -> any()`

<a name="subpath_in_inlined_to_test-0"></a>

### subpath_in_inlined_to_test/0 * ###

`subpath_in_inlined_to_test() -> any()`

<a name="subpath_in_key_test-0"></a>

### subpath_in_key_test/0 * ###

`subpath_in_key_test() -> any()`

<a name="subpath_in_key_to_test-0"></a>

### subpath_in_key_to_test/0 * ###

`subpath_in_key_to_test() -> any()`

<a name="subpath_in_path_test-0"></a>

### subpath_in_path_test/0 * ###

`subpath_in_path_test() -> any()`

<a name="subpath_in_path_to_test-0"></a>

### subpath_in_path_to_test/0 * ###

`subpath_in_path_to_test() -> any()`

<a name="to-1"></a>

### to/1 ###

<pre><code>
to(Messages::[<a href="#type-ao_message">ao_message()</a>]) -&gt; <a href="#type-tabm_message">tabm_message()</a>
</code></pre>
<br />

Convert a list of AO-Core message into TABM message.

<a name="to_suite_test_-0"></a>

### to_suite_test_/0 * ###

`to_suite_test_() -> any()`

<a name="type-1"></a>

### type/1 * ###

`type(Value) -> any()`

<a name="typed_key_test-0"></a>

### typed_key_test/0 * ###

`typed_key_test() -> any()`

<a name="typed_key_to_test-0"></a>

### typed_key_to_test/0 * ###

`typed_key_to_test() -> any()`


--- END OF FILE: docs/resources/source-code/hb_singleton.md ---

--- START OF FILE: docs/resources/source-code/hb_store_fs.md ---
# [Module hb_store_fs.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_store_fs.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_prefix-2">add_prefix/2*</a></td><td>Add the directory prefix to a path.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td>List contents of a directory in the store.</td></tr><tr><td valign="top"><a href="#make_group-2">make_group/2</a></td><td>Create a directory (group) in the store.</td></tr><tr><td valign="top"><a href="#make_link-3">make_link/3</a></td><td>Create a symlink, handling the case where the link would point to itself.</td></tr><tr><td valign="top"><a href="#read-1">read/1*</a></td><td></td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read a key from the store, following symlinks as needed.</td></tr><tr><td valign="top"><a href="#remove_prefix-2">remove_prefix/2*</a></td><td>Remove the directory prefix from a path.</td></tr><tr><td valign="top"><a href="#reset-1">reset/1</a></td><td>Reset the store by completely removing its directory and recreating it.</td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td>Replace links in a path successively, returning the final path.</td></tr><tr><td valign="top"><a href="#resolve-3">resolve/3*</a></td><td></td></tr><tr><td valign="top"><a href="#scope-1">scope/1</a></td><td>The file-based store is always local, for now.</td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td>Initialize the file system store with the given data directory.</td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td>Stop the file system store.</td></tr><tr><td valign="top"><a href="#type-1">type/1*</a></td><td></td></tr><tr><td valign="top"><a href="#type-2">type/2</a></td><td>Determine the type of a key in the store.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write a value to the specified path in the store.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_prefix-2"></a>

### add_prefix/2 * ###

`add_prefix(X1, Path) -> any()`

Add the directory prefix to a path.

<a name="list-2"></a>

### list/2 ###

`list(Opts, Path) -> any()`

List contents of a directory in the store.

<a name="make_group-2"></a>

### make_group/2 ###

`make_group(Opts, Path) -> any()`

Create a directory (group) in the store.

<a name="make_link-3"></a>

### make_link/3 ###

`make_link(Opts, Link, New) -> any()`

Create a symlink, handling the case where the link would point to itself.

<a name="read-1"></a>

### read/1 * ###

`read(Path) -> any()`

<a name="read-2"></a>

### read/2 ###

`read(Opts, Key) -> any()`

Read a key from the store, following symlinks as needed.

<a name="remove_prefix-2"></a>

### remove_prefix/2 * ###

`remove_prefix(X1, Path) -> any()`

Remove the directory prefix from a path.

<a name="reset-1"></a>

### reset/1 ###

`reset(X1) -> any()`

Reset the store by completely removing its directory and recreating it.

<a name="resolve-2"></a>

### resolve/2 ###

`resolve(Opts, RawPath) -> any()`

Replace links in a path successively, returning the final path.
Each element of the path is resolved in turn, with the result of each
resolution becoming the prefix for the next resolution. This allows
paths to resolve across many links. For example, a structure as follows:

/a/b/c: "Not the right data"
/a/b -> /a/alt-b
/a/alt-b/c: "Correct data"

will resolve "a/b/c" to "Correct data".

<a name="resolve-3"></a>

### resolve/3 * ###

`resolve(Opts, CurrPath, Rest) -> any()`

<a name="scope-1"></a>

### scope/1 ###

`scope(X1) -> any()`

The file-based store is always local, for now. In the future, we may
want to allow that an FS store is shared across a cluster and thus remote.

<a name="start-1"></a>

### start/1 ###

`start(X1) -> any()`

Initialize the file system store with the given data directory.

<a name="stop-1"></a>

### stop/1 ###

`stop(X1) -> any()`

Stop the file system store. Currently a no-op.

<a name="type-1"></a>

### type/1 * ###

`type(Path) -> any()`

<a name="type-2"></a>

### type/2 ###

`type(Opts, Key) -> any()`

Determine the type of a key in the store.

<a name="write-3"></a>

### write/3 ###

`write(Opts, PathComponents, Value) -> any()`

Write a value to the specified path in the store.


--- END OF FILE: docs/resources/source-code/hb_store_fs.md ---

--- START OF FILE: docs/resources/source-code/hb_store_gateway.md ---
# [Module hb_store_gateway.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_store_gateway.erl)




A store module that reads data from the nodes Arweave gateway and
GraphQL routes, additionally including additional store-specific routes.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cache_read_message_test-0">cache_read_message_test/0*</a></td><td>Ensure that saving to the gateway store works.</td></tr><tr><td valign="top"><a href="#external_http_access_test-0">external_http_access_test/0*</a></td><td>Test that the default node config allows for data to be accessed.</td></tr><tr><td valign="top"><a href="#graphql_as_store_test_-0">graphql_as_store_test_/0*</a></td><td>Store is accessible via the default options.</td></tr><tr><td valign="top"><a href="#graphql_from_cache_test-0">graphql_from_cache_test/0*</a></td><td>Stored messages are accessible via <code>hb_cache</code> accesses.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td></td></tr><tr><td valign="top"><a href="#manual_local_cache_test-0">manual_local_cache_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_cache-2">maybe_cache/2*</a></td><td>Cache the data if the cache is enabled.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read the data at the given key from the GraphQL route.</td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td></td></tr><tr><td valign="top"><a href="#resolve_on_gateway_test_-0">resolve_on_gateway_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#scope-1">scope/1</a></td><td>The scope of a GraphQL store is always remote, due to performance.</td></tr><tr><td valign="top"><a href="#specific_route_test-0">specific_route_test/0*</a></td><td>Routes can be specified in the options, overriding the default routes.</td></tr><tr><td valign="top"><a href="#store_opts_test-0">store_opts_test/0*</a></td><td>Test to verify store opts is being set for Data-Protocol ao.</td></tr><tr><td valign="top"><a href="#type-2">type/2</a></td><td>Get the type of the data at the given key.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="cache_read_message_test-0"></a>

### cache_read_message_test/0 * ###

`cache_read_message_test() -> any()`

Ensure that saving to the gateway store works.

<a name="external_http_access_test-0"></a>

### external_http_access_test/0 * ###

`external_http_access_test() -> any()`

Test that the default node config allows for data to be accessed.

<a name="graphql_as_store_test_-0"></a>

### graphql_as_store_test_/0 * ###

`graphql_as_store_test_() -> any()`

Store is accessible via the default options.

<a name="graphql_from_cache_test-0"></a>

### graphql_from_cache_test/0 * ###

`graphql_from_cache_test() -> any()`

Stored messages are accessible via `hb_cache` accesses.

<a name="list-2"></a>

### list/2 ###

`list(StoreOpts, Key) -> any()`

<a name="manual_local_cache_test-0"></a>

### manual_local_cache_test/0 * ###

`manual_local_cache_test() -> any()`

<a name="maybe_cache-2"></a>

### maybe_cache/2 * ###

`maybe_cache(StoreOpts, Data) -> any()`

Cache the data if the cache is enabled. The `store` option may either
be `false` to disable local caching, or a store definition to use as the
cache.

<a name="read-2"></a>

### read/2 ###

`read(StoreOpts, Key) -> any()`

Read the data at the given key from the GraphQL route. Will only attempt
to read the data if the key is an ID.

<a name="resolve-2"></a>

### resolve/2 ###

`resolve(X1, Key) -> any()`

<a name="resolve_on_gateway_test_-0"></a>

### resolve_on_gateway_test_/0 * ###

`resolve_on_gateway_test_() -> any()`

<a name="scope-1"></a>

### scope/1 ###

`scope(X1) -> any()`

The scope of a GraphQL store is always remote, due to performance.

<a name="specific_route_test-0"></a>

### specific_route_test/0 * ###

`specific_route_test() -> any()`

Routes can be specified in the options, overriding the default routes.
We test this by inversion: If the above cache read test works, then we know
that the default routes allow access to the item. If the test below were to
produce the same result, despite an empty 'only' route list, then we would
know that the module is not respecting the route list.

<a name="store_opts_test-0"></a>

### store_opts_test/0 * ###

`store_opts_test() -> any()`

Test to verify store opts is being set for Data-Protocol ao

<a name="type-2"></a>

### type/2 ###

`type(StoreOpts, Key) -> any()`

Get the type of the data at the given key. We potentially cache the
result, so that we don't have to read the data from the GraphQL route
multiple times.


--- END OF FILE: docs/resources/source-code/hb_store_gateway.md ---

--- START OF FILE: docs/resources/source-code/hb_store_remote_node.md ---
# [Module hb_store_remote_node.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_store_remote_node.erl)




A store module that reads data from another AO node.

<a name="description"></a>

## Description ##
Notably, this store only provides the _read_ side of the store interface.
The write side could be added, returning an commitment that the data has
been written to the remote node. In that case, the node would probably want
to upload it to an Arweave bundler to ensure persistence, too.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#make_link-3">make_link/3</a></td><td>Link a source to a destination in the remote node.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read a key from the remote node.</td></tr><tr><td valign="top"><a href="#read_test-0">read_test/0*</a></td><td>Test that we can create a store, write a random message to it, then
start a remote node with that store, and read the message from it.</td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td>Resolve a key path in the remote store.</td></tr><tr><td valign="top"><a href="#scope-1">scope/1</a></td><td>Return the scope of this store.</td></tr><tr><td valign="top"><a href="#type-2">type/2</a></td><td>Determine the type of value at a given key.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write a key to the remote node.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="make_link-3"></a>

### make_link/3 ###

`make_link(Opts, Source, Destination) -> any()`

Link a source to a destination in the remote node.

Constructs an HTTP POST link request. If a wallet is provided,
the message is signed. Returns {ok, Path} on HTTP 200, or
{error, Reason} on failure.

<a name="read-2"></a>

### read/2 ###

`read(Opts, Key) -> any()`

Read a key from the remote node.

Makes an HTTP GET request to the remote node and returns the
committed message.

<a name="read_test-0"></a>

### read_test/0 * ###

`read_test() -> any()`

Test that we can create a store, write a random message to it, then
start a remote node with that store, and read the message from it.

<a name="resolve-2"></a>

### resolve/2 ###

`resolve(X1, Key) -> any()`

Resolve a key path in the remote store.

For the remote node store, the key is returned as-is.

<a name="scope-1"></a>

### scope/1 ###

`scope(Arg) -> any()`

Return the scope of this store.

For the remote store, the scope is always `remote`.

<a name="type-2"></a>

### type/2 ###

`type(Opts, Key) -> any()`

Determine the type of value at a given key.

Remote nodes support only the `simple` type or `not_found`.

<a name="write-3"></a>

### write/3 ###

`write(Opts, Key, Value) -> any()`

Write a key to the remote node.

Constructs an HTTP POST write request. If a wallet is provided,
the message is signed. Returns {ok, Path} on HTTP 200, or
{error, Reason} on failure.


--- END OF FILE: docs/resources/source-code/hb_store_remote_node.md ---

--- START OF FILE: docs/resources/source-code/hb_store_rocksdb.md ---
# [Module hb_store_rocksdb.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_store_rocksdb.erl)



* [Data Types](#types)

A process wrapper over rocksdb storage.

__Behaviours:__ [`gen_server`](gen_server.md), [`hb_store`](hb_store.md).

<a name="description"></a>

## Description ##

Replicates functionality of the
hb_fs_store module.

Encodes the item types with the help of prefixes, see `encode_value/2`
and `decode_value/1`
<a name="types"></a>

## Data Types ##




### <a name="type-key">key()</a> ###


<pre><code>
key() = binary() | list()
</code></pre>




### <a name="type-value">value()</a> ###


<pre><code>
value() = binary() | list()
</code></pre>




### <a name="type-value_type">value_type()</a> ###


<pre><code>
value_type() = link | raw | group
</code></pre>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_path-3">add_path/3</a></td><td>Add two path components together.</td></tr><tr><td valign="top"><a href="#code_change-3">code_change/3</a></td><td></td></tr><tr><td valign="top"><a href="#collect-1">collect/1*</a></td><td></td></tr><tr><td valign="top"><a href="#collect-2">collect/2*</a></td><td></td></tr><tr><td valign="top"><a href="#convert_if_list-1">convert_if_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#decode_value-1">decode_value/1*</a></td><td></td></tr><tr><td valign="top"><a href="#do_read-2">do_read/2*</a></td><td></td></tr><tr><td valign="top"><a href="#do_resolve-3">do_resolve/3*</a></td><td></td></tr><tr><td valign="top"><a href="#do_write-3">do_write/3*</a></td><td>Write given Key and Value to the database.</td></tr><tr><td valign="top"><a href="#enabled-0">enabled/0</a></td><td>Returns whether the RocksDB store is enabled.</td></tr><tr><td valign="top"><a href="#encode_value-2">encode_value/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ensure_dir-2">ensure_dir/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ensure_dir-3">ensure_dir/3*</a></td><td></td></tr><tr><td valign="top"><a href="#ensure_list-1">ensure_list/1*</a></td><td>Ensure that the given filename is a list, not a binary.</td></tr><tr><td valign="top"><a href="#handle_call-3">handle_call/3</a></td><td></td></tr><tr><td valign="top"><a href="#handle_cast-2">handle_cast/2</a></td><td></td></tr><tr><td valign="top"><a href="#handle_info-2">handle_info/2</a></td><td></td></tr><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#join-1">join/1*</a></td><td></td></tr><tr><td valign="top"><a href="#list-0">list/0</a></td><td>List all items registered in rocksdb store.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td>Returns the full list of items stored under the given path.</td></tr><tr><td valign="top"><a href="#make_group-2">make_group/2</a></td><td>Creates group under the given path.</td></tr><tr><td valign="top"><a href="#make_link-3">make_link/3</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_append_key_to_group-2">maybe_append_key_to_group/2*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_convert_to_binary-1">maybe_convert_to_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#maybe_create_dir-3">maybe_create_dir/3*</a></td><td></td></tr><tr><td valign="top"><a href="#open_rockdb-1">open_rockdb/1*</a></td><td></td></tr><tr><td valign="top"><a href="#path-2">path/2</a></td><td>Return path.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read data by the key.</td></tr><tr><td valign="top"><a href="#reset-1">reset/1</a></td><td></td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td>Replace links in a path with the target of the link.</td></tr><tr><td valign="top"><a href="#scope-1">scope/1</a></td><td>Return scope (local).</td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Start the RocksDB store.</td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr><tr><td valign="top"><a href="#terminate-2">terminate/2</a></td><td></td></tr><tr><td valign="top"><a href="#type-2">type/2</a></td><td>Get type of the current item.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write given Key and Value to the database.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_path-3"></a>

### add_path/3 ###

`add_path(Opts, Path1, Path2) -> any()`

Add two path components together. // is not used

<a name="code_change-3"></a>

### code_change/3 ###

`code_change(OldVsn, State, Extra) -> any()`

<a name="collect-1"></a>

### collect/1 * ###

`collect(Iterator) -> any()`

<a name="collect-2"></a>

### collect/2 * ###

`collect(Iterator, Acc) -> any()`

<a name="convert_if_list-1"></a>

### convert_if_list/1 * ###

`convert_if_list(Value) -> any()`

<a name="decode_value-1"></a>

### decode_value/1 * ###

<pre><code>
decode_value(X1::binary()) -&gt; {<a href="#type-value_type">value_type()</a>, binary()}
</code></pre>
<br />

<a name="do_read-2"></a>

### do_read/2 * ###

`do_read(Opts, Key) -> any()`

<a name="do_resolve-3"></a>

### do_resolve/3 * ###

`do_resolve(Opts, FinalPath, Rest) -> any()`

<a name="do_write-3"></a>

### do_write/3 * ###

<pre><code>
do_write(Opts, Key, Value) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = map()</code></li><li><code>Key = <a href="#type-key">key()</a></code></li><li><code>Value = <a href="#type-value">value()</a></code></li><li><code>Result = ok | {error, any()}</code></li></ul>

Write given Key and Value to the database

<a name="enabled-0"></a>

### enabled/0 ###

`enabled() -> any()`

Returns whether the RocksDB store is enabled.

<a name="encode_value-2"></a>

### encode_value/2 * ###

<pre><code>
encode_value(X1::<a href="#type-value_type">value_type()</a>, Value::binary()) -&gt; binary()
</code></pre>
<br />

<a name="ensure_dir-2"></a>

### ensure_dir/2 * ###

`ensure_dir(DBHandle, BaseDir) -> any()`

<a name="ensure_dir-3"></a>

### ensure_dir/3 * ###

`ensure_dir(DBHandle, CurrentPath, Rest) -> any()`

<a name="ensure_list-1"></a>

### ensure_list/1 * ###

`ensure_list(Value) -> any()`

Ensure that the given filename is a list, not a binary.

<a name="handle_call-3"></a>

### handle_call/3 ###

`handle_call(Request, From, State) -> any()`

<a name="handle_cast-2"></a>

### handle_cast/2 ###

`handle_cast(Request, State) -> any()`

<a name="handle_info-2"></a>

### handle_info/2 ###

`handle_info(Info, State) -> any()`

<a name="init-1"></a>

### init/1 ###

`init(Dir) -> any()`

<a name="join-1"></a>

### join/1 * ###

`join(Key) -> any()`

<a name="list-0"></a>

### list/0 ###

`list() -> any()`

List all items registered in rocksdb store. Should be used only
for testing/debugging, as the underlying operation is doing full traversal
on the KV storage, and is slow.

<a name="list-2"></a>

### list/2 ###

<pre><code>
list(Opts, Path) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = any()</code></li><li><code>Path = any()</code></li><li><code>Result = {ok, [string()]} | {error, term()}</code></li></ul>

Returns the full list of items stored under the given path. Where the path
child items is relevant to the path of parentItem. (Same as in `hb_store_fs`).

<a name="make_group-2"></a>

### make_group/2 ###

<pre><code>
make_group(Opts, Key) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = any()</code></li><li><code>Key = binary()</code></li><li><code>Result = ok | {error, already_added}</code></li></ul>

Creates group under the given path.

<a name="make_link-3"></a>

### make_link/3 ###

<pre><code>
make_link(Opts::any(), Key1::<a href="#type-key">key()</a>, New::<a href="#type-key">key()</a>) -&gt; ok
</code></pre>
<br />

<a name="maybe_append_key_to_group-2"></a>

### maybe_append_key_to_group/2 * ###

`maybe_append_key_to_group(Key, CurrentDirContents) -> any()`

<a name="maybe_convert_to_binary-1"></a>

### maybe_convert_to_binary/1 * ###

`maybe_convert_to_binary(Value) -> any()`

<a name="maybe_create_dir-3"></a>

### maybe_create_dir/3 * ###

`maybe_create_dir(DBHandle, DirPath, Value) -> any()`

<a name="open_rockdb-1"></a>

### open_rockdb/1 * ###

`open_rockdb(RawDir) -> any()`

<a name="path-2"></a>

### path/2 ###

`path(Opts, Path) -> any()`

Return path

<a name="read-2"></a>

### read/2 ###

<pre><code>
read(Opts, Key) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = map()</code></li><li><code>Key = <a href="#type-key">key()</a> | list()</code></li><li><code>Result = {ok, <a href="#type-value">value()</a>} | not_found | {error, {corruption, string()}} | {error, any()}</code></li></ul>

Read data by the key.
Recursively follows link messages

<a name="reset-1"></a>

### reset/1 ###

<pre><code>
reset(Opts::[]) -&gt; ok | no_return()
</code></pre>
<br />

<a name="resolve-2"></a>

### resolve/2 ###

<pre><code>
resolve(Opts, Path) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = any()</code></li><li><code>Path = binary() | list()</code></li><li><code>Result = not_found | string()</code></li></ul>

Replace links in a path with the target of the link.

<a name="scope-1"></a>

### scope/1 ###

`scope(X1) -> any()`

Return scope (local)

<a name="start-1"></a>

### start/1 ###

`start(Opts) -> any()`

<a name="start_link-1"></a>

### start_link/1 ###

`start_link(Opts) -> any()`

Start the RocksDB store.

<a name="stop-1"></a>

### stop/1 ###

<pre><code>
stop(Opts::any()) -&gt; ok
</code></pre>
<br />

<a name="terminate-2"></a>

### terminate/2 ###

`terminate(Reason, State) -> any()`

<a name="type-2"></a>

### type/2 ###

<pre><code>
type(Opts, Key) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = map()</code></li><li><code>Key = binary()</code></li><li><code>Result = composite | simple | not_found</code></li></ul>

Get type of the current item

<a name="write-3"></a>

### write/3 ###

<pre><code>
write(Opts, Key, Value) -&gt; Result
</code></pre>

<ul class="definitions"><li><code>Opts = map()</code></li><li><code>Key = <a href="#type-key">key()</a></code></li><li><code>Value = <a href="#type-value">value()</a></code></li><li><code>Result = ok | {error, any()}</code></li></ul>

Write given Key and Value to the database


--- END OF FILE: docs/resources/source-code/hb_store_rocksdb.md ---

--- START OF FILE: docs/resources/source-code/hb_store.md ---
# [Module hb_store.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_store.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_path-2">add_path/2</a></td><td>Add two path components together.</td></tr><tr><td valign="top"><a href="#add_path-3">add_path/3</a></td><td></td></tr><tr><td valign="top"><a href="#behavior_info-1">behavior_info/1</a></td><td></td></tr><tr><td valign="top"><a href="#call_all-3">call_all/3*</a></td><td>Call a function on all modules in the store.</td></tr><tr><td valign="top"><a href="#call_function-3">call_function/3*</a></td><td>Call a function on the first store module that succeeds.</td></tr><tr><td valign="top"><a href="#filter-2">filter/2</a></td><td>Takes a store object and a filter function or match spec, returning a
new store object with only the modules that match the filter.</td></tr><tr><td valign="top"><a href="#generate_test_suite-1">generate_test_suite/1</a></td><td></td></tr><tr><td valign="top"><a href="#generate_test_suite-2">generate_test_suite/2</a></td><td></td></tr><tr><td valign="top"><a href="#get_store_scope-1">get_store_scope/1*</a></td><td>Ask a store for its own scope.</td></tr><tr><td valign="top"><a href="#hierarchical_path_resolution_test-1">hierarchical_path_resolution_test/1*</a></td><td>Ensure that we can resolve links through a directory.</td></tr><tr><td valign="top"><a href="#join-1">join/1</a></td><td>Join a list of path components together.</td></tr><tr><td valign="top"><a href="#list-2">list/2</a></td><td>List the keys in a group in the store.</td></tr><tr><td valign="top"><a href="#make_group-2">make_group/2</a></td><td>Make a group in the store.</td></tr><tr><td valign="top"><a href="#make_link-3">make_link/3</a></td><td>Make a link from one path to another in the store.</td></tr><tr><td valign="top"><a href="#path-1">path/1</a></td><td>Create a path from a list of path components.</td></tr><tr><td valign="top"><a href="#path-2">path/2</a></td><td></td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td>Read a key from the store.</td></tr><tr><td valign="top"><a href="#reset-1">reset/1</a></td><td>Delete all of the keys in a store.</td></tr><tr><td valign="top"><a href="#resolve-2">resolve/2</a></td><td>Follow links through the store to resolve a path to its ultimate target.</td></tr><tr><td valign="top"><a href="#resursive_path_resolution_test-1">resursive_path_resolution_test/1*</a></td><td>Ensure that we can resolve links recursively.</td></tr><tr><td valign="top"><a href="#scope-2">scope/2</a></td><td>Limit the store scope to only a specific (set of) option(s).</td></tr><tr><td valign="top"><a href="#simple_path_resolution_test-1">simple_path_resolution_test/1*</a></td><td>Test path resolution dynamics.</td></tr><tr><td valign="top"><a href="#sort-2">sort/2</a></td><td>Order a store by a preference of its scopes.</td></tr><tr><td valign="top"><a href="#start-1">start/1</a></td><td></td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr><tr><td valign="top"><a href="#store_suite_test_-0">store_suite_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#test_stores-0">test_stores/0</a></td><td></td></tr><tr><td valign="top"><a href="#type-2">type/2</a></td><td>Get the type of element of a given path in the store.</td></tr><tr><td valign="top"><a href="#write-3">write/3</a></td><td>Write a key with a value to the store.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_path-2"></a>

### add_path/2 ###

`add_path(Path1, Path2) -> any()`

Add two path components together. If no store implements the add_path
function, we concatenate the paths.

<a name="add_path-3"></a>

### add_path/3 ###

`add_path(Store, Path1, Path2) -> any()`

<a name="behavior_info-1"></a>

### behavior_info/1 ###

`behavior_info(X1) -> any()`

<a name="call_all-3"></a>

### call_all/3 * ###

`call_all(X, Function, Args) -> any()`

Call a function on all modules in the store.

<a name="call_function-3"></a>

### call_function/3 * ###

`call_function(X, Function, Args) -> any()`

Call a function on the first store module that succeeds. Returns its
result, or no_viable_store if none of the stores succeed.

<a name="filter-2"></a>

### filter/2 ###

`filter(Module, Filter) -> any()`

Takes a store object and a filter function or match spec, returning a
new store object with only the modules that match the filter. The filter
function takes 2 arguments: the scope and the options. It calls the store's
scope function to get the scope of the module.

<a name="generate_test_suite-1"></a>

### generate_test_suite/1 ###

`generate_test_suite(Suite) -> any()`

<a name="generate_test_suite-2"></a>

### generate_test_suite/2 ###

`generate_test_suite(Suite, Stores) -> any()`

<a name="get_store_scope-1"></a>

### get_store_scope/1 * ###

`get_store_scope(Store) -> any()`

Ask a store for its own scope. If it doesn't have one, return the
default scope (local).

<a name="hierarchical_path_resolution_test-1"></a>

### hierarchical_path_resolution_test/1 * ###

`hierarchical_path_resolution_test(Opts) -> any()`

Ensure that we can resolve links through a directory.

<a name="join-1"></a>

### join/1 ###

`join(Path) -> any()`

Join a list of path components together.

<a name="list-2"></a>

### list/2 ###

`list(Modules, Path) -> any()`

List the keys in a group in the store. Use only in debugging.
The hyperbeam model assumes that stores are built as efficient hash-based
structures, so this is likely to be very slow for most stores.

<a name="make_group-2"></a>

### make_group/2 ###

`make_group(Modules, Path) -> any()`

Make a group in the store. A group can be seen as a namespace or
'directory' in a filesystem.

<a name="make_link-3"></a>

### make_link/3 ###

`make_link(Modules, Existing, New) -> any()`

Make a link from one path to another in the store.

<a name="path-1"></a>

### path/1 ###

`path(Path) -> any()`

Create a path from a list of path components. If no store implements
the path function, we return the path with the 'default' transformation (id).

<a name="path-2"></a>

### path/2 ###

`path(X1, Path) -> any()`

<a name="read-2"></a>

### read/2 ###

`read(Modules, Key) -> any()`

Read a key from the store.

<a name="reset-1"></a>

### reset/1 ###

`reset(Modules) -> any()`

Delete all of the keys in a store. Should be used with extreme
caution. Lost data can lose money in many/most of hyperbeam's use cases.

<a name="resolve-2"></a>

### resolve/2 ###

`resolve(Modules, Path) -> any()`

Follow links through the store to resolve a path to its ultimate target.

<a name="resursive_path_resolution_test-1"></a>

### resursive_path_resolution_test/1 * ###

`resursive_path_resolution_test(Opts) -> any()`

Ensure that we can resolve links recursively.

<a name="scope-2"></a>

### scope/2 ###

`scope(Scope, Opts) -> any()`

Limit the store scope to only a specific (set of) option(s).
Takes either an Opts message or store, and either a single scope or a list
of scopes.

<a name="simple_path_resolution_test-1"></a>

### simple_path_resolution_test/1 * ###

`simple_path_resolution_test(Opts) -> any()`

Test path resolution dynamics.

<a name="sort-2"></a>

### sort/2 ###

`sort(Stores, PreferenceOrder) -> any()`

Order a store by a preference of its scopes. This is useful for making
sure that faster (or perhaps cheaper) stores are used first. If a list is
provided, it will be used as a preference order. If a map is provided,
scopes will be ordered by the scores in the map. Any unknown scopes will
default to a score of 0.

<a name="start-1"></a>

### start/1 ###

`start(Modules) -> any()`

<a name="stop-1"></a>

### stop/1 ###

`stop(Modules) -> any()`

<a name="store_suite_test_-0"></a>

### store_suite_test_/0 * ###

`store_suite_test_() -> any()`

<a name="test_stores-0"></a>

### test_stores/0 ###

`test_stores() -> any()`

<a name="type-2"></a>

### type/2 ###

`type(Modules, Path) -> any()`

Get the type of element of a given path in the store. This can be
a performance killer if the store is remote etc. Use only when necessary.

<a name="write-3"></a>

### write/3 ###

`write(Modules, Key, Value) -> any()`

Write a key with a value to the store.


--- END OF FILE: docs/resources/source-code/hb_store.md ---

--- START OF FILE: docs/resources/source-code/hb_structured_fields.md ---
# [Module hb_structured_fields.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_structured_fields.erl)



* [Data Types](#types)

A module for parsing and converting between Erlang and HTTP Structured
Fields, as described in RFC-9651.

<a name="description"></a>

## Description ##

The mapping between Erlang and structured headers types is as follow:

List: list()
Inner list: {list, [item()], params()}
Dictionary: [{binary(), item()}]
There is no distinction between empty list and empty dictionary.
Item with parameters: {item, bare_item(), params()}
Parameters: [{binary(), bare_item()}]
Bare item: one bare_item() that can be of type:
Integer: integer()
Decimal: {decimal, {integer(), integer()}}
String: {string, binary()}
Token: {token, binary()}
Byte sequence: {binary, binary()}
Boolean: boolean()
<a name="types"></a>

## Data Types ##




### <a name="type-sh_bare_item">sh_bare_item()</a> ###


<pre><code>
sh_bare_item() = integer() | <a href="#type-sh_decimal">sh_decimal()</a> | boolean() | {string | token | binary, binary()}
</code></pre>




### <a name="type-sh_decimal">sh_decimal()</a> ###


<pre><code>
sh_decimal() = {decimal, {integer(), integer()}}
</code></pre>




### <a name="type-sh_dictionary">sh_dictionary()</a> ###


<pre><code>
sh_dictionary() = [{binary(), <a href="#type-sh_item">sh_item()</a> | <a href="#type-sh_inner_list">sh_inner_list()</a>}]
</code></pre>




### <a name="type-sh_inner_list">sh_inner_list()</a> ###


<pre><code>
sh_inner_list() = {list, [<a href="#type-sh_item">sh_item()</a>], <a href="#type-sh_params">sh_params()</a>}
</code></pre>




### <a name="type-sh_item">sh_item()</a> ###


<pre><code>
sh_item() = {item, <a href="#type-sh_bare_item">sh_bare_item()</a>, <a href="#type-sh_params">sh_params()</a>}
</code></pre>




### <a name="type-sh_list">sh_list()</a> ###


<pre><code>
sh_list() = [<a href="#type-sh_item">sh_item()</a> | <a href="#type-sh_inner_list">sh_inner_list()</a>]
</code></pre>




### <a name="type-sh_params">sh_params()</a> ###


<pre><code>
sh_params() = [{binary(), <a href="#type-sh_bare_item">sh_bare_item()</a>}]
</code></pre>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#bare_item-1">bare_item/1</a></td><td></td></tr><tr><td valign="top"><a href="#dictionary-1">dictionary/1</a></td><td></td></tr><tr><td valign="top"><a href="#e2t-1">e2t/1*</a></td><td></td></tr><tr><td valign="top"><a href="#e2tb-1">e2tb/1*</a></td><td></td></tr><tr><td valign="top"><a href="#e2tp-1">e2tp/1*</a></td><td></td></tr><tr><td valign="top"><a href="#escape_string-2">escape_string/2*</a></td><td></td></tr><tr><td valign="top"><a href="#exp_div-1">exp_div/1*</a></td><td></td></tr><tr><td valign="top"><a href="#expected_to_term-1">expected_to_term/1*</a></td><td></td></tr><tr><td valign="top"><a href="#from_bare_item-1">from_bare_item/1</a></td><td>Convert an SF <code>bare_item</code> to an Erlang term.</td></tr><tr><td valign="top"><a href="#inner_list-1">inner_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#item-1">item/1</a></td><td></td></tr><tr><td valign="top"><a href="#item_or_inner_list-1">item_or_inner_list/1*</a></td><td></td></tr><tr><td valign="top"><a href="#key_to_binary-1">key_to_binary/1*</a></td><td>Convert an Erlang term to a binary key.</td></tr><tr><td valign="top"><a href="#list-1">list/1</a></td><td></td></tr><tr><td valign="top"><a href="#params-1">params/1*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_bare_item-1">parse_bare_item/1</a></td><td>Parse an integer or decimal.</td></tr><tr><td valign="top"><a href="#parse_before_param-2">parse_before_param/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_binary-2">parse_binary/2*</a></td><td>Parse a byte sequence binary.</td></tr><tr><td valign="top"><a href="#parse_decimal-5">parse_decimal/5*</a></td><td>Parse a decimal binary.</td></tr><tr><td valign="top"><a href="#parse_dict_before_member-2">parse_dict_before_member/2*</a></td><td>Parse a binary SF dictionary before a member.</td></tr><tr><td valign="top"><a href="#parse_dict_before_sep-2">parse_dict_before_sep/2*</a></td><td>Parse a binary SF dictionary before a separator.</td></tr><tr><td valign="top"><a href="#parse_dict_key-3">parse_dict_key/3*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_dictionary-1">parse_dictionary/1</a></td><td>Parse a binary SF dictionary.</td></tr><tr><td valign="top"><a href="#parse_inner_list-2">parse_inner_list/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_item-1">parse_item/1</a></td><td>Parse a binary SF item to an SF <code>item</code>.</td></tr><tr><td valign="top"><a href="#parse_item1-1">parse_item1/1*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_list-1">parse_list/1</a></td><td>Parse a binary SF list.</td></tr><tr><td valign="top"><a href="#parse_list_before_member-2">parse_list_before_member/2*</a></td><td>Parse a binary SF list before a member.</td></tr><tr><td valign="top"><a href="#parse_list_before_sep-2">parse_list_before_sep/2*</a></td><td>Parse a binary SF list before a separator.</td></tr><tr><td valign="top"><a href="#parse_list_member-2">parse_list_member/2*</a></td><td>Parse a binary SF list before a member.</td></tr><tr><td valign="top"><a href="#parse_number-3">parse_number/3*</a></td><td>Parse an integer or decimal binary.</td></tr><tr><td valign="top"><a href="#parse_param-3">parse_param/3*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_string-2">parse_string/2*</a></td><td>Parse a string binary.</td></tr><tr><td valign="top"><a href="#parse_struct_hd_test_-0">parse_struct_hd_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_token-2">parse_token/2*</a></td><td>Parse a token binary.</td></tr><tr><td valign="top"><a href="#raw_to_binary-1">raw_to_binary/1*</a></td><td></td></tr><tr><td valign="top"><a href="#struct_hd_identity_test_-0">struct_hd_identity_test_/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_bare_item-1">to_bare_item/1*</a></td><td>Convert an Erlang term to an SF <code>bare_item</code>.</td></tr><tr><td valign="top"><a href="#to_dictionary-1">to_dictionary/1</a></td><td>Convert a map to a dictionary.</td></tr><tr><td valign="top"><a href="#to_dictionary-2">to_dictionary/2*</a></td><td></td></tr><tr><td valign="top"><a href="#to_dictionary_depth_test-0">to_dictionary_depth_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_dictionary_test-0">to_dictionary_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_inner_item-1">to_inner_item/1*</a></td><td>Convert an Erlang term to an SF <code>item</code>.</td></tr><tr><td valign="top"><a href="#to_inner_list-1">to_inner_list/1*</a></td><td>Convert an inner list to an SF term.</td></tr><tr><td valign="top"><a href="#to_inner_list-2">to_inner_list/2*</a></td><td></td></tr><tr><td valign="top"><a href="#to_inner_list-3">to_inner_list/3*</a></td><td></td></tr><tr><td valign="top"><a href="#to_item-1">to_item/1</a></td><td>Convert an item to a dictionary.</td></tr><tr><td valign="top"><a href="#to_item-2">to_item/2</a></td><td></td></tr><tr><td valign="top"><a href="#to_item_or_inner_list-1">to_item_or_inner_list/1*</a></td><td>Convert an Erlang term to an SF <code>item</code> or <code>inner_list</code>.</td></tr><tr><td valign="top"><a href="#to_item_test-0">to_item_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_list-1">to_list/1</a></td><td>Convert a list to an SF term.</td></tr><tr><td valign="top"><a href="#to_list-2">to_list/2*</a></td><td></td></tr><tr><td valign="top"><a href="#to_list_depth_test-0">to_list_depth_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_list_test-0">to_list_test/0*</a></td><td></td></tr><tr><td valign="top"><a href="#to_param-1">to_param/1*</a></td><td>Convert an Erlang term to an SF <code>parameter</code>.</td></tr><tr><td valign="top"><a href="#trim_ws-1">trim_ws/1*</a></td><td></td></tr><tr><td valign="top"><a href="#trim_ws_end-2">trim_ws_end/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="bare_item-1"></a>

### bare_item/1 ###

`bare_item(Integer) -> any()`

<a name="dictionary-1"></a>

### dictionary/1 ###

<pre><code>
dictionary(Map::#{binary() =&gt; <a href="#type-sh_item">sh_item()</a> | <a href="#type-sh_inner_list">sh_inner_list()</a>} | <a href="#type-sh_dictionary">sh_dictionary()</a>) -&gt; iolist()
</code></pre>
<br />

<a name="e2t-1"></a>

### e2t/1 * ###

`e2t(Dict) -> any()`

<a name="e2tb-1"></a>

### e2tb/1 * ###

`e2tb(V) -> any()`

<a name="e2tp-1"></a>

### e2tp/1 * ###

`e2tp(Params) -> any()`

<a name="escape_string-2"></a>

### escape_string/2 * ###

`escape_string(X1, Acc) -> any()`

<a name="exp_div-1"></a>

### exp_div/1 * ###

`exp_div(N) -> any()`

<a name="expected_to_term-1"></a>

### expected_to_term/1 * ###

`expected_to_term(Dict) -> any()`

<a name="from_bare_item-1"></a>

### from_bare_item/1 ###

`from_bare_item(BareItem) -> any()`

Convert an SF `bare_item` to an Erlang term.

<a name="inner_list-1"></a>

### inner_list/1 * ###

`inner_list(X1) -> any()`

<a name="item-1"></a>

### item/1 ###

<pre><code>
item(X1::<a href="#type-sh_item">sh_item()</a>) -&gt; iolist()
</code></pre>
<br />

<a name="item_or_inner_list-1"></a>

### item_or_inner_list/1 * ###

`item_or_inner_list(Value) -> any()`

<a name="key_to_binary-1"></a>

### key_to_binary/1 * ###

`key_to_binary(Key) -> any()`

Convert an Erlang term to a binary key.

<a name="list-1"></a>

### list/1 ###

<pre><code>
list(List::<a href="#type-sh_list">sh_list()</a>) -&gt; iolist()
</code></pre>
<br />

<a name="params-1"></a>

### params/1 * ###

`params(Params) -> any()`

<a name="parse_bare_item-1"></a>

### parse_bare_item/1 ###

`parse_bare_item(X1) -> any()`

Parse an integer or decimal.

<a name="parse_before_param-2"></a>

### parse_before_param/2 * ###

`parse_before_param(X1, Acc) -> any()`

<a name="parse_binary-2"></a>

### parse_binary/2 * ###

`parse_binary(X1, Acc) -> any()`

Parse a byte sequence binary.

<a name="parse_decimal-5"></a>

### parse_decimal/5 * ###

`parse_decimal(R, L1, L2, IntAcc, FracAcc) -> any()`

Parse a decimal binary.

<a name="parse_dict_before_member-2"></a>

### parse_dict_before_member/2 * ###

`parse_dict_before_member(X1, Acc) -> any()`

Parse a binary SF dictionary before a member.

<a name="parse_dict_before_sep-2"></a>

### parse_dict_before_sep/2 * ###

`parse_dict_before_sep(X1, Acc) -> any()`

Parse a binary SF dictionary before a separator.

<a name="parse_dict_key-3"></a>

### parse_dict_key/3 * ###

`parse_dict_key(R, Acc, K) -> any()`

<a name="parse_dictionary-1"></a>

### parse_dictionary/1 ###

<pre><code>
parse_dictionary(X1::binary()) -&gt; <a href="#type-sh_dictionary">sh_dictionary()</a>
</code></pre>
<br />

Parse a binary SF dictionary.

<a name="parse_inner_list-2"></a>

### parse_inner_list/2 * ###

`parse_inner_list(R0, Acc) -> any()`

<a name="parse_item-1"></a>

### parse_item/1 ###

<pre><code>
parse_item(Bin::binary()) -&gt; <a href="#type-sh_item">sh_item()</a>
</code></pre>
<br />

Parse a binary SF item to an SF `item`.

<a name="parse_item1-1"></a>

### parse_item1/1 * ###

`parse_item1(Bin) -> any()`

<a name="parse_list-1"></a>

### parse_list/1 ###

<pre><code>
parse_list(Bin::binary()) -&gt; <a href="#type-sh_list">sh_list()</a>
</code></pre>
<br />

Parse a binary SF list.

<a name="parse_list_before_member-2"></a>

### parse_list_before_member/2 * ###

`parse_list_before_member(R, Acc) -> any()`

Parse a binary SF list before a member.

<a name="parse_list_before_sep-2"></a>

### parse_list_before_sep/2 * ###

`parse_list_before_sep(X1, Acc) -> any()`

Parse a binary SF list before a separator.

<a name="parse_list_member-2"></a>

### parse_list_member/2 * ###

`parse_list_member(R0, Acc) -> any()`

Parse a binary SF list before a member.

<a name="parse_number-3"></a>

### parse_number/3 * ###

`parse_number(R, L, Acc) -> any()`

Parse an integer or decimal binary.

<a name="parse_param-3"></a>

### parse_param/3 * ###

`parse_param(R, Acc, K) -> any()`

<a name="parse_string-2"></a>

### parse_string/2 * ###

`parse_string(X1, Acc) -> any()`

Parse a string binary.

<a name="parse_struct_hd_test_-0"></a>

### parse_struct_hd_test_/0 * ###

`parse_struct_hd_test_() -> any()`

<a name="parse_token-2"></a>

### parse_token/2 * ###

`parse_token(R, Acc) -> any()`

Parse a token binary.

<a name="raw_to_binary-1"></a>

### raw_to_binary/1 * ###

`raw_to_binary(RawList) -> any()`

<a name="struct_hd_identity_test_-0"></a>

### struct_hd_identity_test_/0 * ###

`struct_hd_identity_test_() -> any()`

<a name="to_bare_item-1"></a>

### to_bare_item/1 * ###

`to_bare_item(BareItem) -> any()`

Convert an Erlang term to an SF `bare_item`.

<a name="to_dictionary-1"></a>

### to_dictionary/1 ###

`to_dictionary(Map) -> any()`

Convert a map to a dictionary.

<a name="to_dictionary-2"></a>

### to_dictionary/2 * ###

`to_dictionary(Dict, Rest) -> any()`

<a name="to_dictionary_depth_test-0"></a>

### to_dictionary_depth_test/0 * ###

`to_dictionary_depth_test() -> any()`

<a name="to_dictionary_test-0"></a>

### to_dictionary_test/0 * ###

`to_dictionary_test() -> any()`

<a name="to_inner_item-1"></a>

### to_inner_item/1 * ###

`to_inner_item(Item) -> any()`

Convert an Erlang term to an SF `item`.

<a name="to_inner_list-1"></a>

### to_inner_list/1 * ###

`to_inner_list(Inner) -> any()`

Convert an inner list to an SF term.

<a name="to_inner_list-2"></a>

### to_inner_list/2 * ###

`to_inner_list(Inner, Params) -> any()`

<a name="to_inner_list-3"></a>

### to_inner_list/3 * ###

`to_inner_list(Inner, Rest, Params) -> any()`

<a name="to_item-1"></a>

### to_item/1 ###

`to_item(Item) -> any()`

Convert an item to a dictionary.

<a name="to_item-2"></a>

### to_item/2 ###

`to_item(Item, Params) -> any()`

<a name="to_item_or_inner_list-1"></a>

### to_item_or_inner_list/1 * ###

`to_item_or_inner_list(ItemOrInner) -> any()`

Convert an Erlang term to an SF `item` or `inner_list`.

<a name="to_item_test-0"></a>

### to_item_test/0 * ###

`to_item_test() -> any()`

<a name="to_list-1"></a>

### to_list/1 ###

`to_list(List) -> any()`

Convert a list to an SF term.

<a name="to_list-2"></a>

### to_list/2 * ###

`to_list(Acc, Rest) -> any()`

<a name="to_list_depth_test-0"></a>

### to_list_depth_test/0 * ###

`to_list_depth_test() -> any()`

<a name="to_list_test-0"></a>

### to_list_test/0 * ###

`to_list_test() -> any()`

<a name="to_param-1"></a>

### to_param/1 * ###

`to_param(X1) -> any()`

Convert an Erlang term to an SF `parameter`.

<a name="trim_ws-1"></a>

### trim_ws/1 * ###

`trim_ws(R) -> any()`

<a name="trim_ws_end-2"></a>

### trim_ws_end/2 * ###

`trim_ws_end(Value, N) -> any()`


--- END OF FILE: docs/resources/source-code/hb_structured_fields.md ---

--- START OF FILE: docs/resources/source-code/hb_sup.md ---
# [Module hb_sup.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_sup.erl)




__Behaviours:__ [`supervisor`](supervisor.md).

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_link-0">start_link/0</a></td><td></td></tr><tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td></td></tr><tr><td valign="top"><a href="#store_children-1">store_children/1*</a></td><td>Generate a child spec for stores in the given Opts.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="init-1"></a>

### init/1 ###

`init(Opts) -> any()`

<a name="start_link-0"></a>

### start_link/0 ###

`start_link() -> any()`

<a name="start_link-1"></a>

### start_link/1 ###

`start_link(Opts) -> any()`

<a name="store_children-1"></a>

### store_children/1 * ###

`store_children(Store) -> any()`

Generate a child spec for stores in the given Opts.


--- END OF FILE: docs/resources/source-code/hb_sup.md ---

--- START OF FILE: docs/resources/source-code/hb_test_utils.md ---
# [Module hb_test_utils.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_test_utils.erl)




Simple utilities for testing HyperBEAM.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#run-4">run/4</a></td><td></td></tr><tr><td valign="top"><a href="#satisfies_requirements-1">satisfies_requirements/1*</a></td><td>Determine if the environment satisfies the given test requirements.</td></tr><tr><td valign="top"><a href="#suite_with_opts-2">suite_with_opts/2</a></td><td>Run each test in a suite with each set of options.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="run-4"></a>

### run/4 ###

`run(Name, OptsName, Suite, OptsList) -> any()`

<a name="satisfies_requirements-1"></a>

### satisfies_requirements/1 * ###

`satisfies_requirements(Requirements) -> any()`

Determine if the environment satisfies the given test requirements.
Requirements is a list of atoms, each corresponding to a module that must
return true if it exposes an `enabled/0` function.

<a name="suite_with_opts-2"></a>

### suite_with_opts/2 ###

`suite_with_opts(Suite, OptsList) -> any()`

Run each test in a suite with each set of options. Start and reset
the store(s) for each test. Expects suites to be a list of tuples with
the test name, description, and test function.
The list of `Opts` should contain maps with the `name` and `opts` keys.
Each element may also contain a `skip` key with a list of test names to skip.
They can also contain a `desc` key with a description of the options.


--- END OF FILE: docs/resources/source-code/hb_test_utils.md ---

--- START OF FILE: docs/resources/source-code/hb_tracer.md ---
# [Module hb_tracer.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_tracer.erl)




A module for tracing the flow of requests through the system.

<a name="description"></a>

## Description ##
This allows for tracking the lifecycle of a request from HTTP receipt through processing and response.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#checkmark_emoji-0">checkmark_emoji/0*</a></td><td></td></tr><tr><td valign="top"><a href="#failure_emoji-0">failure_emoji/0*</a></td><td></td></tr><tr><td valign="top"><a href="#format_error_trace-1">format_error_trace/1</a></td><td>Format a trace for error in a user-friendly emoji oriented output.</td></tr><tr><td valign="top"><a href="#get_trace-1">get_trace/1</a></td><td>Exports the complete queue of events.</td></tr><tr><td valign="top"><a href="#record_step-2">record_step/2</a></td><td>Register a new step into a tracer.</td></tr><tr><td valign="top"><a href="#stage_to_emoji-1">stage_to_emoji/1*</a></td><td></td></tr><tr><td valign="top"><a href="#start_trace-0">start_trace/0</a></td><td>Start a new tracer acting as queue of events registered.</td></tr><tr><td valign="top"><a href="#trace_loop-1">trace_loop/1*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="checkmark_emoji-0"></a>

### checkmark_emoji/0 * ###

`checkmark_emoji() -> any()`

<a name="failure_emoji-0"></a>

### failure_emoji/0 * ###

`failure_emoji() -> any()`

<a name="format_error_trace-1"></a>

### format_error_trace/1 ###

`format_error_trace(Trace) -> any()`

Format a trace for error in a user-friendly emoji oriented output

<a name="get_trace-1"></a>

### get_trace/1 ###

`get_trace(TracePID) -> any()`

Exports the complete queue of events

<a name="record_step-2"></a>

### record_step/2 ###

`record_step(TracePID, Step) -> any()`

Register a new step into a tracer

<a name="stage_to_emoji-1"></a>

### stage_to_emoji/1 * ###

`stage_to_emoji(Stage) -> any()`

<a name="start_trace-0"></a>

### start_trace/0 ###

`start_trace() -> any()`

Start a new tracer acting as queue of events registered.

<a name="trace_loop-1"></a>

### trace_loop/1 * ###

`trace_loop(Trace) -> any()`


--- END OF FILE: docs/resources/source-code/hb_tracer.md ---

--- START OF FILE: docs/resources/source-code/hb_util.md ---
# [Module hb_util.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_util.erl)




A collection of utility functions for building with HyperBEAM.

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_commas-1">add_commas/1*</a></td><td></td></tr><tr><td valign="top"><a href="#all_hb_modules-0">all_hb_modules/0</a></td><td>Get all loaded modules that are loaded and are part of HyperBEAM.</td></tr><tr><td valign="top"><a href="#atom-1">atom/1</a></td><td>Coerce a string to an atom.</td></tr><tr><td valign="top"><a href="#bin-1">bin/1</a></td><td>Coerce a value to a binary.</td></tr><tr><td valign="top"><a href="#count-2">count/2</a></td><td></td></tr><tr><td valign="top"><a href="#debug_fmt-1">debug_fmt/1</a></td><td>Convert a term to a string for debugging print purposes.</td></tr><tr><td valign="top"><a href="#debug_fmt-2">debug_fmt/2</a></td><td></td></tr><tr><td valign="top"><a href="#debug_print-4">debug_print/4</a></td><td>Print a message to the standard error stream, prefixed by the amount
of time that has elapsed since the last call to this function.</td></tr><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Try to decode a URL safe base64 into a binary or throw an error when
invalid.</td></tr><tr><td valign="top"><a href="#deep_merge-2">deep_merge/2</a></td><td>Deep merge two maps, recursively merging nested maps.</td></tr><tr><td valign="top"><a href="#do_debug_fmt-2">do_debug_fmt/2*</a></td><td></td></tr><tr><td valign="top"><a href="#do_to_lines-1">do_to_lines/1*</a></td><td></td></tr><tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Encode a binary to URL safe base64 binary string.</td></tr><tr><td valign="top"><a href="#eunit_print-2">eunit_print/2</a></td><td>Format and print an indented string to standard error.</td></tr><tr><td valign="top"><a href="#find_value-2">find_value/2</a></td><td>Find the value associated with a key in parsed a JSON structure list.</td></tr><tr><td valign="top"><a href="#find_value-3">find_value/3</a></td><td></td></tr><tr><td valign="top"><a href="#float-1">float/1</a></td><td>Coerce a string to a float.</td></tr><tr><td valign="top"><a href="#format_address-2">format_address/2*</a></td><td>If the user attempts to print a wallet, format it as an address.</td></tr><tr><td valign="top"><a href="#format_binary-1">format_binary/1</a></td><td>Format a binary as a short string suitable for printing.</td></tr><tr><td valign="top"><a href="#format_debug_trace-3">format_debug_trace/3*</a></td><td>Generate the appropriate level of trace for a given call.</td></tr><tr><td valign="top"><a href="#format_indented-2">format_indented/2</a></td><td>Format a string with an indentation level.</td></tr><tr><td valign="top"><a href="#format_indented-3">format_indented/3</a></td><td></td></tr><tr><td valign="top"><a href="#format_maybe_multiline-2">format_maybe_multiline/2</a></td><td>Format a map as either a single line or a multi-line string depending
on the value of the <code>debug_print_map_line_threshold</code> runtime option.</td></tr><tr><td valign="top"><a href="#format_trace-1">format_trace/1</a></td><td>Format a stack trace as a list of strings, one for each stack frame.</td></tr><tr><td valign="top"><a href="#format_trace-2">format_trace/2*</a></td><td></td></tr><tr><td valign="top"><a href="#format_trace_short-1">format_trace_short/1</a></td><td>Format a trace to a short string.</td></tr><tr><td valign="top"><a href="#format_trace_short-4">format_trace_short/4*</a></td><td></td></tr><tr><td valign="top"><a href="#format_tuple-2">format_tuple/2*</a></td><td>Helper function to format tuples with arity greater than 2.</td></tr><tr><td valign="top"><a href="#get_trace-0">get_trace/0*</a></td><td>Get the trace of the current process.</td></tr><tr><td valign="top"><a href="#hd-1">hd/1</a></td><td>Get the first element (the lowest integer key >= 1) of a numbered map.</td></tr><tr><td valign="top"><a href="#hd-2">hd/2</a></td><td></td></tr><tr><td valign="top"><a href="#hd-3">hd/3</a></td><td></td></tr><tr><td valign="top"><a href="#hd-5">hd/5*</a></td><td></td></tr><tr><td valign="top"><a href="#human_id-1">human_id/1</a></td><td>Convert a native binary ID to a human readable ID.</td></tr><tr><td valign="top"><a href="#human_int-1">human_int/1</a></td><td>Add <code>,</code> characters to a number every 3 digits to make it human readable.</td></tr><tr><td valign="top"><a href="#id-1">id/1</a></td><td>Return the human-readable form of an ID of a message when given either
a message explicitly, raw encoded ID, or an Erlang Arweave <code>tx</code> record.</td></tr><tr><td valign="top"><a href="#id-2">id/2</a></td><td></td></tr><tr><td valign="top"><a href="#int-1">int/1</a></td><td>Coerce a string to an integer.</td></tr><tr><td valign="top"><a href="#is_hb_module-1">is_hb_module/1</a></td><td>Is the given module part of HyperBEAM?.</td></tr><tr><td valign="top"><a href="#is_hb_module-2">is_hb_module/2</a></td><td></td></tr><tr><td valign="top"><a href="#is_human_binary-1">is_human_binary/1*</a></td><td>Determine whether a binary is human-readable.</td></tr><tr><td valign="top"><a href="#is_ordered_list-1">is_ordered_list/1</a></td><td>Determine if the message given is an ordered list, starting from 1.</td></tr><tr><td valign="top"><a href="#is_ordered_list-2">is_ordered_list/2*</a></td><td></td></tr><tr><td valign="top"><a href="#is_string_list-1">is_string_list/1</a></td><td>Is the given term a string list?.</td></tr><tr><td valign="top"><a href="#key_to_atom-2">key_to_atom/2</a></td><td>Convert keys in a map to atoms, lowering <code>-</code> to <code>_</code>.</td></tr><tr><td valign="top"><a href="#list-1">list/1</a></td><td>Coerce a value to a list.</td></tr><tr><td valign="top"><a href="#list_to_numbered_map-1">list_to_numbered_map/1</a></td><td>Convert a list of elements to a map with numbered keys.</td></tr><tr><td valign="top"><a href="#maybe_throw-2">maybe_throw/2</a></td><td>Throw an exception if the Opts map has an <code>error_strategy</code> key with the
value <code>throw</code>.</td></tr><tr><td valign="top"><a href="#mean-1">mean/1</a></td><td></td></tr><tr><td valign="top"><a href="#message_to_ordered_list-1">message_to_ordered_list/1</a></td><td>Take a message with numbered keys and convert it to a list of tuples
with the associated key as an integer and a value.</td></tr><tr><td valign="top"><a href="#message_to_ordered_list-2">message_to_ordered_list/2</a></td><td></td></tr><tr><td valign="top"><a href="#message_to_ordered_list-4">message_to_ordered_list/4*</a></td><td></td></tr><tr><td valign="top"><a href="#native_id-1">native_id/1</a></td><td>Convert a human readable ID to a native binary ID.</td></tr><tr><td valign="top"><a href="#normalize_trace-1">normalize_trace/1*</a></td><td>Remove all calls from this module from the top of a trace.</td></tr><tr><td valign="top"><a href="#number-1">number/1</a></td><td>Label a list of elements with a number.</td></tr><tr><td valign="top"><a href="#ok-1">ok/1</a></td><td>Unwrap a tuple of the form <code>{ok, Value}</code>, or throw/return, depending on
the value of the <code>error_strategy</code> option.</td></tr><tr><td valign="top"><a href="#ok-2">ok/2</a></td><td></td></tr><tr><td valign="top"><a href="#pick_weighted-2">pick_weighted/2*</a></td><td></td></tr><tr><td valign="top"><a href="#print_trace-3">print_trace/3*</a></td><td></td></tr><tr><td valign="top"><a href="#print_trace-4">print_trace/4</a></td><td>Print the trace of the current stack, up to the first non-hyperbeam
module.</td></tr><tr><td valign="top"><a href="#print_trace_short-4">print_trace_short/4</a></td><td>Print a trace to the standard error stream.</td></tr><tr><td valign="top"><a href="#remove_common-2">remove_common/2</a></td><td>Remove the common prefix from two strings, returning the remainder of the
first string.</td></tr><tr><td valign="top"><a href="#remove_trailing_noise-1">remove_trailing_noise/1*</a></td><td></td></tr><tr><td valign="top"><a href="#remove_trailing_noise-2">remove_trailing_noise/2</a></td><td></td></tr><tr><td valign="top"><a href="#safe_decode-1">safe_decode/1</a></td><td>Safely decode a URL safe base64 into a binary returning an ok or error
tuple.</td></tr><tr><td valign="top"><a href="#safe_encode-1">safe_encode/1</a></td><td>Safely encode a binary to URL safe base64.</td></tr><tr><td valign="top"><a href="#short_id-1">short_id/1</a></td><td>Return a short ID for the different types of IDs used in AO-Core.</td></tr><tr><td valign="top"><a href="#shuffle-1">shuffle/1*</a></td><td>Shuffle a list.</td></tr><tr><td valign="top"><a href="#stddev-1">stddev/1</a></td><td></td></tr><tr><td valign="top"><a href="#to_hex-1">to_hex/1</a></td><td>Convert a binary to a hex string.</td></tr><tr><td valign="top"><a href="#to_lines-1">to_lines/1*</a></td><td></td></tr><tr><td valign="top"><a href="#to_lower-1">to_lower/1</a></td><td>Convert a binary to a lowercase.</td></tr><tr><td valign="top"><a href="#to_sorted_keys-1">to_sorted_keys/1</a></td><td>Given a map or KVList, return a deterministically ordered list of its keys.</td></tr><tr><td valign="top"><a href="#to_sorted_list-1">to_sorted_list/1</a></td><td>Given a map or KVList, return a deterministically sorted list of its
key-value pairs.</td></tr><tr><td valign="top"><a href="#trace_macro_helper-5">trace_macro_helper/5</a></td><td>Utility function to help macro <code>?trace/0</code> remove the first frame of the
stack trace.</td></tr><tr><td valign="top"><a href="#until-1">until/1</a></td><td>Utility function to wait for a condition to be true.</td></tr><tr><td valign="top"><a href="#until-2">until/2</a></td><td></td></tr><tr><td valign="top"><a href="#until-3">until/3</a></td><td></td></tr><tr><td valign="top"><a href="#variance-1">variance/1</a></td><td></td></tr><tr><td valign="top"><a href="#weighted_random-1">weighted_random/1</a></td><td>Return a random element from a list, weighted by the values in the list.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_commas-1"></a>

### add_commas/1 * ###

`add_commas(Rest) -> any()`

<a name="all_hb_modules-0"></a>

### all_hb_modules/0 ###

`all_hb_modules() -> any()`

Get all loaded modules that are loaded and are part of HyperBEAM.

<a name="atom-1"></a>

### atom/1 ###

`atom(Str) -> any()`

Coerce a string to an atom.

<a name="bin-1"></a>

### bin/1 ###

`bin(Value) -> any()`

Coerce a value to a binary.

<a name="count-2"></a>

### count/2 ###

`count(Item, List) -> any()`

<a name="debug_fmt-1"></a>

### debug_fmt/1 ###

`debug_fmt(X) -> any()`

Convert a term to a string for debugging print purposes.

<a name="debug_fmt-2"></a>

### debug_fmt/2 ###

`debug_fmt(X, Indent) -> any()`

<a name="debug_print-4"></a>

### debug_print/4 ###

`debug_print(X, Mod, Func, LineNum) -> any()`

Print a message to the standard error stream, prefixed by the amount
of time that has elapsed since the last call to this function.

<a name="decode-1"></a>

### decode/1 ###

`decode(Input) -> any()`

Try to decode a URL safe base64 into a binary or throw an error when
invalid.

<a name="deep_merge-2"></a>

### deep_merge/2 ###

`deep_merge(Map1, Map2) -> any()`

Deep merge two maps, recursively merging nested maps.

<a name="do_debug_fmt-2"></a>

### do_debug_fmt/2 * ###

`do_debug_fmt(Wallet, Indent) -> any()`

<a name="do_to_lines-1"></a>

### do_to_lines/1 * ###

`do_to_lines(In) -> any()`

<a name="encode-1"></a>

### encode/1 ###

`encode(Bin) -> any()`

Encode a binary to URL safe base64 binary string.

<a name="eunit_print-2"></a>

### eunit_print/2 ###

`eunit_print(FmtStr, FmtArgs) -> any()`

Format and print an indented string to standard error.

<a name="find_value-2"></a>

### find_value/2 ###

`find_value(Key, List) -> any()`

Find the value associated with a key in parsed a JSON structure list.

<a name="find_value-3"></a>

### find_value/3 ###

`find_value(Key, Map, Default) -> any()`

<a name="float-1"></a>

### float/1 ###

`float(Str) -> any()`

Coerce a string to a float.

<a name="format_address-2"></a>

### format_address/2 * ###

`format_address(Wallet, Indent) -> any()`

If the user attempts to print a wallet, format it as an address.

<a name="format_binary-1"></a>

### format_binary/1 ###

`format_binary(Bin) -> any()`

Format a binary as a short string suitable for printing.

<a name="format_debug_trace-3"></a>

### format_debug_trace/3 * ###

`format_debug_trace(Mod, Func, Line) -> any()`

Generate the appropriate level of trace for a given call.

<a name="format_indented-2"></a>

### format_indented/2 ###

`format_indented(Str, Indent) -> any()`

Format a string with an indentation level.

<a name="format_indented-3"></a>

### format_indented/3 ###

`format_indented(RawStr, Fmt, Ind) -> any()`

<a name="format_maybe_multiline-2"></a>

### format_maybe_multiline/2 ###

`format_maybe_multiline(X, Indent) -> any()`

Format a map as either a single line or a multi-line string depending
on the value of the `debug_print_map_line_threshold` runtime option.

<a name="format_trace-1"></a>

### format_trace/1 ###

`format_trace(Stack) -> any()`

Format a stack trace as a list of strings, one for each stack frame.
Each stack frame is formatted if it matches the `stack_print_prefixes`
option. At the first frame that does not match a prefix in the
`stack_print_prefixes` option, the rest of the stack is not formatted.

<a name="format_trace-2"></a>

### format_trace/2 * ###

`format_trace(Rest, Prefixes) -> any()`

<a name="format_trace_short-1"></a>

### format_trace_short/1 ###

`format_trace_short(Trace) -> any()`

Format a trace to a short string.

<a name="format_trace_short-4"></a>

### format_trace_short/4 * ###

`format_trace_short(Max, Latch, Trace, Prefixes) -> any()`

<a name="format_tuple-2"></a>

### format_tuple/2 * ###

`format_tuple(Tuple, Indent) -> any()`

Helper function to format tuples with arity greater than 2.

<a name="get_trace-0"></a>

### get_trace/0 * ###

`get_trace() -> any()`

Get the trace of the current process.

<a name="hd-1"></a>

### hd/1 ###

`hd(Message) -> any()`

Get the first element (the lowest integer key >= 1) of a numbered map.
Optionally, it takes a specifier of whether to return the key or the value,
as well as a standard map of HyperBEAM runtime options.

<a name="hd-2"></a>

### hd/2 ###

`hd(Message, ReturnType) -> any()`

<a name="hd-3"></a>

### hd/3 ###

`hd(Message, ReturnType, Opts) -> any()`

<a name="hd-5"></a>

### hd/5 * ###

`hd(Map, Rest, Index, ReturnType, Opts) -> any()`

<a name="human_id-1"></a>

### human_id/1 ###

`human_id(Bin) -> any()`

Convert a native binary ID to a human readable ID. If the ID is already
a human readable ID, it is returned as is.

<a name="human_int-1"></a>

### human_int/1 ###

`human_int(Int) -> any()`

Add `,` characters to a number every 3 digits to make it human readable.

<a name="id-1"></a>

### id/1 ###

`id(Item) -> any()`

Return the human-readable form of an ID of a message when given either
a message explicitly, raw encoded ID, or an Erlang Arweave `tx` record.

<a name="id-2"></a>

### id/2 ###

`id(TX, Type) -> any()`

<a name="int-1"></a>

### int/1 ###

`int(Str) -> any()`

Coerce a string to an integer.

<a name="is_hb_module-1"></a>

### is_hb_module/1 ###

`is_hb_module(Atom) -> any()`

Is the given module part of HyperBEAM?

<a name="is_hb_module-2"></a>

### is_hb_module/2 ###

`is_hb_module(Atom, Prefixes) -> any()`

<a name="is_human_binary-1"></a>

### is_human_binary/1 * ###

`is_human_binary(Bin) -> any()`

Determine whether a binary is human-readable.

<a name="is_ordered_list-1"></a>

### is_ordered_list/1 ###

`is_ordered_list(Msg) -> any()`

Determine if the message given is an ordered list, starting from 1.

<a name="is_ordered_list-2"></a>

### is_ordered_list/2 * ###

`is_ordered_list(N, Msg) -> any()`

<a name="is_string_list-1"></a>

### is_string_list/1 ###

`is_string_list(MaybeString) -> any()`

Is the given term a string list?

<a name="key_to_atom-2"></a>

### key_to_atom/2 ###

`key_to_atom(Key, Mode) -> any()`

Convert keys in a map to atoms, lowering `-` to `_`.

<a name="list-1"></a>

### list/1 ###

`list(Value) -> any()`

Coerce a value to a list.

<a name="list_to_numbered_map-1"></a>

### list_to_numbered_map/1 ###

`list_to_numbered_map(List) -> any()`

Convert a list of elements to a map with numbered keys.

<a name="maybe_throw-2"></a>

### maybe_throw/2 ###

`maybe_throw(Val, Opts) -> any()`

Throw an exception if the Opts map has an `error_strategy` key with the
value `throw`. Otherwise, return the value.

<a name="mean-1"></a>

### mean/1 ###

`mean(List) -> any()`

<a name="message_to_ordered_list-1"></a>

### message_to_ordered_list/1 ###

`message_to_ordered_list(Message) -> any()`

Take a message with numbered keys and convert it to a list of tuples
with the associated key as an integer and a value. Optionally, it takes a
standard map of HyperBEAM runtime options.

<a name="message_to_ordered_list-2"></a>

### message_to_ordered_list/2 ###

`message_to_ordered_list(Message, Opts) -> any()`

<a name="message_to_ordered_list-4"></a>

### message_to_ordered_list/4 * ###

`message_to_ordered_list(Message, Keys, Key, Opts) -> any()`

<a name="native_id-1"></a>

### native_id/1 ###

`native_id(Bin) -> any()`

Convert a human readable ID to a native binary ID. If the ID is already
a native binary ID, it is returned as is.

<a name="normalize_trace-1"></a>

### normalize_trace/1 * ###

`normalize_trace(Rest) -> any()`

Remove all calls from this module from the top of a trace.

<a name="number-1"></a>

### number/1 ###

`number(List) -> any()`

Label a list of elements with a number.

<a name="ok-1"></a>

### ok/1 ###

`ok(Value) -> any()`

Unwrap a tuple of the form `{ok, Value}`, or throw/return, depending on
the value of the `error_strategy` option.

<a name="ok-2"></a>

### ok/2 ###

`ok(Other, Opts) -> any()`

<a name="pick_weighted-2"></a>

### pick_weighted/2 * ###

`pick_weighted(Rest, Remaining) -> any()`

<a name="print_trace-3"></a>

### print_trace/3 * ###

`print_trace(Stack, Label, CallerInfo) -> any()`

<a name="print_trace-4"></a>

### print_trace/4 ###

`print_trace(Stack, CallMod, CallFunc, CallLine) -> any()`

Print the trace of the current stack, up to the first non-hyperbeam
module. Prints each stack frame on a new line, until it finds a frame that
does not start with a prefix in the `stack_print_prefixes` hb_opts.
Optionally, you may call this function with a custom label and caller info,
which will be used instead of the default.

<a name="print_trace_short-4"></a>

### print_trace_short/4 ###

`print_trace_short(Trace, Mod, Func, Line) -> any()`

Print a trace to the standard error stream.

<a name="remove_common-2"></a>

### remove_common/2 ###

`remove_common(MainStr, SubStr) -> any()`

Remove the common prefix from two strings, returning the remainder of the
first string. This function also coerces lists to binaries where appropriate,
returning the type of the first argument.

<a name="remove_trailing_noise-1"></a>

### remove_trailing_noise/1 * ###

`remove_trailing_noise(Str) -> any()`

<a name="remove_trailing_noise-2"></a>

### remove_trailing_noise/2 ###

`remove_trailing_noise(Str, Noise) -> any()`

<a name="safe_decode-1"></a>

### safe_decode/1 ###

`safe_decode(E) -> any()`

Safely decode a URL safe base64 into a binary returning an ok or error
tuple.

<a name="safe_encode-1"></a>

### safe_encode/1 ###

`safe_encode(Bin) -> any()`

Safely encode a binary to URL safe base64.

<a name="short_id-1"></a>

### short_id/1 ###

`short_id(Bin) -> any()`

Return a short ID for the different types of IDs used in AO-Core.

<a name="shuffle-1"></a>

### shuffle/1 * ###

`shuffle(List) -> any()`

Shuffle a list.

<a name="stddev-1"></a>

### stddev/1 ###

`stddev(List) -> any()`

<a name="to_hex-1"></a>

### to_hex/1 ###

`to_hex(Bin) -> any()`

Convert a binary to a hex string. Do not use this for anything other than
generating a lower-case, non-special character id. It should not become part of
the core protocol. We use b64u for efficient encoding.

<a name="to_lines-1"></a>

### to_lines/1 * ###

`to_lines(Elems) -> any()`

<a name="to_lower-1"></a>

### to_lower/1 ###

`to_lower(Str) -> any()`

Convert a binary to a lowercase.

<a name="to_sorted_keys-1"></a>

### to_sorted_keys/1 ###

`to_sorted_keys(Msg) -> any()`

Given a map or KVList, return a deterministically ordered list of its keys.

<a name="to_sorted_list-1"></a>

### to_sorted_list/1 ###

`to_sorted_list(Msg) -> any()`

Given a map or KVList, return a deterministically sorted list of its
key-value pairs.

<a name="trace_macro_helper-5"></a>

### trace_macro_helper/5 ###

`trace_macro_helper(Fun, X2, Mod, Func, Line) -> any()`

Utility function to help macro `?trace/0` remove the first frame of the
stack trace.

<a name="until-1"></a>

### until/1 ###

`until(Condition) -> any()`

Utility function to wait for a condition to be true. Optionally,
you can pass a function that will be called with the current count of
iterations, returning an integer that will be added to the count. Once the
condition is true, the function will return the count.

<a name="until-2"></a>

### until/2 ###

`until(Condition, Count) -> any()`

<a name="until-3"></a>

### until/3 ###

`until(Condition, Fun, Count) -> any()`

<a name="variance-1"></a>

### variance/1 ###

`variance(List) -> any()`

<a name="weighted_random-1"></a>

### weighted_random/1 ###

`weighted_random(List) -> any()`

Return a random element from a list, weighted by the values in the list.


--- END OF FILE: docs/resources/source-code/hb_util.md ---

--- START OF FILE: docs/resources/source-code/hb_volume.md ---
# [Module hb_volume.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb_volume.erl)




<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#change_node_store-2">change_node_store/2</a></td><td></td></tr><tr><td valign="top"><a href="#check_for_device-1">check_for_device/1</a></td><td></td></tr><tr><td valign="top"><a href="#create_actual_partition-2">create_actual_partition/2*</a></td><td></td></tr><tr><td valign="top"><a href="#create_mount_info-3">create_mount_info/3*</a></td><td></td></tr><tr><td valign="top"><a href="#create_partition-2">create_partition/2</a></td><td></td></tr><tr><td valign="top"><a href="#format_disk-2">format_disk/2</a></td><td></td></tr><tr><td valign="top"><a href="#get_partition_info-1">get_partition_info/1*</a></td><td></td></tr><tr><td valign="top"><a href="#list_partitions-0">list_partitions/0</a></td><td></td></tr><tr><td valign="top"><a href="#mount_disk-4">mount_disk/4</a></td><td></td></tr><tr><td valign="top"><a href="#mount_opened_volume-3">mount_opened_volume/3*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_disk_info-2">parse_disk_info/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_disk_line-2">parse_disk_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_disk_model_line-2">parse_disk_model_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_disk_units_line-2">parse_disk_units_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_io_size_line-2">parse_io_size_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#parse_sector_size_line-2">parse_sector_size_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#process_disk_line-2">process_disk_line/2*</a></td><td></td></tr><tr><td valign="top"><a href="#update_store_config-2">update_store_config/2*</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="change_node_store-2"></a>

### change_node_store/2 ###

<pre><code>
change_node_store(StorePath::binary(), CurrentStore::list()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="check_for_device-1"></a>

### check_for_device/1 ###

<pre><code>
check_for_device(Device::binary()) -&gt; boolean()
</code></pre>
<br />

<a name="create_actual_partition-2"></a>

### create_actual_partition/2 * ###

`create_actual_partition(Device, PartType) -> any()`

<a name="create_mount_info-3"></a>

### create_mount_info/3 * ###

`create_mount_info(Partition, MountPoint, VolumeName) -> any()`

<a name="create_partition-2"></a>

### create_partition/2 ###

<pre><code>
create_partition(Device::binary(), PartType::binary()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="format_disk-2"></a>

### format_disk/2 ###

<pre><code>
format_disk(Partition::binary(), EncKey::binary()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="get_partition_info-1"></a>

### get_partition_info/1 * ###

`get_partition_info(Device) -> any()`

<a name="list_partitions-0"></a>

### list_partitions/0 ###

<pre><code>
list_partitions() -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="mount_disk-4"></a>

### mount_disk/4 ###

<pre><code>
mount_disk(Partition::binary(), EncKey::binary(), MountPoint::binary(), VolumeName::binary()) -&gt; {ok, map()} | {error, binary()}
</code></pre>
<br />

<a name="mount_opened_volume-3"></a>

### mount_opened_volume/3 * ###

`mount_opened_volume(Partition, MountPoint, VolumeName) -> any()`

<a name="parse_disk_info-2"></a>

### parse_disk_info/2 * ###

`parse_disk_info(Device, Lines) -> any()`

<a name="parse_disk_line-2"></a>

### parse_disk_line/2 * ###

`parse_disk_line(Line, Info) -> any()`

<a name="parse_disk_model_line-2"></a>

### parse_disk_model_line/2 * ###

`parse_disk_model_line(Line, Info) -> any()`

<a name="parse_disk_units_line-2"></a>

### parse_disk_units_line/2 * ###

`parse_disk_units_line(Line, Info) -> any()`

<a name="parse_io_size_line-2"></a>

### parse_io_size_line/2 * ###

`parse_io_size_line(Line, Info) -> any()`

<a name="parse_sector_size_line-2"></a>

### parse_sector_size_line/2 * ###

`parse_sector_size_line(Line, Info) -> any()`

<a name="process_disk_line-2"></a>

### process_disk_line/2 * ###

`process_disk_line(Line, X2) -> any()`

<a name="update_store_config-2"></a>

### update_store_config/2 * ###

<pre><code>
update_store_config(StoreConfig::term(), NewPath::binary()) -&gt; term()
</code></pre>
<br />


--- END OF FILE: docs/resources/source-code/hb_volume.md ---

--- START OF FILE: docs/resources/source-code/hb.md ---
# [Module hb.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/hb.erl)




Hyperbeam is a decentralized node implementing the AO-Core protocol
on top of Arweave.

<a name="description"></a>

## Description ##

This protocol offers a computation layer for executing arbitrary logic on
top of the network's data.

Arweave is built to offer a robust, permanent storage layer for static data
over time. It can be seen as a globally distributed key-value store that
allows users to lookup IDs to retrieve data at any point in time:

`Arweave(ID) => Message`

Hyperbeam adds another layer of functionality on top of Arweave's protocol:
Allowing users to store and retrieve not only arbitrary bytes, but also to
perform execution of computation upon that data:

`Hyperbeam(Message1, Message2) => Message3`

When Hyperbeam executes a message, it will return a new message containing
the result of that execution, as well as signed commitments of its
correctness. If the computation that is executed is deterministic, recipients
of the new message are able to verify that the computation was performed
correctly. The new message may be stored back to Arweave if desired,
forming a permanent, verifiable, and decentralized log of computation.

The mechanisms described above form the basis of a decentralized and
verifiable compute engine without any relevant protocol-enforced
scalability limits. It is an implementation of a global, shared
supercomputer.

Hyperbeam can be used for an extremely large variety of applications, from
serving static Arweave data with signed commitments of correctness, to
executing smart contracts that have _built-in_ HTTP APIs. The Hyperbeam
node implementation implements AO, an Actor-Oriented process-based
environment for orchestrating computation over Arweave messages in order to
facilitate the execution of more traditional, consensus-based smart
contracts.

The core abstractions of the Hyperbeam node are broadly as follows:

1. The `hb` and `hb_opts` modules manage the node's configuration,
environment variables, and debugging tools.

2. The `hb_http` and `hb_http_server` modules manage all HTTP-related
functionality. `hb_http_server` handles turning received HTTP requests
into messages and applying those messages with the appropriate devices.
`hb_http` handles making requests and responding with messages. `cowboy`
is used to implement the underlying HTTP server.

3. `hb_ao` implements the computation logic of the node: A mechanism
for resolving messages to other messages, via the application of logic
implemented in `devices`. `hb_ao` also manages the loading of Erlang
modules for each device into the node's environment. There are many
different default devices implemented in the hyperbeam node, using the
namespace `dev_*`. Some of the critical components are:

- `dev_message`: The default handler for all messages that do not
specify their own device. The message device is also used to resolve
keys that are not implemented by the device specified in a message,
unless otherwise signalled.

- `dev_stack`: The device responsible for creating and executing stacks
of other devices on messages that request it. There are many uses for
this device, one of which is the resolution of AO processes.

- `dev_p4`: The device responsible for managing payments for the services
provided by the node.

4. `hb_store`, `hb_cache` and the store implementations forms a layered
system for managing the node's access to persistent storage. `hb_cache`
is used as a resolution mechanism for reading and writing messages, while
`hb_store` provides an abstraction over the underlying persistent key-value
byte storage mechanisms. Example `hb_store` mechanisms can be found in
`hb_store_fs` and `hb_store_remote_node`.

5. `ar_*` modules implement functionality related to the base-layer Arweave
protocol and are largely unchanged from their counterparts in the Arweave
node codebase presently maintained by the Digital History Association
(@dha-team/Arweave).

You can find documentation of a similar form to this note in each of the core
modules of the hyperbeam node.<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#address-0">address/0</a></td><td>Get the address of a wallet.</td></tr><tr><td valign="top"><a href="#address-1">address/1*</a></td><td></td></tr><tr><td valign="top"><a href="#benchmark-2">benchmark/2</a></td><td>Run a function as many times as possible in a given amount of time.</td></tr><tr><td valign="top"><a href="#benchmark-3">benchmark/3</a></td><td>Run multiple instances of a function in parallel for a given amount of time.</td></tr><tr><td valign="top"><a href="#build-0">build/0</a></td><td>Utility function to hot-recompile and load the hyperbeam environment.</td></tr><tr><td valign="top"><a href="#debug_wait-4">debug_wait/4</a></td><td>Utility function to wait for a given amount of time, printing a debug
message to the console first.</td></tr><tr><td valign="top"><a href="#do_start_simple_pay-1">do_start_simple_pay/1*</a></td><td></td></tr><tr><td valign="top"><a href="#init-0">init/0</a></td><td>Initialize system-wide settings for the hyperbeam node.</td></tr><tr><td valign="top"><a href="#no_prod-3">no_prod/3</a></td><td>Utility function to throw an error if the current mode is prod and
non-prod ready code is being executed.</td></tr><tr><td valign="top"><a href="#now-0">now/0</a></td><td>Utility function to get the current time in milliseconds.</td></tr><tr><td valign="top"><a href="#profile-1">profile/1</a></td><td>Utility function to start a profiling session and run a function,
then analyze the results.</td></tr><tr><td valign="top"><a href="#read-1">read/1</a></td><td>Debugging function to read a message from the cache.</td></tr><tr><td valign="top"><a href="#read-2">read/2</a></td><td></td></tr><tr><td valign="top"><a href="#start_mainnet-0">start_mainnet/0</a></td><td>Start a mainnet server without payments.</td></tr><tr><td valign="top"><a href="#start_mainnet-1">start_mainnet/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_simple_pay-0">start_simple_pay/0</a></td><td>Start a server with a <code>simple-pay@1.0</code> pre-processor.</td></tr><tr><td valign="top"><a href="#start_simple_pay-1">start_simple_pay/1</a></td><td></td></tr><tr><td valign="top"><a href="#start_simple_pay-2">start_simple_pay/2</a></td><td></td></tr><tr><td valign="top"><a href="#topup-3">topup/3</a></td><td>Helper for topping up a user's balance on a simple-pay node.</td></tr><tr><td valign="top"><a href="#topup-4">topup/4</a></td><td></td></tr><tr><td valign="top"><a href="#wallet-0">wallet/0</a></td><td></td></tr><tr><td valign="top"><a href="#wallet-1">wallet/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="address-0"></a>

### address/0 ###

`address() -> any()`

Get the address of a wallet. Defaults to the address of the wallet
specified by the `priv_key_location` configuration key. It can also take a
wallet tuple as an argument.

<a name="address-1"></a>

### address/1 * ###

`address(Wallet) -> any()`

<a name="benchmark-2"></a>

### benchmark/2 ###

`benchmark(Fun, TLen) -> any()`

Run a function as many times as possible in a given amount of time.

<a name="benchmark-3"></a>

### benchmark/3 ###

`benchmark(Fun, TLen, Procs) -> any()`

Run multiple instances of a function in parallel for a given amount of time.

<a name="build-0"></a>

### build/0 ###

`build() -> any()`

Utility function to hot-recompile and load the hyperbeam environment.

<a name="debug_wait-4"></a>

### debug_wait/4 ###

`debug_wait(T, Mod, Func, Line) -> any()`

Utility function to wait for a given amount of time, printing a debug
message to the console first.

<a name="do_start_simple_pay-1"></a>

### do_start_simple_pay/1 * ###

`do_start_simple_pay(Opts) -> any()`

<a name="init-0"></a>

### init/0 ###

`init() -> any()`

Initialize system-wide settings for the hyperbeam node.

<a name="no_prod-3"></a>

### no_prod/3 ###

`no_prod(X, Mod, Line) -> any()`

Utility function to throw an error if the current mode is prod and
non-prod ready code is being executed. You can find these in the codebase
by looking for ?NO_PROD calls.

<a name="now-0"></a>

### now/0 ###

`now() -> any()`

Utility function to get the current time in milliseconds.

<a name="profile-1"></a>

### profile/1 ###

`profile(Fun) -> any()`

Utility function to start a profiling session and run a function,
then analyze the results. Obviously -- do not use in production.

<a name="read-1"></a>

### read/1 ###

`read(ID) -> any()`

Debugging function to read a message from the cache.
Specify either a scope atom (local or remote) or a store tuple
as the second argument.

<a name="read-2"></a>

### read/2 ###

`read(ID, ScopeAtom) -> any()`

<a name="start_mainnet-0"></a>

### start_mainnet/0 ###

`start_mainnet() -> any()`

Start a mainnet server without payments.

<a name="start_mainnet-1"></a>

### start_mainnet/1 ###

`start_mainnet(Port) -> any()`

<a name="start_simple_pay-0"></a>

### start_simple_pay/0 ###

`start_simple_pay() -> any()`

Start a server with a `simple-pay@1.0` pre-processor.

<a name="start_simple_pay-1"></a>

### start_simple_pay/1 ###

`start_simple_pay(Addr) -> any()`

<a name="start_simple_pay-2"></a>

### start_simple_pay/2 ###

`start_simple_pay(Addr, Port) -> any()`

<a name="topup-3"></a>

### topup/3 ###

`topup(Node, Amount, Recipient) -> any()`

Helper for topping up a user's balance on a simple-pay node.

<a name="topup-4"></a>

### topup/4 ###

`topup(Node, Amount, Recipient, Wallet) -> any()`

<a name="wallet-0"></a>

### wallet/0 ###

`wallet() -> any()`

<a name="wallet-1"></a>

### wallet/1 ###

`wallet(Location) -> any()`


--- END OF FILE: docs/resources/source-code/hb.md ---

--- START OF FILE: docs/resources/source-code/index.md ---
# Source Code Documentation

Welcome to the source code documentation for HyperBEAM. This section provides detailed insights into the codebase, helping developers understand the structure, functionality, and implementation details of HyperBEAM and its components.

## Overview

HyperBEAM is built with a modular architecture to ensure scalability, maintainability, and extensibility. The source code is organized into distinct components, each serving a specific purpose within the ecosystem.

## Sections

- **HyperBEAM Core**: The main framework that orchestrates data processing, storage, and routing.
- **Compute Unit**: Handles computational tasks and integrates with the HyperBEAM core for distributed processing.
- **Trusted Execution Environment (TEE)**: Ensures secure execution of sensitive operations.
- **Client Libraries**: Tools and SDKs for interacting with HyperBEAM, including the JavaScript client.

## Getting Started

To explore the source code, you can clone the repository from [GitHub](https://github.com/permaweb/HyperBEAM).

## Navigation

Use the navigation menu to dive into specific parts of the codebase. Each module includes detailed documentation, code comments, and examples to assist in understanding and contributing to the project.


--- END OF FILE: docs/resources/source-code/index.md ---

--- START OF FILE: docs/resources/source-code/README.md ---


# The hb application #


## Modules ##


<table width="100%" border="0" summary="list of modules">
<tr><td><a href="ar_bundles.md" class="module">ar_bundles</a></td></tr>
<tr><td><a href="ar_deep_hash.md" class="module">ar_deep_hash</a></td></tr>
<tr><td><a href="ar_rate_limiter.md" class="module">ar_rate_limiter</a></td></tr>
<tr><td><a href="ar_timestamp.md" class="module">ar_timestamp</a></td></tr>
<tr><td><a href="ar_tx.md" class="module">ar_tx</a></td></tr>
<tr><td><a href="ar_wallet.md" class="module">ar_wallet</a></td></tr>
<tr><td><a href="dev_cache.md" class="module">dev_cache</a></td></tr>
<tr><td><a href="dev_cacheviz.md" class="module">dev_cacheviz</a></td></tr>
<tr><td><a href="dev_codec_ans104.md" class="module">dev_codec_ans104</a></td></tr>
<tr><td><a href="dev_codec_flat.md" class="module">dev_codec_flat</a></td></tr>
<tr><td><a href="dev_codec_httpsig.md" class="module">dev_codec_httpsig</a></td></tr>
<tr><td><a href="dev_codec_httpsig_conv.md" class="module">dev_codec_httpsig_conv</a></td></tr>
<tr><td><a href="dev_codec_json.md" class="module">dev_codec_json</a></td></tr>
<tr><td><a href="dev_codec_structured.md" class="module">dev_codec_structured</a></td></tr>
<tr><td><a href="dev_cron.md" class="module">dev_cron</a></td></tr>
<tr><td><a href="dev_cu.md" class="module">dev_cu</a></td></tr>
<tr><td><a href="dev_dedup.md" class="module">dev_dedup</a></td></tr>
<tr><td><a href="dev_delegated_compute.md" class="module">dev_delegated_compute</a></td></tr>
<tr><td><a href="dev_faff.md" class="module">dev_faff</a></td></tr>
<tr><td><a href="dev_genesis_wasm.md" class="module">dev_genesis_wasm</a></td></tr>
<tr><td><a href="dev_green_zone.md" class="module">dev_green_zone</a></td></tr>
<tr><td><a href="dev_hyperbuddy.md" class="module">dev_hyperbuddy</a></td></tr>
<tr><td><a href="dev_json_iface.md" class="module">dev_json_iface</a></td></tr>
<tr><td><a href="dev_local_name.md" class="module">dev_local_name</a></td></tr>
<tr><td><a href="dev_lookup.md" class="module">dev_lookup</a></td></tr>
<tr><td><a href="dev_lua.md" class="module">dev_lua</a></td></tr>
<tr><td><a href="dev_lua_lib.md" class="module">dev_lua_lib</a></td></tr>
<tr><td><a href="dev_lua_test.md" class="module">dev_lua_test</a></td></tr>
<tr><td><a href="dev_manifest.md" class="module">dev_manifest</a></td></tr>
<tr><td><a href="dev_message.md" class="module">dev_message</a></td></tr>
<tr><td><a href="dev_meta.md" class="module">dev_meta</a></td></tr>
<tr><td><a href="dev_monitor.md" class="module">dev_monitor</a></td></tr>
<tr><td><a href="dev_multipass.md" class="module">dev_multipass</a></td></tr>
<tr><td><a href="dev_name.md" class="module">dev_name</a></td></tr>
<tr><td><a href="dev_node_process.md" class="module">dev_node_process</a></td></tr>
<tr><td><a href="dev_p4.md" class="module">dev_p4</a></td></tr>
<tr><td><a href="dev_patch.md" class="module">dev_patch</a></td></tr>
<tr><td><a href="dev_poda.md" class="module">dev_poda</a></td></tr>
<tr><td><a href="dev_process.md" class="module">dev_process</a></td></tr>
<tr><td><a href="dev_process_cache.md" class="module">dev_process_cache</a></td></tr>
<tr><td><a href="dev_process_worker.md" class="module">dev_process_worker</a></td></tr>
<tr><td><a href="dev_push.md" class="module">dev_push</a></td></tr>
<tr><td><a href="dev_relay.md" class="module">dev_relay</a></td></tr>
<tr><td><a href="dev_router.md" class="module">dev_router</a></td></tr>
<tr><td><a href="dev_scheduler.md" class="module">dev_scheduler</a></td></tr>
<tr><td><a href="dev_scheduler_cache.md" class="module">dev_scheduler_cache</a></td></tr>
<tr><td><a href="dev_scheduler_formats.md" class="module">dev_scheduler_formats</a></td></tr>
<tr><td><a href="dev_scheduler_registry.md" class="module">dev_scheduler_registry</a></td></tr>
<tr><td><a href="dev_scheduler_server.md" class="module">dev_scheduler_server</a></td></tr>
<tr><td><a href="dev_simple_pay.md" class="module">dev_simple_pay</a></td></tr>
<tr><td><a href="dev_snp.md" class="module">dev_snp</a></td></tr>
<tr><td><a href="dev_snp_nif.md" class="module">dev_snp_nif</a></td></tr>
<tr><td><a href="dev_stack.md" class="module">dev_stack</a></td></tr>
<tr><td><a href="dev_test.md" class="module">dev_test</a></td></tr>
<tr><td><a href="dev_wasi.md" class="module">dev_wasi</a></td></tr>
<tr><td><a href="dev_wasm.md" class="module">dev_wasm</a></td></tr>
<tr><td><a href="hb.md" class="module">hb</a></td></tr>
<tr><td><a href="hb_ao.md" class="module">hb_ao</a></td></tr>
<tr><td><a href="hb_ao_test_vectors.md" class="module">hb_ao_test_vectors</a></td></tr>
<tr><td><a href="hb_app.md" class="module">hb_app</a></td></tr>
<tr><td><a href="hb_beamr.md" class="module">hb_beamr</a></td></tr>
<tr><td><a href="hb_beamr_io.md" class="module">hb_beamr_io</a></td></tr>
<tr><td><a href="hb_cache.md" class="module">hb_cache</a></td></tr>
<tr><td><a href="hb_cache_control.md" class="module">hb_cache_control</a></td></tr>
<tr><td><a href="hb_cache_render.md" class="module">hb_cache_render</a></td></tr>
<tr><td><a href="hb_client.md" class="module">hb_client</a></td></tr>
<tr><td><a href="hb_crypto.md" class="module">hb_crypto</a></td></tr>
<tr><td><a href="hb_debugger.md" class="module">hb_debugger</a></td></tr>
<tr><td><a href="hb_escape.md" class="module">hb_escape</a></td></tr>
<tr><td><a href="hb_event.md" class="module">hb_event</a></td></tr>
<tr><td><a href="hb_examples.md" class="module">hb_examples</a></td></tr>
<tr><td><a href="hb_features.md" class="module">hb_features</a></td></tr>
<tr><td><a href="hb_gateway_client.md" class="module">hb_gateway_client</a></td></tr>
<tr><td><a href="hb_http.md" class="module">hb_http</a></td></tr>
<tr><td><a href="hb_http_benchmark_tests.md" class="module">hb_http_benchmark_tests</a></td></tr>
<tr><td><a href="hb_http_client.md" class="module">hb_http_client</a></td></tr>
<tr><td><a href="hb_http_client_sup.md" class="module">hb_http_client_sup</a></td></tr>
<tr><td><a href="hb_http_server.md" class="module">hb_http_server</a></td></tr>
<tr><td><a href="hb_json.md" class="module">hb_json</a></td></tr>
<tr><td><a href="hb_logger.md" class="module">hb_logger</a></td></tr>
<tr><td><a href="hb_message.md" class="module">hb_message</a></td></tr>
<tr><td><a href="hb_metrics_collector.md" class="module">hb_metrics_collector</a></td></tr>
<tr><td><a href="hb_name.md" class="module">hb_name</a></td></tr>
<tr><td><a href="hb_opts.md" class="module">hb_opts</a></td></tr>
<tr><td><a href="hb_path.md" class="module">hb_path</a></td></tr>
<tr><td><a href="hb_persistent.md" class="module">hb_persistent</a></td></tr>
<tr><td><a href="hb_private.md" class="module">hb_private</a></td></tr>
<tr><td><a href="hb_process_monitor.md" class="module">hb_process_monitor</a></td></tr>
<tr><td><a href="hb_router.md" class="module">hb_router</a></td></tr>
<tr><td><a href="hb_singleton.md" class="module">hb_singleton</a></td></tr>
<tr><td><a href="hb_store.md" class="module">hb_store</a></td></tr>
<tr><td><a href="hb_store_fs.md" class="module">hb_store_fs</a></td></tr>
<tr><td><a href="hb_store_gateway.md" class="module">hb_store_gateway</a></td></tr>
<tr><td><a href="hb_store_remote_node.md" class="module">hb_store_remote_node</a></td></tr>
<tr><td><a href="hb_store_rocksdb.md" class="module">hb_store_rocksdb</a></td></tr>
<tr><td><a href="hb_structured_fields.md" class="module">hb_structured_fields</a></td></tr>
<tr><td><a href="hb_sup.md" class="module">hb_sup</a></td></tr>
<tr><td><a href="hb_test_utils.md" class="module">hb_test_utils</a></td></tr>
<tr><td><a href="hb_tracer.md" class="module">hb_tracer</a></td></tr>
<tr><td><a href="hb_util.md" class="module">hb_util</a></td></tr>
<tr><td><a href="hb_volume.md" class="module">hb_volume</a></td></tr>
<tr><td><a href="rsa_pss.md" class="module">rsa_pss</a></td></tr></table>


--- END OF FILE: docs/resources/source-code/README.md ---

--- START OF FILE: docs/resources/source-code/rsa_pss.md ---
# [Module rsa_pss.erl](https://github.com/permaweb/HyperBEAM/blob/main/src/rsa_pss.erl)



* [Data Types](#types)

Distributed under the Mozilla Public License v2.0.

Copyright (c) 2014-2015, Andrew Bennett

__Authors:__ Andrew Bennett ([`andrew@pixid.com`](mailto:andrew@pixid.com)).

<a name="description"></a>

## Description ##
Original available at:
https://github.com/potatosalad/erlang-crypto_rsassa_pss
<a name="types"></a>

## Data Types ##




### <a name="type-rsa_digest_type">rsa_digest_type()</a> ###


<pre><code>
rsa_digest_type() = md5 | sha | sha224 | sha256 | sha384 | sha512
</code></pre>




### <a name="type-rsa_private_key">rsa_private_key()</a> ###


<pre><code>
rsa_private_key() = #RSAPrivateKey{}
</code></pre>




### <a name="type-rsa_public_key">rsa_public_key()</a> ###


<pre><code>
rsa_public_key() = #RSAPublicKey{}
</code></pre>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#dp-2">dp/2*</a></td><td></td></tr><tr><td valign="top"><a href="#ep-2">ep/2*</a></td><td></td></tr><tr><td valign="top"><a href="#int_to_bit_size-1">int_to_bit_size/1*</a></td><td></td></tr><tr><td valign="top"><a href="#int_to_bit_size-2">int_to_bit_size/2*</a></td><td></td></tr><tr><td valign="top"><a href="#int_to_byte_size-1">int_to_byte_size/1*</a></td><td></td></tr><tr><td valign="top"><a href="#int_to_byte_size-2">int_to_byte_size/2*</a></td><td></td></tr><tr><td valign="top"><a href="#mgf1-3">mgf1/3*</a></td><td></td></tr><tr><td valign="top"><a href="#mgf1-5">mgf1/5*</a></td><td></td></tr><tr><td valign="top"><a href="#normalize_to_key_size-2">normalize_to_key_size/2*</a></td><td></td></tr><tr><td valign="top"><a href="#pad_to_key_size-2">pad_to_key_size/2*</a></td><td></td></tr><tr><td valign="top"><a href="#sign-3">sign/3</a></td><td></td></tr><tr><td valign="top"><a href="#sign-4">sign/4</a></td><td></td></tr><tr><td valign="top"><a href="#verify-4">verify/4</a></td><td></td></tr><tr><td valign="top"><a href="#verify_legacy-4">verify_legacy/4</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="dp-2"></a>

### dp/2 * ###

`dp(B, X2) -> any()`

<a name="ep-2"></a>

### ep/2 * ###

`ep(B, X2) -> any()`

<a name="int_to_bit_size-1"></a>

### int_to_bit_size/1 * ###

`int_to_bit_size(I) -> any()`

<a name="int_to_bit_size-2"></a>

### int_to_bit_size/2 * ###

`int_to_bit_size(I, B) -> any()`

<a name="int_to_byte_size-1"></a>

### int_to_byte_size/1 * ###

`int_to_byte_size(I) -> any()`

<a name="int_to_byte_size-2"></a>

### int_to_byte_size/2 * ###

`int_to_byte_size(I, B) -> any()`

<a name="mgf1-3"></a>

### mgf1/3 * ###

`mgf1(DigestType, Seed, Len) -> any()`

<a name="mgf1-5"></a>

### mgf1/5 * ###

`mgf1(DigestType, Seed, Len, T, Counter) -> any()`

<a name="normalize_to_key_size-2"></a>

### normalize_to_key_size/2 * ###

`normalize_to_key_size(Bits, A) -> any()`

<a name="pad_to_key_size-2"></a>

### pad_to_key_size/2 * ###

`pad_to_key_size(Bytes, Data) -> any()`

<a name="sign-3"></a>

### sign/3 ###

<pre><code>
sign(Message, DigestType, PrivateKey) -&gt; Signature
</code></pre>

<ul class="definitions"><li><code>Message = binary() | {digest, binary()}</code></li><li><code>DigestType = <a href="#type-rsa_digest_type">rsa_digest_type()</a> | atom()</code></li><li><code>PrivateKey = <a href="#type-rsa_private_key">rsa_private_key()</a></code></li><li><code>Signature = binary()</code></li></ul>

<a name="sign-4"></a>

### sign/4 ###

<pre><code>
sign(Message, DigestType, Salt, PrivateKey) -&gt; Signature
</code></pre>

<ul class="definitions"><li><code>Message = binary() | {digest, binary()}</code></li><li><code>DigestType = <a href="#type-rsa_digest_type">rsa_digest_type()</a> | atom()</code></li><li><code>Salt = binary()</code></li><li><code>PrivateKey = <a href="#type-rsa_private_key">rsa_private_key()</a></code></li><li><code>Signature = binary()</code></li></ul>

<a name="verify-4"></a>

### verify/4 ###

<pre><code>
verify(Message, DigestType, Signature, PublicKey) -&gt; boolean()
</code></pre>

<ul class="definitions"><li><code>Message = binary() | {digest, binary()}</code></li><li><code>DigestType = <a href="#type-rsa_digest_type">rsa_digest_type()</a> | atom()</code></li><li><code>Signature = binary()</code></li><li><code>PublicKey = <a href="#type-rsa_public_key">rsa_public_key()</a></code></li></ul>

<a name="verify_legacy-4"></a>

### verify_legacy/4 ###

`verify_legacy(Message, DigestType, Signature, PublicKey) -> any()`


--- END OF FILE: docs/resources/source-code/rsa_pss.md ---

--- START OF FILE: docs/run/configuring-your-machine.md ---
# Configuring Your HyperBEAM Node

This guide details the various ways to configure your HyperBEAM node's behavior, including ports, storage, keys, and logging.

## Configuration (`config.flat`)

The primary way to configure your HyperBEAM node is through a `config.flat` file located in the node's working directory or specified by the `HB_CONFIG_LOCATION` environment variable.

This file uses a simple `Key = Value.` format (note the period at the end of each line).

**Example `config.flat`:**

```erlang
% Set the HTTP port
port = 8080.

% Specify the Arweave key file
priv_key_location = "/path/to/your/wallet.json".

% Set the data store directory
% Note: Storage configuration can be complex. See below.
% store = [{local, [{root, <<"./node_data_mainnet">>}]}]. % Example of complex config, not for config.flat

% Enable verbose logging for specific modules
% debug_print = [hb_http, dev_router]. % Example of complex config, not for config.flat
```

Below is a reference of commonly used configuration keys. Remember that `config.flat` only supports simple key-value pairs (Atoms, Strings, Integers, Booleans). For complex configurations (Lists, Maps), you must use environment variables or `hb:start_mainnet/1`.

### Core Configuration

These options control fundamental HyperBEAM behavior.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `port` | Integer | 8734 | HTTP API port |
| `hb_config_location` | String | "config.flat" | Path to configuration file |
| `priv_key_location` | String | "hyperbeam-key.json" | Path to operator wallet key file |
| `mode` | Atom | debug | Execution mode (debug, prod) |

### Server & Network Configuration

These options control networking behavior and HTTP settings.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `host` | String | "localhost" | Choice of remote node for non-local tasks |
| `gateway` | String | "https://arweave.net" | Default gateway |
| `bundler_ans104` | String | "https://up.arweave.net:443" | Location of ANS-104 bundler |
| `protocol` | Atom | http2 | Protocol for HTTP requests (http1, http2, http3) |
| `http_client` | Atom | gun | HTTP client to use (gun, httpc) |
| `http_connect_timeout` | Integer | 5000 | HTTP connection timeout in milliseconds |
| `http_keepalive` | Integer | 120000 | HTTP keepalive time in milliseconds |
| `http_request_send_timeout` | Integer | 60000 | HTTP request send timeout in milliseconds |
| `relay_http_client` | Atom | httpc | HTTP client for the relay device |
<!-- Complex options like http_extra_opts are omitted as they are not suitable for config.flat -->

### Security & Identity

These options control identity and security settings.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `scheduler_location_ttl` | Integer | 604800000 | TTL for scheduler registration (7 days in ms) |
<!-- Complex options like trusted_device_signers, trusted are omitted -->

### Caching & Storage

These options control caching behavior. **Note:** Detailed storage configuration (`store` option) involves complex data structures and cannot be set via `config.flat`.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `cache_lookup_hueristics` | Boolean | false | Whether to use caching heuristics or always consult the local data store |
| `access_remote_cache_for_client` | Boolean | false | Whether to access data from remote caches for client requests |
| `store_all_signed` | Boolean | true | Whether the node should store all signed messages |
| `await_inprogress` | Atom/Boolean | named | Whether to await in-progress executions (false, named, true) |
<!-- Complex options like cache_control are omitted -->

### Execution & Processing

These options control how HyperBEAM executes messages and processes.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `scheduling_mode` | Atom | local_confirmation | When to inform recipients about scheduled assignments (aggressive, local_confirmation, remote_confirmation) |
| `compute_mode` | Atom | lazy | Whether to execute more messages after returning a result (aggressive, lazy) |
| `process_workers` | Boolean | true | Whether the node should use persistent processes |
| `client_error_strategy` | Atom | throw | What to do if a client error occurs |
| `wasm_allow_aot` | Boolean | false | Allow ahead-of-time compilation for WASM |

### Device Management

These options control how HyperBEAM manages devices.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `load_remote_devices` | Boolean | false | Whether to load devices from remote signers |
<!-- Complex options like preloaded_devices, devices are omitted -->

### Debug & Development

These options control debugging and development features.

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `debug_stack_depth` | Integer | 40 | Maximum stack depth for debug printing |
| `debug_print_map_line_threshold` | Integer | 30 | Maximum lines for map printing |
| `debug_print_binary_max` | Integer | 60 | Maximum binary size for debug printing |
| `debug_print_indent` | Integer | 2 | Indentation for debug printing |
| `debug_print_trace` | Atom | short | Trace mode (short, false) |
| `short_trace_len` | Integer | 5 | Length of short traces |
| `debug_hide_metadata` | Boolean | true | Whether to hide metadata in debug output |
| `debug_ids` | Boolean | false | Whether to print IDs in debug output |
| `debug_hide_priv` | Boolean | true | Whether to hide private data in debug output |
<!-- Complex options like debug_print, stack_print_prefixes are omitted -->

**Note:** For the *absolute complete* and most up-to-date list, including complex options not suitable for `config.flat`, refer to the `default_message/0` function in the `hb_opts` module source code.

## Overrides (Environment Variables & Args)

You can override settings from `config.flat` or provide values if the file is missing using environment variables or command-line arguments.

**Using Environment Variables:**

Environment variables typically use an `HB_` prefix followed by the configuration key in uppercase.

*   **`HB_PORT=<port_number>`:** Overrides `hb_port`.
    *   Example: `HB_PORT=8080 rebar3 shell`
*   **`HB_KEY=<path/to/wallet.key>`:** Overrides `hb_key`.
    *   Example: `HB_KEY=~/.keys/arweave_key.json rebar3 shell`
*   **`HB_STORE=<directory_path>`:** Overrides `hb_store`.
    *   Example: `HB_STORE=./node_data_1 rebar3 shell`
*   **`HB_PRINT=<setting>`:** Overrides `hb_print`. `<setting>` can be `true` (or `1`), or a comma-separated list of modules/topics (e.g., `hb_path,hb_ao,ao_result`).
    *   Example: `HB_PRINT=hb_http,dev_router rebar3 shell`
*   **`HB_CONFIG_LOCATION=<path/to/config.flat>`:** Specifies a custom location for the configuration file.

**Using `erl_opts` (Direct Erlang VM Arguments):**

You can also pass arguments directly to the Erlang VM using the `-<key> <value>` format within `erl_opts`. This is generally less common for application configuration than `config.flat` or environment variables.

```bash
rebar3 shell --erl_opts "-hb_port 8080 -hb_key path/to/key.json"
```

**Order of Precedence:**

1.  Command-line arguments (`erl_opts`).
2.  Settings in `config.flat`.
3.  Environment variables (`HB_*`).
4.  Default values from `hb_opts.erl`.

## Configuration in Releases

When running a release build (see [Running a HyperBEAM Node](./running-a-hyperbeam-node.md)), configuration works similarly:

1.  A `config.flat` file will be present in the release directory (e.g., `_build/default/rel/hb/config.flat`). Edit this file to set your desired parameters for the release environment.
2.  Environment variables (`HB_*`) can still be used to override the settings in the release's `config.flat` when starting the node using the `bin/hb` script.

--- END OF FILE: docs/run/configuring-your-machine.md ---

--- START OF FILE: docs/run/joining-running-a-router.md ---
# Joining or Running a Router Node

Router nodes play a crucial role in the HyperBEAM network by directing incoming HTTP requests to appropriate worker nodes capable of handling the requested computation or data retrieval. They act as intelligent load balancers and entry points into the AO ecosystem.

!!! info "Advanced Topic"
    Configuring and running a production-grade router involves considerations beyond the scope of this introductory guide, including network topology, security, high availability, and performance tuning.

## What is a Router?

In HyperBEAM, the `dev_router` module (and associated logic) implements routing functionality. A node configured as a router typically:

1.  Receives external HTTP requests (HyperPATH calls).
2.  Parses the request path to determine the target process, device, and desired operation.
3.  Consults its routing table or logic to select an appropriate downstream worker node (which might be itself or another node).
4.  Forwards the request to the selected worker.
5.  Receives the response from the worker.
6.  Returns the response to the original client.

Routers often maintain information about the capabilities and load of worker nodes they know about.

## Configuring Routing Behavior

Routing logic is primarily configured through node options, often managed via `hb_opts` or environment variables when starting the node. Key aspects include:

*   **Route Definitions:** Defining patterns (templates) and corresponding downstream targets (worker node URLs or internal handlers). Routes are typically ordered by precedence.
*   **Load Balancing Strategy:** How the router chooses among multiple potential workers for a given route (e.g., round-robin, least connections, latency-based).
*   **Worker Discovery/Management:** How the router learns about available worker nodes and their status.

**Example Configuration Snippet (Conceptual - from `hb_opts` or config file):**

```erlang
{
  routes,
  [
    #{ template => "/~meta@1.0/.*", target => self }, % Handle meta locally
    #{ template => "/PROCESS_ID1~process@1.0/.*", target => "http://worker1.example.com" },
    #{ template => "/PROCESS_ID2~process@1.0/.*", target => "http://worker2.example.com" },
    #{ template => "/.*~wasm64@1.0/.*", target => ["http://wasm_worker1", "http://wasm_worker2"], strategy => round_robin }, % Route WASM requests
    #{ template => "/.*", target => "http://default_worker.example.com" } % Default fallback
  ]
},
{ router_load_balancing_strategy, latency_aware }
```

*(Note: The actual configuration format and options should be verified in the `hb_opts.erl` and `dev_router.erl` source code.)*

## Running a Simple Router

While a dedicated router setup is complex, any HyperBEAM node implicitly performs some level of routing, especially if it needs to interact with other nodes (e.g., via the `~relay@1.0` device). The default configuration might route certain requests internally or have basic forwarding capabilities.

To run a node that explicitly acts *more* like a router, you would typically configure it with specific `routes` pointing to other worker nodes, potentially disabling local execution for certain devices it intends to forward.

## Joining an Existing Router Network

As a user or developer, you typically don't *run* the main public routers (like `router-1.forward.computer`). Instead, you configure your client applications (or your own local node if it needs to relay requests) to *use* these public routers as entry points.

When making HyperPATH calls, you simply target the public router's URL:

```
https://<router_url>/<process_id>~<device>/<key>...
```
The router handles directing your request to an appropriate compute node.

## Further Exploration

*   Examine the `dev_router.erl` source code for detailed implementation.
*   Review the available configuration options in `hb_opts.erl` related to routing (`routes`, strategies, etc.).
*   Consult community channels or advanced documentation for best practices on deploying production routers.

--- END OF FILE: docs/run/joining-running-a-router.md ---

--- START OF FILE: docs/run/running-a-hyperbeam-node.md ---
# Running a HyperBEAM Node

This guide provides the basics for running your own HyperBEAM node, installing dependencies, and connecting to the AO network.

## System Dependencies

To successfully build and run a HyperBEAM node, your system needs several software dependencies installed.

=== "macOS"
    Install core dependencies using [Homebrew](https://brew.sh/):

    ```bash
    brew install cmake git pkg-config openssl ncurses
    ```

=== "Linux (Debian/Ubuntu)"
    Install core dependencies using `apt`:
    ```bash
    sudo apt-get update && sudo apt-get install -y --no-install-recommends \
        build-essential \
        cmake \
        git \
        pkg-config \
        ncurses-dev \
        libssl-dev \
        sudo \
        curl \
        ca-certificates
    ```

=== "Windows (WSL)"
    Using the Windows Subsystem for Linux (WSL) with a distribution like Ubuntu is recommended. Follow the Linux (Debian/Ubuntu) instructions within your WSL environment.

<!-- **Core Dependency Breakdown:**

*   `build-essential` (Linux) / Xcode Command Line Tools (macOS): Basic C/C++ compilers and build tools (gcc, g++, make).
*   `cmake`: Build system generator.
*   `git`: Version control for fetching the source code.
*   `pkg-config`: Helps find installed libraries during compilation.
*   `ncurses-dev` / `ncurses`: Required for some terminal interface elements used by Erlang/OTP.
*   `libssl-dev` / `openssl`: Necessary for cryptographic operations and secure connections (HTTPS). You might need to set specific environment variables for `openssl` during Erlang compilation if building from source on macOS.
*   `sudo` (Linux/macOS): Needed for system-level installations.
*   `curl`: Used for downloading dependencies or interacting with web services.
*   `ca-certificates` (Linux): Required for validating SSL certificates (often handled by the OS on macOS/Windows).

*(Note: Package names may vary slightly on other Linux distributions. Use your system's package manager accordingly, e.g., `yum`, `dnf`, `pacman`.)* -->

### Erlang/OTP

HyperBEAM is built on Erlang/OTP. You need a compatible version installed (check the `rebar.config` or project documentation for specific version requirements, **typically OTP 27**).

Installation methods:

=== "macOS (brew)"
    ```bash
    brew install erlang
    ```

=== "Linux (apt)"
    ```bash
    sudo apt install erlang
    ```

=== "asdf (Recommended)"
    Tools like `asdf-vm` with the `asdf-erlang` plugin are highly recommended for managing multiple Erlang versions across platforms.
    ```bash
    asdf plugin add erlang https://github.com/asdf-vm/asdf-erlang.git
    asdf install erlang <version> # e.g., 27.0
    asdf global erlang <version>
    ```

=== "Source Build"
    Download from [erlang.org](https://www.erlang.org/downloads) and follow the build instructions for your platform.

### Rebar3

Rebar3 is the build tool for Erlang projects.

Installation methods:

=== "macOS (brew)"
    ```bash
    brew install rebar3
    ```

=== "Linux / macOS (Direct Download)"
    Get the `rebar3` binary from the [official website](https://rebar3.org/). Place the downloaded `rebar3` file in your system's `PATH` (e.g., `/usr/local/bin`) and make it executable (`chmod +x rebar3`).

=== "asdf (Recommended)"
    If using `asdf`, you can install it via the `rebar` plugin:
    ```bash
    asdf plugin add rebar https://github.com/asdf-vm/asdf-rebar.git
    asdf install rebar <version> # e.g., 3.23.0
    asdf global rebar <version>
    ```

### Node.js

Node.js might be required for certain JavaScript-related tools or dependencies.

Installation methods:

=== "macOS (brew)"
    ```bash
    brew install node
    ```

=== "Linux (apt)"
    ```bash
    # Check your distribution's recommended method, might need nodesource repo
    sudo apt install nodejs npm 
    ```

=== "asdf (Recommended)"
    `asdf-vm` with the `asdf-nodejs` plugin is recommended.
    ```bash
    asdf plugin add nodejs https://github.com/asdf-vm/asdf-nodejs.git
    asdf install nodejs <version> # e.g., lts
    asdf global nodejs <version>
    ```

### Rust

Rust is needed if you intend to work with or build components involving WebAssembly (WASM) or certain Native Implemented Functions (NIFs) used by some devices (like `~snp@1.0`).

The recommended way to install Rust on **all platforms** is via `rustup`:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source "$HOME/.cargo/env" # Or follow the instructions provided by rustup
```

## Prerequisites for Running

Before starting a node, ensure you have:

*   Installed the [system dependencies](#system-dependencies) mentioned above.
*   Cloned the [HyperBEAM repository](https://github.com/permaweb/HyperBEAM) (`git clone ...`).
*   Compiled the source code (`rebar3 compile` in the repo directory).
*   An Arweave **wallet keyfile** (e.g., generated via [Wander](https://www.wander.app)). The path to this file is typically set via the `hb_key` configuration option (see [Configuring Your HyperBEAM Node](./configuring-your-machine.md)).

## Starting a Basic Node

The simplest way to start a HyperBEAM node for development or testing is using `rebar3` from the repository's root directory:

```bash
rebar3 shell
```

This command:

1.  Starts the Erlang Virtual Machine (BEAM) with all HyperBEAM modules loaded.
2.  Initializes the node with default settings (from `hb_opts.erl`).
3.  Starts the default HTTP server (typically on **port 10000**), making the node accessible via HyperPATHs.
4.  Drops you into an interactive Erlang shell where you can interact with the running node.

This basic setup is suitable for local development and exploring HyperBEAM's functionalities.

## Optional Build Profiles

HyperBEAM uses build profiles to enable optional features, often requiring extra dependencies. To run a node with specific profiles enabled, use `rebar3 as ... shell`:

**Available Profiles (Examples):**

*   `genesis_wasm`: Enables Genesis WebAssembly support.
*   `rocksdb`: Enables the RocksDB storage backend.
*   `http3`: Enables HTTP/3 support.

**Example Usage:**

```bash
# Start with RocksDB profile
rebar3 as rocksdb shell

# Start with RocksDB and Genesis WASM profiles
rebar3 as rocksdb, genesis_wasm shell
```

*Note: Choose profiles **before** starting the shell, as they affect compile-time options.*

## Node Configuration

HyperBEAM offers various configuration options (port, key file, data storage, logging, etc.). These are primarily set using a `config.flat` file and can be overridden by environment variables or command-line arguments.

See the dedicated **[Configuring Your HyperBEAM Node](./configuring-your-machine.md)** guide for detailed information on all configuration methods and options.

## Verify Installation

To quickly check if your node is running and accessible, you can send a request to its `~meta@1.0` device (assuming default port 10000):

```bash
curl http://localhost:10000/~meta@1.0/info
```

A JSON response containing node information indicates success.

## Running for Production (Mainnet)

While you can connect to the main AO network using the `rebar3 shell` for testing purposes (potentially using specific configurations or helper functions like `hb:start_mainnet/1` if available and applicable), the standard and recommended method for a stable production deployment (like running on the mainnet) is to build and run a **release**.

**1. Build the Release:**

From the root of the HyperBEAM repository, build the release package. You might include specific profiles needed for your mainnet setup (e.g., `rocksdb` if you intend to use it):

```bash
# Build release with default profile
rebar3 release

# Or, build with specific profiles (example)
# rebar3 as rocksdb release
```

This command compiles the project and packages it along with the Erlang Runtime System (ERTS) and all dependencies into a directory, typically `_build/default/rel/hb`.

**2. Configure the Release:**

Navigate into the release directory (e.g., `cd _build/default/rel/hb`). Ensure you have a correctly configured `config.flat` file here. See the [configuration guide](./configuring-your-machine.md) for details on setting mainnet parameters (port, key file location, store path, specific peers, etc.). Environment variables can also be used to override settings in the release's `config.flat` when starting the node.

**3. Start the Node:**

Use the generated start script (`bin/hb`) to run the node:

```bash
# Start the node in the foreground (logs to console)
./bin/hb console

# Start the node as a background daemon
./bin/hb start

# Check the status
./bin/hb ping
./bin/hb status

# Stop the node
./bin/hb stop
```

Consult the generated `bin/hb` script or Erlang/OTP documentation for more advanced start-up options (e.g., attaching a remote shell).

Running as a release provides a more robust, isolated, and manageable way to operate a node compared to running directly from the `rebar3 shell`.

## Stopping the Node (rebar3 shell)

To stop the node running *within the `rebar3 shell`*, press `Ctrl+C` twice or use the Erlang command `q().`.

## Next Steps

*   **Configure Your Node:** Deep dive into [configuration options](./configuring-your-machine.md).
*   **TEE Nodes:** Learn about running nodes in [Trusted Execution Environments](./tee-nodes.md) for enhanced security.
*   **Routers:** Understand how to configure and run a [router node](./joining-running-a-router.md).

--- END OF FILE: docs/run/running-a-hyperbeam-node.md ---

--- START OF FILE: docs/run/tee-nodes.md ---
# Trusted Execution Environment (TEE)

!!! info "Documentation Coming Soon"
    Detailed documentation about Trusted Execution Environment support in HyperBEAM is currently being developed and will be available soon.

## Overview

HyperBEAM supports Trusted Execution Environments (TEEs) through the `~snp@1.0` device, which enables secure, trust-minimized computation on remote machines. TEEs provide hardware-level isolation and attestation capabilities that allow users to verify that their code is running in a protected environment, exactly as intended, even on untrusted hardware.

The `~snp@1.0` device in HyperBEAM is used to generate and validate proofs that a node is executing inside a Trusted Execution Environment. Nodes executing inside these environments use an ephemeral key pair that provably only exists inside the TEE, and can sign attestations of AO-Core executions in a trust-minimized way.

## Key Features

- Hardware-level isolation for secure computation
- Remote attestation capabilities
- Protected execution state
- Confidential computing support
- Compatibility with AMD SEV-SNP technology

## Coming Soon

Detailed documentation on the following topics will be added:

- TEE setup and configuration
- Using the `~snp@1.0` device
- Verifying TEE attestations
- Developing for TEEs
- Security considerations
- Performance characteristics

If you intend to offer TEE-based computation of AO-Core devices, please see the [HyperBEAM OS repository](https://github.com/permaweb/hb-os) for preliminary details on configuration and deployment. 
--- END OF FILE: docs/run/tee-nodes.md ---

