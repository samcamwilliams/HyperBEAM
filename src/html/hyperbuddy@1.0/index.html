<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="icon"
            type="image/png"
            href="https://arweave.net/rBcLwnVU2fWNEKUW8PY0TzEAPuCHMj2Vp6z6CedHJf0"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" href="/~hyperbuddy@1.0/styles.css" />

        <title>HyperBEAM</title>
    </head>
    <body>
        <header>
            <div class="header-inner">
                <a href="/">
                    <div class="logo">
                        <img
                            src="https://arweave.net/Ggr1cz-jbiDS2gAVFHxkoKzmNQQD4WcMTfipWyuEmgY"
                            alt="hyperbeam-logo"
                        />
                    </div>
                </a>
                <div class="subheader-value">
                    <p>Operator:</p>
                    <button id="operator-action" disabled="true">
                        Loading...
                    </button>
                </div>
            </div>
        </header>
        <div class="view-wrapper">
            <div class="explorer-view-flex">
                <div class="bg-video">
                    <video
                        src="https://arweave.net/tJd9JJa8ap5dHHvRAAPOE4Gh6VAY4h8KpBY1gzrtVWo"
                        alt="bg-hyperbeam-video"
                        autoplay
                        loop
                        muted
                        playsinline
                    ></video>
                </div>
                <div class="explorers-wrapper">
                    <div class="explorer-view">
                        <div class="signature-wrapper border-wrapper-primary">
                            <div class="signature-line">
                                <span>Signature</span>
                                <p>...</p>
                            </div>
                            <div class="signature-line">
                                <span>Signer</span>
                                <p>...</p>
                            </div>
                        </div>
                        <div class="explorer-wrapper">
                            <div class="explorer-header">
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20"
                                    height="20"
                                    fill="#000"
                                    viewBox="0 0 256 256"
                                >
                                    <path
                                        d="M120,176h-8v-4a28,28,0,0,0-56,0v4H48a8,8,0,0,0-8,8v40a8,8,0,0,0,8,8h72a8,8,0,0,0,8-8V184A8,8,0,0,0,120,176Zm-48-4a12,12,0,0,1,24,0v4H72Zm40,44H56V192h56ZM213.66,82.34l-56-56A8,8,0,0,0,152,24H56A16,16,0,0,0,40,40v88a8,8,0,0,0,16,0V40h88V88a8,8,0,0,0,8,8h48V216H160a8,8,0,0,0,0,16h40a16,16,0,0,0,16-16V88A8,8,0,0,0,213.66,82.34ZM160,51.31,188.69,80H160Z"
                                    ></path>
                                </svg>
                                <p>Response</p>
                            </div>
                            <div
                                id="signed-headers-explorer"
                                class="explorer"
                            ></div>
                            <div class="explorer-footer">
                                <p id="headers-explorer-footer-value">
                                    (0) Headers
                                </p>
                            </div>
                        </div>
                        <div class="explorer-wrapper">
                            <div class="explorer-header">
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20"
                                    height="20"
                                    fill="#000"
                                    viewBox="0 0 256 256"
                                >
                                    <path
                                        d="M232,80a55.67,55.67,0,0,1-16.4,39.6l-30.07,30.06a8,8,0,0,1-11.31-11.32l30.07-30.06a40,40,0,1,0-56.57-56.56L117.66,81.77a8,8,0,0,1-11.32-11.32L136.4,40.4A56,56,0,0,1,232,80Zm-93.66,94.22-30.06,30.06a40,40,0,1,1-56.56-56.57l30.05-30.05a8,8,0,0,0-11.32-11.32L40.4,136.4a56,56,0,0,0,79.2,79.2l30.06-30.07a8,8,0,0,0-11.32-11.31Z"
                                    ></path>
                                </svg>
                                <p>Links</p>
                            </div>
                            <div id="links-explorer" class="explorer"></div>
                            <div class="explorer-footer">
                                <p id="links-explorer-footer-value">
                                    (0) Links
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="visual-wrapper">
                    <div class="tabs-wrapper">
                        <div class="tabs">
                            <button
                                class="tab-button hyperstate-tab-button active"
                                data-id="cacheviz@1.0/index"
                                data-tab="cacheviz-tab"
                            >
                                Cacheviz
                            </button>
                            <button
                                class="tab-button hyperstate-tab-button"
                                data-id="hyperbuddy@1.0/format"
                                data-tab="hyperbuddy-tab"
                            >
                                Hyperbuddy
                            </button>
                        </div>
                    </div>
                    <div class="visual-body"></div>
                </div>
            </div>
        </div>
        <footer>
            <div class="footer-inner">
                <div class="subheader">
                    <div class="subheader-value">
                        <p>Status:</p>
                        <div class="subheader-indicator-wrapper">
                            <div class="subheader-indicator"></div>
                            <p>Live</p>
                        </div>
                    </div>
                </div>
            </div>
        </footer>

        <script>
            function parseHeaders(input) {
                const out = {};
                input
                    .split("\n")
                    .map((l) => l.trim())
                    .filter((l) => l && l.includes(":"))
                    .forEach((line) => {
                        const idx = line.indexOf(":");
                        const key = line.slice(0, idx).trim();
                        const val = line.slice(idx + 1).trim();
                        out[key] = { data: val };
                        if (key.includes("+link")) out[key].isLink = true;
                    });
                return out;
            }

            /**
             * Parse a Signature-Input header value into structured entries.
             * @param {string} inputHeader – the raw Signature-Input header *value* (no “Signature-Input:” prefix)
             */
            function parseSignatureInput(inputHeader) {
                return inputHeader.split(/\s*,\s*/).map((entry) => {
                    // Label is everything before the first '='
                    const eq = entry.indexOf("=");
                    const label = entry.slice(0, eq).trim();

                    // Fields are inside the first "(...)"
                    const parenMatch = entry.match(/=\(\s*([^)]+)\s*\)/);
                    const fields = parenMatch
                        ? Array.from(
                              parenMatch[1].matchAll(/"([^"]+)"/g),
                              (m) => m[1]
                          )
                        : [];

                    // Pull out any ;key="value" pairs
                    const paramRegex = /;\s*([^=;\s]+)\s*=\s*"([^"]*)"/g;
                    const params = {};
                    let m;
                    while ((m = paramRegex.exec(entry)) !== null) {
                        params[m[1]] = m[2];
                    }

                    return {
                        label,
                        fields,
                        alg: params.alg || "",
                        keyid: params.keyid || "",
                        ...(params.tag ? { tag: params.tag } : {}),
                    };
                });
            }

            function joinHeaders(headers) {
                return Array.from(headers.entries())
                    .map(([name, value]) => `${name}: ${value}`)
                    .join("\n");
            }

            /**
             * Given your parsed headers object (from parseHeaders) and the raw
             * Signature-Input header value, return a new object containing
             * only those headers which were covered by the signature-input.
             */
            function filterSignedHeaders(parsedHeaders, signatureInputValue) {
                const sigInputs = parseSignatureInput(signatureInputValue);

                // Collect all the field names covered
                const covered = new Set(
                    sigInputs.flatMap((si) =>
                        si.fields.map((f) => f.toLowerCase())
                    )
                );

                // Filter parsedHeaders keys by membership in covered
                return Object.fromEntries(
                    Object.entries(parsedHeaders).filter(([headerName]) =>
                        covered.has(headerName.toLowerCase())
                    )
                );
            }

            /**
             * @param {string} sigInputRaw
             * @returns {Promise<string>} the derived “address” of the first non-HMAC signer
             */
            async function getSignerAddress(sigInputRaw) {
                const entries = parseSignatureInput(sigInputRaw);
                if (!entries.length) return "Unknown";

                // Pick the first entry whose alg isn’t hmac-sha256 (i.e. the real pubkey)
                const realEntry =
                    entries.find(
                        (e) => e.alg.toLowerCase() !== "hmac-sha256"
                    ) || entries[0];
                const rawKeyId = realEntry.keyid;

                // Now decode it to bytes (base64url → Uint8Array)
                const pubKeyBytes = base64UrlToUint8Array(rawKeyId);

                // sha-256 the public key bytes
                const hash = await crypto.subtle.digest("SHA-256", pubKeyBytes);
                const hashArr = new Uint8Array(hash);

                // base64url-encode the hash to get your “address”
                const address = btoa(String.fromCharCode(...hashArr))
                    .replace(/\+/g, "-")
                    .replace(/\//g, "_")
                    .replace(/=+$/, "");

                return address;
            }

            /** Decode base64url string → Uint8Array */
            function base64UrlToUint8Array(b64url) {
                let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
                // Pad to multiple of 4
                while (b64.length % 4) b64 += "=";
                const bin = atob(b64);
                const arr = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) {
                    arr[i] = bin.charCodeAt(i);
                }
                return arr;
            }

            async function renderExplorer(container, parsed, depth = 0) {
                const body = document.createElement("div");
                body.className = "explorer-body";

                Object.entries(parsed).forEach(
                    ([headerKey, { data, isLink }], idx, arr) => {
                        const wrapper = document.createElement("div");
                        wrapper.className = "explorer-body-row-wrapper";

                        const row = document.createElement("div");
                        row.className = "explorer-body-row";
                        row.style.paddingLeft = `${depth * 20 + 15}px`;

                        let arrow, nestedBody;
                        if (isLink) {
                            row.classList.add("explorer-action");

                            arrow = document.createElement("span");
                            arrow.className = "explorer-body-row-indicator";
                            row.appendChild(arrow);

                            wrapper._loaded = false;
                            wrapper._isOpen = false;

                            row.addEventListener("click", async () => {
                                if (!wrapper._loaded) {
                                    wrapper._loaded = true;
                                    try {
                                        const res = await fetch(
                                            `${window.location.origin}/${data}`
                                        );
                                        const raw = joinHeaders(
                                            res.headers
                                        ).trim();
                                        
                                        const parsed = parseHeaders(raw);

                                        // Get the signature-input header string
                                        const sigInputRaw =
                                            parsed["signature-input"]?.data;

                                        // If it's missing, render everything
                                        const toRender = sigInputRaw
                                            ? filterSignedHeaders(
                                                  parsed,
                                                  sigInputRaw
                                              )
                                            : parsed;

                                        await renderExplorer(
                                            nestedBody,
                                            toRender,
                                            depth + 1
                                        );
                                    } catch (e) {
                                        console.error("Fetch failed:", e);
                                    }
                                    wrapper._isOpen = true;
                                    nestedBody.style.display = "flex";
                                    row.classList.add("explorer-body-row-open");
                                    arrow.classList.add(
                                        "explorer-body-row-indicator-open"
                                    );
                                } else {
                                    wrapper._isOpen = !wrapper._isOpen;
                                    if (wrapper._isOpen) {
                                        nestedBody.style.display = "flex";
                                        row.classList.add(
                                            "explorer-body-row-open"
                                        );
                                        arrow.classList.add(
                                            "explorer-body-row-indicator-open"
                                        );
                                    } else {
                                        nestedBody.style.display = "none";
                                        row.classList.remove(
                                            "explorer-body-row-open"
                                        );
                                        arrow.classList.remove(
                                            "explorer-body-row-indicator-open"
                                        );
                                    }
                                }
                            });
                        }

                        const keySpan = document.createElement("span");
                        keySpan.textContent = headerKey + ":";
                        row.appendChild(keySpan);

                        const value = document.createElement("p");
                        if (isLink)
                            value.classList.add("explorer-body-link-value");
                        value.textContent = data;
                        row.appendChild(value);

                        wrapper.appendChild(row);

                        nestedBody = document.createElement("div");
                        nestedBody.className = "explorer-body";
                        nestedBody.style.display = "none";
                        wrapper.appendChild(nestedBody);

                        body.appendChild(wrapper);
                    }
                );

                container.appendChild(body);
            }

            function renderSignature(signature, signer) {
                const wrapper = document.querySelector(".signature-wrapper");

                while (wrapper.firstChild) {
                    wrapper.removeChild(wrapper.firstChild);
                }

                const signatureLine = document.createElement("div");
                signatureLine.classList.add("signature-line");

                const signatureKey = document.createElement("span");
                signatureKey.innerText = "Signature";
                signatureLine.appendChild(signatureKey);

                const signatureValue = document.createElement("p");
                signatureValue.innerText = signature;
                signatureValue.classList.add("signature-value", "copy-hover");
                signatureLine.appendChild(signatureValue);

                const signerLine = document.createElement("div");
                signerLine.classList.add("signature-line");

                const signerKey = document.createElement("span");
                signerKey.innerText = "Signer";
                signerLine.appendChild(signerKey);

                const signerValue = document.createElement("p");
                signerValue.innerText = signer;
                signerValue.classList.add("signer-value", "copy-hover");
                signerLine.appendChild(signerValue);

                wrapper.appendChild(signatureLine);
                wrapper.appendChild(signerLine);

                // Add class or ID here for copy tooltip
                enableTooltipAndCopy(".signature-value");
                enableTooltipAndCopy(".signer-value");
                enableTooltipAndCopy(".message-value");
                enableTooltipAndCopy("#operator-action");
            }

            function enableTooltipAndCopy(selector) {
                const el = document.querySelector(selector);
                if (!el) return;

                // Create tooltip
                const tooltip = document.createElement("div");
                tooltip.className = "custom-tooltip";
                tooltip.style.position = "absolute";
                tooltip.style.backgroundColor = "#333";
                tooltip.style.color = "#fff";
                tooltip.style.padding = "5px 10px";
                tooltip.style.borderRadius = "4px";
                tooltip.style.fontSize = "12px";
                tooltip.style.whiteSpace = "nowrap";
                tooltip.style.display = "none";
                tooltip.style.zIndex = "9999";
                tooltip.style.pointerEvents = "none";
                document.body.appendChild(tooltip);

                el.style.cursor = "pointer";

                el.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = "Click to copy";
                    tooltip.style.display = "block";
                });

                el.addEventListener("mousemove", (e) => {
                    const tooltipRect = tooltip.getBoundingClientRect();
                    tooltip.style.left = `${
                        e.clientX - tooltipRect.width / 2
                    }px`;
                    tooltip.style.top = `${
                        e.clientY - tooltipRect.height - 10
                    }px`;
                });

                el.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                });

                el.addEventListener("click", async () => {
                    try {
                        await navigator.clipboard.writeText(el.innerText);
                        tooltip.textContent = "Copied!";
                        setTimeout(() => {
                            tooltip.style.display = "none";
                        }, 1000);
                    } catch (err) {
                        console.error("Copy failed", err);
                    }
                });
            }

            async function renderInitialMessage() {
                const res = await fetch(window.location.href);
                const raw = joinHeaders(res.headers).trim();
                const parsed = parseHeaders(raw);

                const signature = res.headers.get("signature");
                if (signature) {
                    const signatureInput =
                        parsed["signature-input"]?.data ?? "";

                    const signer = signatureInput
                        ? await getSignerAddress(signatureInput)
                        : "Unknown";

                    renderSignature(signature, signer);
                }

                // Get the signature-input header string
                const sigInputRaw = parsed["signature-input"]?.data;

                // If it's missing, render everything
                const toRender = sigInputRaw
                    ? filterSignedHeaders(parsed, sigInputRaw)
                    : parsed;

                renderExplorer(
                    document.getElementById("signed-headers-explorer"),
                    toRender,
                    0
                );

                document.getElementById(
                    "headers-explorer-footer-value"
                ).innerText = `(${Object.keys(toRender).length}) Headers`;

                let links = {};
                for (const key of Object.keys(parsed)) {
                    if (key.includes("+link")) {
                        links[key] = parsed[key];
                    }
                }

                if (Object.keys(links).length > 0) {
                    renderExplorer(
                        document.getElementById("links-explorer"),
                        links,
                        0
                    );

                    document.getElementById(
                        "links-explorer-footer-value"
                    ).innerText = `(${Object.keys(links).length}) Links`;
                }
            }

            document.addEventListener("DOMContentLoaded", () => {
                const container = document.querySelector(".visual-body");
                const tabs = document.querySelectorAll(".tab-button");

                const makeIframe = (device) => {
                    const iframe = document.createElement("iframe");
                    iframe.src = `${window.location.href}/~${device}`;
                    iframe.id = "preview-frame";
                    iframe.style.width = "100%";
                    iframe.style.height = "100%";
                    return iframe;
                };

                const initial = document.querySelector(".tab-button.active");
                if (initial)
                    container.appendChild(makeIframe(initial.dataset.id));

                tabs.forEach((tab) => {
                    tab.addEventListener("click", () => {
                        document
                            .querySelectorAll(".tab-button.active")
                            .forEach((t) => t.classList.remove("active"));
                        tab.classList.add("active");

                        const old = document.getElementById("preview-frame");
                        if (old) old.remove();

                        container.appendChild(makeIframe(tab.dataset.id));
                    });
                });
            });

            renderInitialMessage();
        </script>

        <script type="module">
            import { fetchInfo } from "/~hyperbuddy@1.0/devices.js";

            fetchInfo();
        </script>
    </body>
</html>
